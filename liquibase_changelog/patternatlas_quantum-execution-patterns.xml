<?xml version="1.1" encoding="UTF-8" standalone="no"?>
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog" xmlns:ext="http://www.liquibase.org/xml/ns/dbchangelog-ext" xmlns:pro="http://www.liquibase.org/xml/ns/pro" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd http://www.liquibase.org/xml/ns/pro http://www.liquibase.org/xml/ns/pro/liquibase-pro-latest.xsd http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">
    <changeSet author="Daniel Georg" id="1690883645063-2">
        <insert tableName="directed_edge">
            <column name="id" value="ed27346d-28d9-4436-902d-d3c24bc5e731"/>
            <column name="description" value="&quot;In the NISQ-era it is advised to use prioritization for execution.&quot;"/>
            <column name="type" value="canBeUsedWith"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="source_id" value="70adfd6f-0648-47cf-88ff-0212b882a262"/>
            <column name="target_id" value="bc795a9b-7977-4e01-b513-f9f5aba38aa7"/>
        </insert>
		<insert tableName="directed_edge">
            <column name="id" value="afcf3bca-1993-466f-86b6-4ba32019197f"/>
            <column name="description" value="&quot;In the NISQ-era it is advised to use prioritization for execution.&quot;"/>
            <column name="type" value="canBeUsedWith"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="source_id" value="70adfd6f-0648-47cf-88ff-0212b882a262"/>
            <column name="target_id" value="27a5d147-a323-4c6a-84ef-45d80cae923d"/>
        </insert>
		<insert tableName="directed_edge">
            <column name="id" value="b3235a7d-db5b-42ae-b61c-0e495f8030d2"/>
            <column name="description" value="&quot;In the NISQ-era it is advised to use prioritization for execution.&quot;"/>
            <column name="type" value="canBeUsedWith"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="source_id" value="70adfd6f-0648-47cf-88ff-0212b882a262"/>
            <column name="target_id" value="da93f915-7f4c-49df-99d0-80d91f26a337"/>
        </insert>
		<insert tableName="directed_edge">
            <column name="id" value="1e1c0190-c562-4cee-8170-f727297439b2"/>
            <column name="description" value="&quot;Reduce the waiting times of the workflow.&quot;"/>
            <column name="type" value="canBeUsedWith"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="source_id" value="3f3d5582-1af9-4a23-93f5-5d0474b2b42c"/>
            <column name="target_id" value="70adfd6f-0648-47cf-88ff-0212b882a262"/>
        </insert>
		        <insert tableName="directed_edge">
            <column name="id" value="73ae8e24-299f-4789-b19e-e0e7de4adf25"/>
            <column name="description" value="&quot;Integration of several distinct quantum applications.&quot;"/>
            <column name="type" value="canBeUsedWith"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="source_id" value="3f3d5582-1af9-4a23-93f5-5d0474b2b42c"/>
            <column name="target_id" value="9af072e8-875b-4e7d-980a-98cc6e0e7fd6"/>
        </insert>
		<insert tableName="directed_edge">
            <column name="id" value="cf13b143-5e47-4494-8d6c-78fccac45c1b"/>
            <column name="description" value="&quot;Implementation of a VQA can be executed in either variant.&quot;"/>
            <column name="type" value="canBeUsedWith"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="source_id" value="9af072e8-875b-4e7d-980a-98cc6e0e7fd6"/>
            <column name="target_id" value="bc795a9b-7977-4e01-b513-f9f5aba38aa7"/>
        </insert>
		<insert tableName="directed_edge">
            <column name="id" value="4be80353-2738-4256-a1de-0dfc6532a3e2"/>
            <column name="description" value="&quot;Implementation of the VQE can be executed with either variant.&quot;"/>
            <column name="type" value="canBeUsedWith"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="source_id" value="9af072e8-875b-4e7d-980a-98cc6e0e7fd6"/>
            <column name="target_id" value="27a5d147-a323-4c6a-84ef-45d80cae923d"/>
        </insert>
		<insert tableName="directed_edge">
            <column name="id" value="58f37772-7483-4161-b161-09b580e850e9"/>
            <column name="description" value="&quot;Implementation of the QAOA can be executed with either variant.&quot;"/>
            <column name="type" value="canBeUsedWith"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="source_id" value="9af072e8-875b-4e7d-980a-98cc6e0e7fd6"/>
            <column name="target_id" value="da93f915-7f4c-49df-99d0-80d91f26a337"/>
        </insert>
		<insert tableName="directed_edge">
            <column name="id" value="c0748f09-ab61-433c-8d44-c85e7c4cb0f3"/>
            <column name="description" value="&quot;Combination of pre-deployment and a form of prioritization.&quot;"/>
            <column name="type" value="canBeUsedWith"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="source_id" value="9af072e8-875b-4e7d-980a-98cc6e0e7fd6"/>
            <column name="target_id" value="70adfd6f-0648-47cf-88ff-0212b882a262"/>
        </insert>
        <insert tableName="directed_edge">
            <column name="id" value="47abbbff-ab5a-42ce-a83e-1b8cacd11988"/>
            <column name="description" value="&quot;Can be used as post-processing step in a pre-deployed application.&quot;"/>
            <column name="type" value="canBeUsedWith"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="source_id" value="9af072e8-875b-4e7d-980a-98cc6e0e7fd6"/>
            <column name="target_id" value="ed3af509-904e-4732-8113-215d65a7d53d"/>
        </insert>
        <insert tableName="directed_edge">
            <column name="id" value="c4d12945-a2cf-47a8-b9bc-7ac609107584"/>
            <column name="description" value="&quot;Can be used as pre-processing in a pre-deployed application.&quot;"/>
            <column name="type" value="canBeUsedWith"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="source_id" value="9af072e8-875b-4e7d-980a-98cc6e0e7fd6"/>
            <column name="target_id" value="312bc9d3-26c0-40ae-b90b-56effd136c0d"/>
        </insert>
		<insert tableName="directed_edge">
            <column name="id" value="dc1a833e-9c50-4935-b29c-46ec0522663f"/>
            <column name="description" value="&quot;Can be used while modeling quantum circuits&quot;"/>
            <column name="type" value="canBeUsedWith"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="source_id" value="5850c6ab-5c87-4331-8439-73692a403228"/>
            <column name="target_id" value="2229a430-fe92-4411-9d72-d10dd1d8da14"/>
        </insert>
        <insert tableName="directed_edge">
            <column name="id" value="7571cbac-f345-4a07-aced-42a7a6a2dd29"/>
            <column name="description" value="&quot;Quantum Circuit can be integrated with pre- and post-processing. &quot;"/>
            <column name="type" value="isRelatedTo"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="source_id" value="5850c6ab-5c87-4331-8439-73692a403228"/>
            <column name="target_id" value="c450e0ce-c55f-4b72-afe9-e9e2c7e4c091"/>
        </insert>
        <insert tableName="pattern">
            <column name="id" value="c450e0ce-c55f-4b72-afe9-e9e2c7e4c091"/>
            <column name="name" value="Ad-hoc Hybrid Code Execution"/>
            <column name="uri" value="https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/ad-hocHybridCodeExecution"/>
            <column name="content" value="{&quot;Alias&quot;: &quot;â€“&quot;, &quot;Forces&quot;: &quot;Enter your input for this section here.Similar to STANDALONE CIRCUIT EXECUTION. However, using this pattern prevents integrating the classical pre- and post-processing steps. Using local or provider-managed development environments reduces management efforts, e.g., execution of quantum and classical code via single commands.&quot;, &quot;Intent&quot;: &quot;How to execute quantum circuits with classical pre- and post-processing steps with no additional deployment or integration requirements?&quot;, &quot;Result&quot;: &quot;This pattern offers developers more control over the execution of quantum and classical parts, e.g., token management or request construction via SDKs, than the STANDALONE CIRCUIT EXECUTION pattern. However, integration with external applications is often limited, which makes it unsuitable for designing larger applications or running several distinct computations. After a successful ad-hoc execution of quantum circuits and their classical pre- and post-processing steps, all artifacts can be packaged and deployed to a compatible offering or published via application marketplaces to simplify their reuse.&quot;, &quot;Context&quot;: &quot;Often it is necessary to execute standalone quantum circuits with their classical pre- and post-processing steps without incurring extra overhead to deploy, run, and manage them in the cloud.&quot;, &quot;Examples&quot;: &quot;Enter your input for this section here.&quot;, &quot;Solution&quot;: &quot;Use provider-managed code editors or local editors with manually-added token-based authentication. Figure 3 shows the execution of quantum circuits and classical code using AD-HOC HYBRID CODE EXECUTION. The classical pre- and post-processing steps run in a local or remote code editor. The quantum circuits are executed via function calls, often provided by the programming language or quantum SDK, transmitting the quantum circuit to the quantum cloud offering.\n\n![Solution Sketch for Ad-hoc Hybrid Code Execution](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/ad-hoc-code.svg)&quot;, &quot;Known Uses&quot;: &quot;This pattern is supported by various vendors. For example, iPython notebooks are provided as remote code editors by Amazon with Braket [[AWS, 2023]](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html), IBM with Qiskit [[IBM, 2023b]](https://quantum-computing.ibm.com/lab/docs/iql/), and Google with Cirq [[Google, 2020]](https://colab.research.google.com/github/quantumlib/Cirq/blob/master/docs/tutorials/google/start.ipynb). Local code editors support different languages via dedicated packages, e.g., Rigettis pyQuil and Forest SDK [[Rigetti, 2023a]](https://pyquil-docs.rigetti.com/en/v3.3.3/). Authentication to quantum services is then performed via manual configuration of access tokens.&quot;, &quot;Related Pattern&quot;: &quot;Classical pre-processing steps include STATE PREPARATION, which can be done using, e.g., BASIS ENCODING or ANGLE ENCODING [[Weigold et al., 2020]](https://hillside.net/plop/2020/papers/weigold.pdf). Post-processing steps comprise, e.g., READOUT ERROR MITIGATION [[Beisel et al., 2022]](https://www.thinkmind.org/index.php?view=article&amp;articleid=patterns_2022_2_10_70007). If multiple quantum circuits must be executed, PRIORITIZED EXECUTION can be used to increase efficiency.&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/ad-hoc-code-thin.svg"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;â€“&quot;, &quot;Forces&quot;: &quot;Enter your input for this section here.Similar to STANDALONE CIRCUIT EXECUTION. However, using this pattern prevents integrating the classical pre- and post-processing steps. Using local or provider-managed development environments reduces management efforts, e.g., execution of quantum and classical code via single commands.&quot;, &quot;Intent&quot;: &quot;How to execute quantum circuits with classical pre- and post-processing steps with no additional deployment or integration requirements?&quot;, &quot;Result&quot;: &quot;This pattern offers developers more control over the execution of quantum and classical parts, e.g., token management or request construction via SDKs, than the STANDALONE CIRCUIT EXECUTION pattern. However, integration with external applications is often limited, which makes it unsuitable for designing larger applications or running several distinct computations. After a successful ad-hoc execution of quantum circuits and their classical pre- and post-processing steps, all artifacts can be packaged and deployed to a compatible offering or published via application marketplaces to simplify their reuse.&quot;, &quot;Context&quot;: &quot;Often it is necessary to execute standalone quantum circuits with their classical pre- and post-processing steps without incurring extra overhead to deploy, run, and manage them in the cloud.&quot;, &quot;Examples&quot;: &quot;Enter your input for this section here.&quot;, &quot;Solution&quot;: &quot;Use provider-managed code editors or local editors with manually-added token-based authentication. Figure 3 shows the execution of quantum circuits and classical code using AD-HOC HYBRID CODE EXECUTION. The classical pre- and post-processing steps run in a local or remote code editor. The quantum circuits are executed via function calls, often provided by the programming language or quantum SDK, transmitting the quantum circuit to the quantum cloud offering.\n\n![Solution Sketch for Ad-hoc Hybrid Code Execution](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/ad-hoc-code.svg)&quot;, &quot;Known Uses&quot;: &quot;This pattern is supported by various vendors. For example, iPython notebooks are provided as remote code editors by Amazon with Braket [[AWS, 2023]](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html), IBM with Qiskit [[IBM, 2023b]](https://quantum-computing.ibm.com/lab/docs/iql/), and Google with Cirq [[Google, 2020]](https://colab.research.google.com/github/quantumlib/Cirq/blob/master/docs/tutorials/google/start.ipynb). Local code editors support different languages via dedicated packages, e.g., Rigettis pyQuil and Forest SDK [[Rigetti, 2023a]](https://pyquil-docs.rigetti.com/en/v3.3.3/). Authentication to quantum services is then performed via manual configuration of access tokens.&quot;, &quot;Related Pattern&quot;: &quot;Classical pre-processing steps include STATE PREPARATION, which can be done using, e.g., BASIS ENCODING or ANGLE ENCODING [[Weigold et al., 2020]](https://hillside.net/plop/2020/papers/weigold.pdf). Post-processing steps comprise, e.g., READOUT ERROR MITIGATION [[Beisel et al., 2022]](https://www.thinkmind.org/index.php?view=article&amp;articleid=patterns_2022_2_10_70007). If multiple quantum circuits must be executed, PRIORITIZED EXECUTION can be used to increase efficiency.&quot;}"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="paper_ref" value="https://www.scitepress.org/Link.aspx?doi=10.5220/0012057700003538"/>
            <column name="deployment_modeling_behavior_pattern"/>
            <column name="deployment_modeling_structure_pattern"/>
        </insert>
        <insert tableName="pattern">
            <column name="id" value="5850c6ab-5c87-4331-8439-73692a403228"/>
            <column name="name" value="Standalone Circuit Execution"/>
            <column name="uri" value="https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/standaloneCircuitExecution"/>
            <column name="content" value="{&quot;Alias&quot;: &quot;â€“&quot;, &quot;Forces&quot;: &quot;Quantum offerings vary in features and capabilities. Use of advanced offerings for simple use cases may incur unnecessary management overhead and even block the task due to lacking technical expertise, e.g., deployment automation and integration technologies. In contrast, certain quantum offerings reduce the amount of required management efforts, e.g., by generating execution requests automatically.&quot;, &quot;Intent&quot;: &quot;How to execute standalone quantum circuits that impose no deployment or integration requirements?&quot;, &quot;Result&quot;: &quot;Quantum offerings supporting this pattern provide a simple way for executing quantum circuits. However, classical pre- and post-processing steps can not be defined using these offerings. Thus, this style of execution is not suitable for running larger quantum applications and integration with external applications is either very limited or not supported at all. Additionally, running computations with this pattern cannot take advantage of prioritized executions.&quot;, &quot;Context&quot;: &quot;In some scenarios, only standalone quantum circuits need to be executed, such as circuit design and testing or education. Thereby, it is beneficial to execute quantum circuits with minimal effort and required knowledge about different quantum offerings as well as deployment or integration technologies.&quot;, &quot;Examples&quot;: &quot;Enter your input for this section here.&quot;, &quot;Solution&quot;: &quot;Execute quantum circuits via quantum offerings that do not require implementing custom deployment logic or integration with other services. Figure 2 shows the solution sketch in which distinct quantum circuits are executed using offerings capable of creating and executing circuits. This includes dedicated graphical circuit composers or text-based tools transmitting the quantum circuits to the offering. Typically, providers are responsible for the majority of the management efforts, e.g., deployment of circuits and authentication to the underlying quantum offering.\n\n![Solution Sketch for Standalone Circuit Execution](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/ad-hoc-circuit.svg)&quot;, &quot;Known Uses&quot;: &quot;Vendors such as IBM [[IBM, 2023b]](https://quantum-computing.ibm.com/lab/docs/iql/) or Pasqal [[Pasqal, 2023]](https://pasqal.io ) support this pattern via graphical circuit composer services that enable modeling quantum circuits visually and executing them from the GUI, hence, abstracting away the authentication and construction of the invocation request.&quot;, &quot;Related Pattern&quot;: &quot;In scenarios when quantum circuits are executed for testing purposes and afterwards require the integration with classical pre- and post-processing steps, the AD-HOC HYBRID CODE EXECUTION can be used. Additionally, different quantum computing patterns can be used while modeling quantum circuits, e.g., AMPLITUDE AMPLIFICATION or UNIFORM SUPERPOSITION [[Leymann, 2019]](https://link.springer.com/chapter/10.1007/978-3-030-14082-3_19).&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/ad-hoc-circuit-thin.svg"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;â€“&quot;, &quot;Forces&quot;: &quot;Quantum offerings vary in features and capabilities. Use of advanced offerings for simple use cases may incur unnecessary management overhead and even block the task due to lacking technical expertise, e.g., deployment automation and integration technologies. In contrast, certain quantum offerings reduce the amount of required management efforts, e.g., by generating execution requests automatically.&quot;, &quot;Intent&quot;: &quot;How to execute standalone quantum circuits that impose no deployment or integration requirements?&quot;, &quot;Result&quot;: &quot;Quantum offerings supporting this pattern provide a simple way for executing quantum circuits. However, classical pre- and post-processing steps can not be defined using these offerings. Thus, this style of execution is not suitable for running larger quantum applications and integration with external applications is either very limited or not supported at all. Additionally, running computations with this pattern cannot take advantage of prioritized executions.&quot;, &quot;Context&quot;: &quot;In some scenarios, only standalone quantum circuits need to be executed, such as circuit design and testing or education. Thereby, it is beneficial to execute quantum circuits with minimal effort and required knowledge about different quantum offerings as well as deployment or integration technologies.&quot;, &quot;Examples&quot;: &quot;Enter your input for this section here.&quot;, &quot;Solution&quot;: &quot;Execute quantum circuits via quantum offerings that do not require implementing custom deployment logic or integration with other services. Figure 2 shows the solution sketch in which distinct quantum circuits are executed using offerings capable of creating and executing circuits. This includes dedicated graphical circuit composers or text-based tools transmitting the quantum circuits to the offering. Typically, providers are responsible for the majority of the management efforts, e.g., deployment of circuits and authentication to the underlying quantum offering.\n\n![Solution Sketch for Standalone Circuit Execution](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/ad-hoc-circuit.svg)&quot;, &quot;Known Uses&quot;: &quot;Vendors such as IBM [[IBM, 2023b]](https://quantum-computing.ibm.com/lab/docs/iql/) or Pasqal [[Pasqal, 2023]](https://pasqal.io ) support this pattern via graphical circuit composer services that enable modeling quantum circuits visually and executing them from the GUI, hence, abstracting away the authentication and construction of the invocation request.&quot;, &quot;Related Pattern&quot;: &quot;In scenarios when quantum circuits are executed for testing purposes and afterwards require the integration with classical pre- and post-processing steps, the AD-HOC HYBRID CODE EXECUTION can be used. Additionally, different quantum computing patterns can be used while modeling quantum circuits, e.g., AMPLITUDE AMPLIFICATION or UNIFORM SUPERPOSITION [[Leymann, 2019]](https://link.springer.com/chapter/10.1007/978-3-030-14082-3_19).&quot;}"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="paper_ref" value="https://www.scitepress.org/Link.aspx?doi=10.5220/0012057700003538"/>
            <column name="deployment_modeling_behavior_pattern"/>
            <column name="deployment_modeling_structure_pattern"/>
        </insert>
        <insert tableName="pattern">
            <column name="id" value="9af072e8-875b-4e7d-980a-98cc6e0e7fd6"/>
            <column name="name" value="Pre-deployed Execution"/>
            <column name="uri" value="https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/pre-deployedExecution"/>
            <column name="content" value="{&quot;Alias&quot;: &quot;â€“&quot;, &quot;Forces&quot;: &quot;Quantum service offerings vary significantly feature-wise and often rely on different authentication mechanisms, proprietary formats, and SDKs. Additional technical expertise may be required to successfully execute a provided quantum circuit with its pre- and post-processing steps that can be hosted separately, e.g., due to data processing requirements. In certain cases, it is more beneficial to execute quantum and classical parts of the application in proximity of each other, e.g., to reduce the networking overhead.&quot;, &quot;Intent&quot;: &quot;How to execute quantum circuits with classical pre- and post-processing steps that have custom deployment requirements?&quot;, &quot;Result&quot;: &quot;The deployment of quantum applications is decoupled from its execution, hence, enabling the invocation by other users or integration with other applications, e.g., a pre-deployed VQA can be subsumed as a part of another application. In the case of hybrid runtimes, the pre-deployed application benefits from provider-managed execution transparency but is locked into the requirements and limitations of the underlying offering. In the Distributed Deployment variant, developers can benefit from combining different services for specific parts of the application.&quot;, &quot;Context&quot;: &quot;Most quantum algorithms are hybrid, e.g., VQAs contain a hybrid loop with many successive executions of parameterized quantum circuits with optimization steps in-between performed on classical hardware [[Cerezo et al., 2021]](https://www.nature.com/articles/s42254-021-00348-9). Further, quantum devices are accessed via the cloud and to execute a circuit, it is queued in the job-queue of the respective service, which may not support the execution of classical code parts. Thus, a quantum circuit and its classical pre- and post-processing steps may need to be deployed in a specific manner, e.g., together or using specific combinations of cloud service offerings.&quot;, &quot;Examples&quot;: &quot;Enter your input for this section here.&quot;, &quot;Solution&quot;: &quot; Pre-deploy the quantum circuit with its pre- and post-processing steps either on (i) a single quantum offering that supports execution of quantum and classical parts, or (ii) a specific combination of quantum and cloud offerings that fulfills the given deployment requirements. Figure 4 shows the solution sketch of this pattern: In *Step 1*, the quantum and classical parts are deployed according to deployment preferences. The subsequent execution and fetching of the results shown in *Steps 2&amp;3* can be done independently by developers or client applications.\n\n![Solution Sketch for Pre-deployed Execution](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/pre-deployed-single-column.svg)\n\n\n**Variants:** One deployment target option in *Step 1* is a Hybrid Execution Environment offering that can speed up the interaction between quantum and classical computations. Hence, they reduce the network overhead and queuing times for many successive quantum circuit executions. Another variant is a Distributed Deployment in which parts of the quantum application are deployed on a combination of different cloud offerings. Implementation of quantum and classical parts, as well as their deployment models, depend on chosen technologies, e.g., implementation of QAOA for Qiskit Runtime would impose more coding and deployment modeling constraints compared to more general deployment scenarios such as packaging the quantum application as one or more containers that can be deployed to a container orchestration engine such as Kubernetes and later executed via client requests.&quot;, &quot;Known Uses&quot;: &quot;Qiskit Runtime [[Qiskit, 2023a]](https://qiskit.org/documentation/) is a service from IBM, which offers a hybrid execution environment that enables deploying a quantum application packaged as a Python file with a JSON meta-data file, and subsequently executing it via a publicly available HTTP endpoint. A similar service is Amazon Braket Hybrid Jobs  [[AWS, 2023]](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html). Microsoft also introduced the hybrid execution environment and shows an example how to use it [[Frachon, 2023]](https://devblogs.microsoft.com/qsharp/azure-quantum-unlocks-the-next-generation-of-hybrid-quantum-computing/). For distributed deployment scenarios, various cloud offerings can be employed for classical tasks. Example offerings from AWS include AWS Lambda for executing classical Python code, AWS S3 as an object storage offering, and Amazon Cloudwatch for monitoring.&quot;, &quot;Related Pattern&quot;: &quot;Pre-deployed execution of hybrid applications improves the reusability of different algorithms such as the VQA and the more concrete patterns like VQE and QAOA [[Weigold et al., 2021b]](https://doi.org/10.1007/978-3-030-87568-8_2). Additionally, pre- and post-processing steps, such as STATE PREPARATION [[Leymann, 2019]](https://link.springer.com/chapter/10.1007/978-3-030-14082-3_19) or READOUT ERROR MITIGATION [[Beisel et al., 2022]](https://www.thinkmind.org/index.php?view=article&amp;articleid=patterns_2022_2_10_70007), can be applied to run on preferred execution targets.&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/pre-deployed-execution-thin.svg"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;â€“&quot;, &quot;Forces&quot;: &quot;Quantum service offerings vary significantly feature-wise and often rely on different authentication mechanisms, proprietary formats, and SDKs. Additional technical expertise may be required to successfully execute a provided quantum circuit with its pre- and post-processing steps that can be hosted separately, e.g., due to data processing requirements. In certain cases, it is more beneficial to execute quantum and classical parts of the application in proximity of each other, e.g., to reduce the networking overhead.&quot;, &quot;Intent&quot;: &quot;How to execute quantum circuits with classical pre- and post-processing steps that have custom deployment requirements?&quot;, &quot;Result&quot;: &quot;The deployment of quantum applications is decoupled from its execution, hence, enabling the invocation by other users or integration with other applications, e.g., a pre-deployed VQA can be subsumed as a part of another application. In the case of hybrid runtimes, the pre-deployed application benefits from provider-managed execution transparency but is locked into the requirements and limitations of the underlying offering. In the Distributed Deployment variant, developers can benefit from combining different services for specific parts of the application.&quot;, &quot;Context&quot;: &quot;Most quantum algorithms are hybrid, e.g., VQAs contain a hybrid loop with many successive executions of parameterized quantum circuits with optimization steps in-between performed on classical hardware [[Cerezo et al., 2021]](https://www.nature.com/articles/s42254-021-00348-9). Further, quantum devices are accessed via the cloud and to execute a circuit, it is queued in the job-queue of the respective service, which may not support the execution of classical code parts. Thus, a quantum circuit and its classical pre- and post-processing steps may need to be deployed in a specific manner, e.g., together or using specific combinations of cloud service offerings.&quot;, &quot;Examples&quot;: &quot;Enter your input for this section here.&quot;, &quot;Solution&quot;: &quot; Pre-deploy the quantum circuit with its pre- and post-processing steps either on (i) a single quantum offering that supports execution of quantum and classical parts, or (ii) a specific combination of quantum and cloud offerings that fulfills the given deployment requirements. Figure 4 shows the solution sketch of this pattern: In *Step 1*, the quantum and classical parts are deployed according to deployment preferences. The subsequent execution and fetching of the results shown in *Steps 2&amp;3* can be done independently by developers or client applications.\n\n![Solution Sketch for Pre-deployed Execution](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/pre-deployed-single-column.svg)\n\n\n**Variants:** One deployment target option in *Step 1* is a Hybrid Execution Environment offering that can speed up the interaction between quantum and classical computations. Hence, they reduce the network overhead and queuing times for many successive quantum circuit executions. Another variant is a Distributed Deployment in which parts of the quantum application are deployed on a combination of different cloud offerings. Implementation of quantum and classical parts, as well as their deployment models, depend on chosen technologies, e.g., implementation of QAOA for Qiskit Runtime would impose more coding and deployment modeling constraints compared to more general deployment scenarios such as packaging the quantum application as one or more containers that can be deployed to a container orchestration engine such as Kubernetes and later executed via client requests.&quot;, &quot;Known Uses&quot;: &quot;Qiskit Runtime [[Qiskit, 2023a]](https://qiskit.org/documentation/) is a service from IBM, which offers a hybrid execution environment that enables deploying a quantum application packaged as a Python file with a JSON meta-data file, and subsequently executing it via a publicly available HTTP endpoint. A similar service is Amazon Braket Hybrid Jobs  [[AWS, 2023]](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html). Microsoft also introduced the hybrid execution environment and shows an example how to use it [[Frachon, 2023]](https://devblogs.microsoft.com/qsharp/azure-quantum-unlocks-the-next-generation-of-hybrid-quantum-computing/). For distributed deployment scenarios, various cloud offerings can be employed for classical tasks. Example offerings from AWS include AWS Lambda for executing classical Python code, AWS S3 as an object storage offering, and Amazon Cloudwatch for monitoring.&quot;, &quot;Related Pattern&quot;: &quot;Pre-deployed execution of hybrid applications improves the reusability of different algorithms such as the VQA and the more concrete patterns like VQE and QAOA [[Weigold et al., 2021b]](https://doi.org/10.1007/978-3-030-87568-8_2). Additionally, pre- and post-processing steps, such as STATE PREPARATION [[Leymann, 2019]](https://link.springer.com/chapter/10.1007/978-3-030-14082-3_19) or READOUT ERROR MITIGATION [[Beisel et al., 2022]](https://www.thinkmind.org/index.php?view=article&amp;articleid=patterns_2022_2_10_70007), can be applied to run on preferred execution targets.&quot;}"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="paper_ref" value="https://www.scitepress.org/Link.aspx?doi=10.5220/0012057700003538"/>
            <column name="deployment_modeling_behavior_pattern"/>
            <column name="deployment_modeling_structure_pattern"/>
        </insert>
        <insert tableName="pattern">
            <column name="id" value="3f3d5582-1af9-4a23-93f5-5d0474b2b42c"/>
            <column name="name" value="Orchestrated Execution"/>
            <column name="uri" value="https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/orchestratedExecution"/>
            <column name="content" value="{&quot;Alias&quot;: &quot;â€“&quot;, &quot;Forces&quot;: &quot;Quantum devices and the corresponding quantum cloud offerings vary strongly in characteristics, such as the number of available qubits, incurred costs for the execution, or queuing times [[Tannu and Qureshi, 2019]](https://dl.acm.org/doi/10.1145/3297858.3304007), [[Vietz et al., 2021]](http://ceur-ws.org/Vol-3008/paper1.pdf). The orchestration of parts running in heterogeneous environments can get unmanageable without external orchestration tools, e.g., as there could be long invocation chains, complex data transfers, data format transformations, and interactions with various heterogeneous APIs.&quot;, &quot;Intent&quot;: &quot;How to ensure the control and data flow for quantum applications comprising one or more quantum circuits with corresponding classical pre- and post-processing steps?&quot;, &quot;Result&quot;: &quot;The classical code as well as the quantum circuits required to realize a quantum application are separated from the workflow model defining how they are integrated. This increases modularity and enables the reuse of existing code, decreasing development time and cost. Furthermore, by using workflows, quantum applications can benefit from the reliability, scalability, and robustness of workflow engines [[Leymann and Barzen, 2021a]](https://arxiv.org/abs/2103.04320). Finally, also the usage of various heterogeneous quantum and classical cloud offerings with different functionalities is supported. However, the need to model orchestrations to enact them on specialized middleware requires additional expertise and may result in overhead for simple use cases such as circuit design and testing.&quot;, &quot;Context&quot;: &quot;Most quantum algorithms are hybrid, i.e., parts are executed on quantum devices, and others run on classical hardware [[Leymann and Barzen, 2020]](https://arxiv.org/abs/2103.04320). Furthermore, quantum applications can involve multiple quantum algorithms and additional classical parts, e.g., interacting with the user or loading data from a database. These parts must be orchestrated, i.e., the control and data flow between them must be ensured.&quot;, &quot;Examples&quot;: &quot;Enter your input for this section here.&quot;, &quot;Solution&quot;: &quot;Utilize a workflow language to model the quantum and classical parts as tasks within a workflow model [[Weder et al., 2020b]](https://ieeexplore.ieee.org/abstract/document/9302814) as shown in Figure 6. The workflow model can then be deployed to a workflow engine, which orchestrates the quantum and classical parts by invoking them in the specified order and ensuring the required data flow (Ellis, 1999). Thereby, the invocation of heterogeneous offerings, as well as features such as data format transformation is provided by the workflow engine [[Leymann and Roller, 2000]](https://www.econbiz.de/Record/production-workflow-concepts-and-techniques-leymann-frank/10001377705). While there exist workflow offerings specifically targeting the quantum computing domain, e.g., providing some pre-implemented quantum algorithms, standardized workflow languages and corresponding workflow engines can also be employed to benefit from their maturity and rich feature sets.\n\n![Solution Sketch for Orchestrated Execution](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/orchestrated.svg)&quot;, &quot;Known Uses&quot;: &quot;Examples of standardized workflow languages are Business Process Model and Notation (BPMN) [[Object Management Group, 2010]](https://www.omg.org/spec/BPMN/2.0/PDF) or Business Process Execution Language (BPEL) (OASIS, 2007). For the execution of these workflow models, different workflow engines are available, e.g., the Camunda BPMN engine [[Camunda Services, 2023]](https://docs.camunda.io). Furthermore, there exists a quantum-specific modeling extension to ease the modeling of workflows in the quantum computing domain [[Weder et al., 2020b]](https://ieeexplore.ieee.org/abstract/document/9302814). Quantum-specific orchestration tools comprise Orquestra by Zapata [[Zapata, 2022]](https://www.zapatacomputing.com/orquestra), which uses a custom YAML-based language, and Covalent by Agnostiq [[Agnostiq, 2023]](https://agnostiq.ai/covalent/), a quantum orchestration platform that requires specifying control flow via a Python-based domain-specific language.&quot;, &quot;Related Pattern&quot;: &quot;If multiple quantum circuits have to be executed by the workflow, the PRIORITIZED EXECUTION pattern can be used to reduce waiting times. Further, this pattern can be applied to integrate several distinct quantum applications made available using the PRE-DEPLOYED EXECUTION pattern.&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/orchestrated-execution-thin.svg"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;â€“&quot;, &quot;Forces&quot;: &quot;Quantum devices and the corresponding quantum cloud offerings vary strongly in characteristics, such as the number of available qubits, incurred costs for the execution, or queuing times [[Tannu and Qureshi, 2019]](https://dl.acm.org/doi/10.1145/3297858.3304007), [[Vietz et al., 2021]](http://ceur-ws.org/Vol-3008/paper1.pdf). The orchestration of parts running in heterogeneous environments can get unmanageable without external orchestration tools, e.g., as there could be long invocation chains, complex data transfers, data format transformations, and interactions with various heterogeneous APIs.&quot;, &quot;Intent&quot;: &quot;How to ensure the control and data flow for quantum applications comprising one or more quantum circuits with corresponding classical pre- and post-processing steps?&quot;, &quot;Result&quot;: &quot;The classical code as well as the quantum circuits required to realize a quantum application are separated from the workflow model defining how they are integrated. This increases modularity and enables the reuse of existing code, decreasing development time and cost. Furthermore, by using workflows, quantum applications can benefit from the reliability, scalability, and robustness of workflow engines [[Leymann and Barzen, 2021a]](https://arxiv.org/abs/2103.04320). Finally, also the usage of various heterogeneous quantum and classical cloud offerings with different functionalities is supported. However, the need to model orchestrations to enact them on specialized middleware requires additional expertise and may result in overhead for simple use cases such as circuit design and testing.&quot;, &quot;Context&quot;: &quot;Most quantum algorithms are hybrid, i.e., parts are executed on quantum devices, and others run on classical hardware [[Leymann and Barzen, 2020]](https://arxiv.org/abs/2103.04320). Furthermore, quantum applications can involve multiple quantum algorithms and additional classical parts, e.g., interacting with the user or loading data from a database. These parts must be orchestrated, i.e., the control and data flow between them must be ensured.&quot;, &quot;Examples&quot;: &quot;Enter your input for this section here.&quot;, &quot;Solution&quot;: &quot;Utilize a workflow language to model the quantum and classical parts as tasks within a workflow model [[Weder et al., 2020b]](https://ieeexplore.ieee.org/abstract/document/9302814) as shown in Figure 6. The workflow model can then be deployed to a workflow engine, which orchestrates the quantum and classical parts by invoking them in the specified order and ensuring the required data flow (Ellis, 1999). Thereby, the invocation of heterogeneous offerings, as well as features such as data format transformation is provided by the workflow engine [[Leymann and Roller, 2000]](https://www.econbiz.de/Record/production-workflow-concepts-and-techniques-leymann-frank/10001377705). While there exist workflow offerings specifically targeting the quantum computing domain, e.g., providing some pre-implemented quantum algorithms, standardized workflow languages and corresponding workflow engines can also be employed to benefit from their maturity and rich feature sets.\n\n![Solution Sketch for Orchestrated Execution](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/orchestrated.svg)&quot;, &quot;Known Uses&quot;: &quot;Examples of standardized workflow languages are Business Process Model and Notation (BPMN) [[Object Management Group, 2010]](https://www.omg.org/spec/BPMN/2.0/PDF) or Business Process Execution Language (BPEL) (OASIS, 2007). For the execution of these workflow models, different workflow engines are available, e.g., the Camunda BPMN engine [[Camunda Services, 2023]](https://docs.camunda.io). Furthermore, there exists a quantum-specific modeling extension to ease the modeling of workflows in the quantum computing domain [[Weder et al., 2020b]](https://ieeexplore.ieee.org/abstract/document/9302814). Quantum-specific orchestration tools comprise Orquestra by Zapata [[Zapata, 2022]](https://www.zapatacomputing.com/orquestra), which uses a custom YAML-based language, and Covalent by Agnostiq [[Agnostiq, 2023]](https://agnostiq.ai/covalent/), a quantum orchestration platform that requires specifying control flow via a Python-based domain-specific language.&quot;, &quot;Related Pattern&quot;: &quot;If multiple quantum circuits have to be executed by the workflow, the PRIORITIZED EXECUTION pattern can be used to reduce waiting times. Further, this pattern can be applied to integrate several distinct quantum applications made available using the PRE-DEPLOYED EXECUTION pattern.&quot;}"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="paper_ref" value="https://www.scitepress.org/Link.aspx?doi=10.5220/0012057700003538"/>
            <column name="deployment_modeling_behavior_pattern"/>
            <column name="deployment_modeling_structure_pattern"/>
        </insert>
        <insert tableName="pattern">
            <column name="id" value="70adfd6f-0648-47cf-88ff-0212b882a262"/>
            <column name="name" value="Prioritized Execution"/>
            <column name="uri" value="https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/prioritizedExecution"/>
            <column name="content" value="{&quot;Alias&quot;: &quot;â€“&quot;, &quot;Forces&quot;: &quot;Quantum devices are usually accessed via queues, ensuring their fair utilization. Thus, the queuing times sum up when executing multiple quantum circuits independently of each other. One approach is to use batch processing, i.e., combining various quantum circuits into one job, which is then executed at once [[Vietz et al., 2021]](http://ceur-ws.org/Vol-3008/paper1.pdf). However, this approach is not possible when quantum circuits depend on the results of previous executions, e.g., for VQAs.&quot;, &quot;Intent&quot;: &quot;How to execute multiple quantum circuits in succession while keeping the queuing time low?&quot;, &quot;Result&quot;: &quot;By applying this pattern, the time spent waiting inside highly occupied job queues is minimized. The choice between the two options is a trade-off between runtime and cost. In the reserved time-slice scenario, runtime is the highest priority since the reservation of a quantum device incurs higher costs than other forms of access. When using sessions for the execution, there can still be competing executions in the job queue from other users.&quot;, &quot;Context&quot;: &quot;Quantum applications often require executing multiple quantum circuits. This is especially the case when utilizing VQAs on contemporary NISQ devices. Thus, these quantum circuits should be executed efficiently by minimizing the queuing times.&quot;, &quot;Examples&quot;: &quot;Enter your input for this section here.&quot;, &quot;Solution&quot;: &quot;Use quantum offerings that enable prioritized access to quantum devices to reduce or completely avoid queuing times, as shown in the solutions sketch in Figure 5. For this, prioritized access to quantum devices is obtained in Step 1. In Step 2, the quantum device can then be reused via this prioritized access, which restricts the number of users to reduce queuing times for multiple circuit executions.\n\n![Solution Sketch for Prioritized Execution](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/session-based-single-column.svg)&quot;, &quot;Known Uses&quot;: &quot;The Session Reuse variant is currently supported by IBM [[Qiskit, 2023a]](https://qiskit.org/documentation/) and AWS [[AWS, 2023]](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html). Further, the Dedicated Access variant is offered by vendors such as AWS [[AWS, 2023]](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html), Azure [[Microsoft, 2023]](https://azure.microsoft.com/en-us/services/quantum/), or IBM [[IBM, 2023b]](https://quantum-computing.ibm.com/lab/docs/iql/). A concrete example of a prioritized execution using Qiskit  [[Qiskit, 2023b]](https://qiskit.org/documentation/partners/qiskit_ibm_runtime/how_to/run_session.html) highlights which options for the session are available and shows the details like the session time limit.&quot;, &quot;Related Pattern&quot;: &quot;When using the VQA, VQE, or QAOA patterns [[Weigold et al., 2021b]](https://doi.org/10.1007/978-3-030-87568-8_2), prioritization is highly advised because of the amount of sequential quantum circuit executions. In these cases, it can be combined with the PRE-DEPLOYED EXECUTION pattern to address custom deployment requirements.&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/priortized-execution-thin.svg"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;â€“&quot;, &quot;Forces&quot;: &quot;Quantum devices are usually accessed via queues, ensuring their fair utilization. Thus, the queuing times sum up when executing multiple quantum circuits independently of each other. One approach is to use batch processing, i.e., combining various quantum circuits into one job, which is then executed at once [[Vietz et al., 2021]](http://ceur-ws.org/Vol-3008/paper1.pdf). However, this approach is not possible when quantum circuits depend on the results of previous executions, e.g., for VQAs.&quot;, &quot;Intent&quot;: &quot;How to execute multiple quantum circuits in succession while keeping the queuing time low?&quot;, &quot;Result&quot;: &quot;By applying this pattern, the time spent waiting inside highly occupied job queues is minimized. The choice between the two options is a trade-off between runtime and cost. In the reserved time-slice scenario, runtime is the highest priority since the reservation of a quantum device incurs higher costs than other forms of access. When using sessions for the execution, there can still be competing executions in the job queue from other users.&quot;, &quot;Context&quot;: &quot;Quantum applications often require executing multiple quantum circuits. This is especially the case when utilizing VQAs on contemporary NISQ devices. Thus, these quantum circuits should be executed efficiently by minimizing the queuing times.&quot;, &quot;Examples&quot;: &quot;Enter your input for this section here.&quot;, &quot;Solution&quot;: &quot;Use quantum offerings that enable prioritized access to quantum devices to reduce or completely avoid queuing times, as shown in the solutions sketch in Figure 5. For this, prioritized access to quantum devices is obtained in Step 1. In Step 2, the quantum device can then be reused via this prioritized access, which restricts the number of users to reduce queuing times for multiple circuit executions.\n\n![Solution Sketch for Prioritized Execution](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/session-based-single-column.svg)&quot;, &quot;Known Uses&quot;: &quot;The Session Reuse variant is currently supported by IBM [[Qiskit, 2023a]](https://qiskit.org/documentation/) and AWS [[AWS, 2023]](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html). Further, the Dedicated Access variant is offered by vendors such as AWS [[AWS, 2023]](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html), Azure [[Microsoft, 2023]](https://azure.microsoft.com/en-us/services/quantum/), or IBM [[IBM, 2023b]](https://quantum-computing.ibm.com/lab/docs/iql/). A concrete example of a prioritized execution using Qiskit  [[Qiskit, 2023b]](https://qiskit.org/documentation/partners/qiskit_ibm_runtime/how_to/run_session.html) highlights which options for the session are available and shows the details like the session time limit.&quot;, &quot;Related Pattern&quot;: &quot;When using the VQA, VQE, or QAOA patterns [[Weigold et al., 2021b]](https://doi.org/10.1007/978-3-030-87568-8_2), prioritization is highly advised because of the amount of sequential quantum circuit executions. In these cases, it can be combined with the PRE-DEPLOYED EXECUTION pattern to address custom deployment requirements.&quot;}"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="paper_ref" value="https://www.scitepress.org/Link.aspx?doi=10.5220/0012057700003538"/>
            <column name="deployment_modeling_behavior_pattern"/>
            <column name="deployment_modeling_structure_pattern"/>
        </insert>
    </changeSet>
</databaseChangeLog>
