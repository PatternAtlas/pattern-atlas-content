<?xml version="1.1" encoding="UTF-8" standalone="no"?>
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog" xmlns:ext="http://www.liquibase.org/xml/ns/dbchangelog-ext" xmlns:pro="http://www.liquibase.org/xml/ns/pro" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd http://www.liquibase.org/xml/ns/pro http://www.liquibase.org/xml/ns/pro/liquibase-pro-latest.xsd http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">
    <changeSet author="fabian" id="1685022922006-17">
        <insert tableName="pattern">
            <column name="id" value="424c803a-aefb-4b54-8e45-d177fedac893"/>
            <column name="name" value="Quantum Module"/>
            <column name="uri" value="https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/quantumModule"/>
            <column name="content" value="{&quot;Alias&quot;: &quot;–&quot;, &quot;Forces&quot;: &quot;Quantum circuits to be processed by a quantum\ncomputer must already contain all appropriately encoded input values. A static implementation of a quantum circuit that does not allow the quantum circuit to be changed based on some input values cannot be reused to solve different problems. Thus, a reusable implementation of the quantum part of a quantum algorithm needs to be able to adapt the quantum circuit to different input values. The input values that need to be encoded in a quantum circuit are, first, the problem to be solved, e.g., an implementation of Shor’s algorithm [[Shor 1997]](https://doi.org/10.1137/s0097539795293172) would require as input the number to be factored into primes, and second, parameters used for optimization or machine learning, e.g., for QAOA [[Weigold et al. 2021]](https://doi.org/10.1007/978-3-030-87568-8_2).\n\n\nMoreover, implementing the quantum part of a quantum algorithm requires in depth knowledge of quantum computing and the underlying mathematical concepts. Thus, quantum computing experts are required in the development teams. However, other parts of the algorithm that only require classical computation, e.g., classical optimizers, may not require quantum computing knowledge at all and can be implemented by different teams without a quantum computing expert.&quot;, &quot;Intent&quot;: &quot;How can the implementation of the quantum part of a quantum algorithm be packaged for reuse independent of concrete input values?&quot;, &quot;Result&quot;: &quot;A quantum algorithm implementation is partitioned into (i) quantum modules containing the implementations of the quantum part, and (ii) additional classical code required for the control flow and other classical computations of the quantum algorithm. The quantum modules are independent of the concrete input values, which increases their reusability for different quantum algorithm implementations.\n\n\nThe separation of code that generates quantum circuits into quantum modules can thus also be reflected in the organizational structure of the development teams. Only the teams working on the quantum modules need quantum computing experts, while other teams mainly need experts in classical software engineering.\n\n&quot;, &quot;Context&quot;: &quot;Each quantum algorithm is a hybrid algorithm, i.e., parts of the algorithm require quantum computers and other parts require classical computers for their execution. For the execution of the quantum part, a quantum circuit implementing the required operations is needed. However, quantum circuits are problem-specific and, thus, depend on various inputs, e.g., the problem instance or initial values for parameterized quantum gates, which are then optimized by a classical optimizer. Therefore, the implementation of the quantum part of a quantum algorithm must be input-agnostic in order to be reusable. &quot;, &quot;Examples&quot;: &quot;–&quot;, &quot;Solution&quot;: &quot;Separate the implementation of the quantum part\nof the quantum algorithm into one or more quantum modules. These modules contain the code that generates quantum circuits based on input values provided to the module. Quantum modules can also be used to reduce the number of code duplicates by implementing common parts of a quantum circuit as a reusable Quantum Module.\n\n![Solution sketch quantum module](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/7870b15afcae629bfbc0d0022fcb758832b3b8eb/sketches/quantum_computing_patterns/quantum-module.svg)\n\nThe solution sketch depicts that a quantum module receives input values and uses generative code to construct quantum circuits depending on these input values. This ensures the reusability of the quantum module, as the implementation can create quantum circuits for different problem sizes as well as parameters.\n\n&quot;, &quot;Known Uses&quot;: &quot;Quantum Modules can already be found in several libraries for building quantum circuits. In [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html), the Grover algorithm [[Grover 1996]](https://doi.org/10.1145/237814.237866) is offered as a module with functions to build the oracle and execute the Grover search. Another example of a Quantum Module for creating oracles is the PhaseOracle in [Qiskit](https://qiskit.org/documentation). Generic parts used in multiple quantum algorithms, such as the quantum fourier transformation used in Shor’s algorithm [[Shor 1997]](https://doi.org/10.1137/s0097539795293172) are available in [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html) and [Qiskit](https://qiskit.org/documentation). The quantum phase estimation, which is also part of Shor’s algorithm can be constructed in [Qiskit](https://qiskit.org/documentation) with the PhaseEstimation module.&quot;, &quot;Related Pattern&quot;: &quot;A Quantum Module generating specific quantum circuits for a quantum algorithm can be used inside a [Hybrid Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/4074490a-4236-49ed-83d1-625ce58e2dbd) that contains the implementation of the overall quantum algorithm with its quantum and classical parts. Quantum circuits generated by a Quantum Module can be integrated into a [Quantum Module Template](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d5cda8c9-f39b-474a-9032-c17131884975) to create a complete quantum circuit, if the Quantum Module only generates a part of a quantum circuit. The boundary of a Quantum Module is directly corresponding to the [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531). The Quantum-Classic Split pattern states, that there is necessarily a separation – a split – between code executed on classical computers and code executed on quantum computers. Thus, the Quantum Module pattern is related to this pattern.&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/7870b15afcae629bfbc0d0022fcb758832b3b8eb/icons/quantum_computing_patterns/quantum-module.svg"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;–&quot;, &quot;Forces&quot;: &quot;Quantum circuits to be processed by a quantum\ncomputer must already contain all appropriately encoded input values. A static implementation of a quantum circuit that does not allow the quantum circuit to be changed based on some input values cannot be reused to solve different problems. Thus, a reusable implementation of the quantum part of a quantum algorithm needs to be able to adapt the quantum circuit to different input values. The input values that need to be encoded in a quantum circuit are, first, the problem to be solved, e.g., an implementation of Shor’s algorithm [[Shor 1997]](https://doi.org/10.1137/s0097539795293172) would require as input the number to be factored into primes, and second, parameters used for optimization or machine learning, e.g., for QAOA [[Weigold et al. 2021]](https://doi.org/10.1007/978-3-030-87568-8_2).\n\n\nMoreover, implementing the quantum part of a quantum algorithm requires in depth knowledge of quantum computing and the underlying mathematical concepts. Thus, quantum computing experts are required in the development teams. However, other parts of the algorithm that only require classical computation, e.g., classical optimizers, may not require quantum computing knowledge at all and can be implemented by different teams without a quantum computing expert.&quot;, &quot;Intent&quot;: &quot;How can the implementation of the quantum part of a quantum algorithm be packaged for reuse independent of concrete input values?&quot;, &quot;Result&quot;: &quot;A quantum algorithm implementation is partitioned into (i) quantum modules containing the implementations of the quantum part, and (ii) additional classical code required for the control flow and other classical computations of the quantum algorithm. The quantum modules are independent of the concrete input values, which increases their reusability for different quantum algorithm implementations.\n\n\nThe separation of code that generates quantum circuits into quantum modules can thus also be reflected in the organizational structure of the development teams. Only the teams working on the quantum modules need quantum computing experts, while other teams mainly need experts in classical software engineering.\n\n&quot;, &quot;Context&quot;: &quot;Each quantum algorithm is a hybrid algorithm, i.e., parts of the algorithm require quantum computers and other parts require classical computers for their execution. For the execution of the quantum part, a quantum circuit implementing the required operations is needed. However, quantum circuits are problem-specific and, thus, depend on various inputs, e.g., the problem instance or initial values for parameterized quantum gates, which are then optimized by a classical optimizer. Therefore, the implementation of the quantum part of a quantum algorithm must be input-agnostic in order to be reusable. &quot;, &quot;Examples&quot;: &quot;–&quot;, &quot;Solution&quot;: &quot;Separate the implementation of the quantum part\nof the quantum algorithm into one or more quantum modules. These modules contain the code that generates quantum circuits based on input values provided to the module. Quantum modules can also be used to reduce the number of code duplicates by implementing common parts of a quantum circuit as a reusable Quantum Module.\n\n![Solution sketch quantum module](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/7870b15afcae629bfbc0d0022fcb758832b3b8eb/sketches/quantum_computing_patterns/quantum-module.svg)\n\nThe solution sketch depicts that a quantum module receives input values and uses generative code to construct quantum circuits depending on these input values. This ensures the reusability of the quantum module, as the implementation can create quantum circuits for different problem sizes as well as parameters.\n\n&quot;, &quot;Known Uses&quot;: &quot;Quantum Modules can already be found in several libraries for building quantum circuits. In [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html), the Grover algorithm [[Grover 1996]](https://doi.org/10.1145/237814.237866) is offered as a module with functions to build the oracle and execute the Grover search. Another example of a Quantum Module for creating oracles is the PhaseOracle in [Qiskit](https://qiskit.org/documentation). Generic parts used in multiple quantum algorithms, such as the quantum fourier transformation used in Shor’s algorithm [[Shor 1997]](https://doi.org/10.1137/s0097539795293172) are available in [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html) and [Qiskit](https://qiskit.org/documentation). The quantum phase estimation, which is also part of Shor’s algorithm can be constructed in [Qiskit](https://qiskit.org/documentation) with the PhaseEstimation module.&quot;, &quot;Related Pattern&quot;: &quot;A Quantum Module generating specific quantum circuits for a quantum algorithm can be used inside a [Hybrid Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/4074490a-4236-49ed-83d1-625ce58e2dbd) that contains the implementation of the overall quantum algorithm with its quantum and classical parts. Quantum circuits generated by a Quantum Module can be integrated into a [Quantum Module Template](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d5cda8c9-f39b-474a-9032-c17131884975) to create a complete quantum circuit, if the Quantum Module only generates a part of a quantum circuit. The boundary of a Quantum Module is directly corresponding to the [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531). The Quantum-Classic Split pattern states, that there is necessarily a separation – a split – between code executed on classical computers and code executed on quantum computers. Thus, the Quantum Module pattern is related to this pattern.&quot;}"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="paper_ref" value="IARIA, 2023"/>
            <column name="deployment_modeling_behavior_pattern"/>
            <column name="deployment_modeling_structure_pattern"/>
        </insert>
        <insert tableName="pattern">
            <column name="id" value="d5cda8c9-f39b-474a-9032-c17131884975"/>
            <column name="name" value="Quantum Module Template"/>
            <column name="uri" value="https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/quantumModuleTemplate"/>
            <column name="content" value="{&quot;Alias&quot;: &quot;–&quot;, &quot;Forces&quot;: &quot;Quantum algorithms may intentionally leave parts of the behavior of the quantum part unspecified until a later point in time. For example, the Grover search [[Grover 1996]](https://doi.org/10.1145/237814.237866) uses an unspecified placeholder gate, as the specific function that marks the correct values cannot be known before it has been decided what to search for. In the case of QAOA, the choice of a suitable ansatz depends on information that is only available at runtime. However, for the algorithms to be executed, the missing behavior must be integrated before the execution of the quantum circuits on a quantum computer. Note, that similar situations can arise if the development of a quantum algorithm is split between different teams.\n\n\nIntegrating quantum behavior into an existing circuit requires a specification of the requirements an implementation has to fulfill to be integrated and function correctly. This includes the specification of the input qubits available, possible ancilla qubits, on which qubits and in what form the output is expected, and any other requirements or restrictions, e.g., on the creation of entanglement between quantum bits. Some of the restrictions, e.g., the number of available ancilla qubits, may additionally depend on the quantum computer used for execution, as a quantum computer with more qubits can allocate more ancilla qubits if the number of qubits used in the circuit is otherwise constant.&quot;, &quot;Intent&quot;: &quot;How can the implementation of the quantum part of a quantum algorithm be packaged for reuse when some of the behavior is determined later?&quot;, &quot;Result&quot;: &quot;The generic behavior of the quantum part of a quantum algorithm is implemented as Quantum Module Template that requires behavior inputs to generate an executable complete quantum circuit. The behavior inputs specify the parts of the algorithm’s behavior that cannot be known in advance. Thereby, their influence on the resulting quantum circuit can be significantly higher than with a [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893). The behavior inputs must be compatible with the required input definitions of the template.\n\n\nThe integration of the behavior inputs can be done at design time if the behavior is provided as [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893), since the Quantum Module generates the circuit based on the input values. Templates can be nested inside other templates to compose quantum circuits from Quantum Modules implementing higher level circuit functions. This facilitates the replacement of a part of a quantum circuit if that part should be generated by a new Quantum Module implementing an improved algorithm, e.g., a more efficient state preparation.&quot;, &quot;Context&quot;: &quot;Some quantum algorithms can be implemented in a reusable manner, but their behavior may be partially modified depending on the problem to which the algorithm is applied. For example, the Grover search algorithm [[Grover 1996]](https://doi.org/10.1145/237814.237866) contains an unspecified oracle. The information required for defining the concrete behavior of this oracle may not be available until a later point in time. Similar cases are algorithms like QAOA [[Weigold et al. 2021]](https://doi.org/10.1007/978-3-030-87568-8_2), which do not specify a concrete ansatz to use. Thus, implementations of the quantum part of such algorithms, where the unspecified behavior can be integrated later, are required.&quot;, &quot;Examples&quot;: &quot;–&quot;, &quot;Solution&quot;: &quot;Implement the generic behavior of the quantum part of a quantum algorithm in a Quantum Module Template. This module accepts inputs, that define the unspecified behavior to be integrated into the final quantum circuit. The behavior can either be specified as a quantum circuit or as a [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893) that generates the required quantum circuit. This circuit then gets integrated by the Quantum Module Template into the main quantum circuit that represents the generic behavior.\n\n\nTo ensure that the behavior input, in form of a quantum circuit, can be integrated to correctly perform the operations it contains, the Quantum Module Template must include specifications in the documentation that can be used to build a compatible quantum circuit, as outlined in the pattern forces. This specification is mainly a contract that needs to be fulfilled by the quantum circuit serving as input for the template. Similar contracts, e.g., plugin contracts [Marquardt 1999](http://www.kmarquardt.de/papers/EuroPLoP1999.PlugInPatterns.pdf), are also used in classical software engineering.\n\n![Solution sketch quantum module template](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/7870b15afcae629bfbc0d0022fcb758832b3b8eb/sketches/quantum_computing_patterns/quantum-module-template.svg)\n\nThe sketch shows the essential building blocks of a Quantum Module Template. The template requires two kinds of inputs: (i) the input values representing the problem to be solved as well as parameters affecting the circuit generation, as used in the[Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893), and (ii) behavior inputs partially specifying the behavior of the algorithm, provided in the form of a quantum circuit or a [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893). Much like the Quantum Module, the Quantum Module Template uses the input values to generate a quantum circuit, which is still incomplete as it does not include the behavior from the behavior inputs yet. If the behavior inputs are provided in the form of a quantum module, this module is used to generate a quantum circuit from the inputs. Finally, the quantum circuit is integrated into the incomplete main circuit. However, implementations of the template are not limited to the exemplary steps shown here.&quot;, &quot;Known Uses&quot;: &quot;Various quantum algorithms, e.g., the algorithm of Deutsch [[Collins et al. 1998]](https://doi.org/10.1103/PhysRevA.58.R1633) or the Grover search [[Grover 1996]](https://doi.org/10.1145/237814.237866), use an unspecified unitary gate as placeholder. Implementations of the generic behavior of these algorithms are available in [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html) and [Qiskit](https://qiskit.org/documentation). These algorithms need oracle circuits to replace the placeholder gate, which are described in the [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e) pattern. The oracle replacement is described in [[Weder et al. 2020]](https://doi.org/10.1109/UCC48980.2020.00046) in an Oracle Expansion Task for workflows using the Quantum Modeling Extension. Generic parts of QAOA [[Weigold et al. 2021]](https://doi.org/10.1007/978-3-030-87568-8_2), such as state preparation and the mixer operator are implemented in [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html) and [Qiskit](https://qiskit.org/documentation) and can be used by providing a quantum circuit encoding the cost function.&quot;, &quot;Related Pattern&quot;: &quot;A Quantum Module Template is a special kind of [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893) that additionally accepts behavior inputs, which are integrated into the generated quantum circuit. Quantum Module Templates can be used to integrate, e.g., [Oracles](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e) and [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) circuits into an executable quantum circuit allowing circuits to be built from smaller modules.&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/7870b15afcae629bfbc0d0022fcb758832b3b8eb/icons/quantum_computing_patterns/quantum-module-template.svg"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;–&quot;, &quot;Forces&quot;: &quot;Quantum algorithms may intentionally leave parts of the behavior of the quantum part unspecified until a later point in time. For example, the Grover search [[Grover 1996]](https://doi.org/10.1145/237814.237866) uses an unspecified placeholder gate, as the specific function that marks the correct values cannot be known before it has been decided what to search for. In the case of QAOA, the choice of a suitable ansatz depends on information that is only available at runtime. However, for the algorithms to be executed, the missing behavior must be integrated before the execution of the quantum circuits on a quantum computer. Note, that similar situations can arise if the development of a quantum algorithm is split between different teams.\n\n\nIntegrating quantum behavior into an existing circuit requires a specification of the requirements an implementation has to fulfill to be integrated and function correctly. This includes the specification of the input qubits available, possible ancilla qubits, on which qubits and in what form the output is expected, and any other requirements or restrictions, e.g., on the creation of entanglement between quantum bits. Some of the restrictions, e.g., the number of available ancilla qubits, may additionally depend on the quantum computer used for execution, as a quantum computer with more qubits can allocate more ancilla qubits if the number of qubits used in the circuit is otherwise constant.&quot;, &quot;Intent&quot;: &quot;How can the implementation of the quantum part of a quantum algorithm be packaged for reuse when some of the behavior is determined later?&quot;, &quot;Result&quot;: &quot;The generic behavior of the quantum part of a quantum algorithm is implemented as Quantum Module Template that requires behavior inputs to generate an executable complete quantum circuit. The behavior inputs specify the parts of the algorithm’s behavior that cannot be known in advance. Thereby, their influence on the resulting quantum circuit can be significantly higher than with a [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893). The behavior inputs must be compatible with the required input definitions of the template.\n\n\nThe integration of the behavior inputs can be done at design time if the behavior is provided as [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893), since the Quantum Module generates the circuit based on the input values. Templates can be nested inside other templates to compose quantum circuits from Quantum Modules implementing higher level circuit functions. This facilitates the replacement of a part of a quantum circuit if that part should be generated by a new Quantum Module implementing an improved algorithm, e.g., a more efficient state preparation.&quot;, &quot;Context&quot;: &quot;Some quantum algorithms can be implemented in a reusable manner, but their behavior may be partially modified depending on the problem to which the algorithm is applied. For example, the Grover search algorithm [[Grover 1996]](https://doi.org/10.1145/237814.237866) contains an unspecified oracle. The information required for defining the concrete behavior of this oracle may not be available until a later point in time. Similar cases are algorithms like QAOA [[Weigold et al. 2021]](https://doi.org/10.1007/978-3-030-87568-8_2), which do not specify a concrete ansatz to use. Thus, implementations of the quantum part of such algorithms, where the unspecified behavior can be integrated later, are required.&quot;, &quot;Examples&quot;: &quot;–&quot;, &quot;Solution&quot;: &quot;Implement the generic behavior of the quantum part of a quantum algorithm in a Quantum Module Template. This module accepts inputs, that define the unspecified behavior to be integrated into the final quantum circuit. The behavior can either be specified as a quantum circuit or as a [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893) that generates the required quantum circuit. This circuit then gets integrated by the Quantum Module Template into the main quantum circuit that represents the generic behavior.\n\n\nTo ensure that the behavior input, in form of a quantum circuit, can be integrated to correctly perform the operations it contains, the Quantum Module Template must include specifications in the documentation that can be used to build a compatible quantum circuit, as outlined in the pattern forces. This specification is mainly a contract that needs to be fulfilled by the quantum circuit serving as input for the template. Similar contracts, e.g., plugin contracts [Marquardt 1999](http://www.kmarquardt.de/papers/EuroPLoP1999.PlugInPatterns.pdf), are also used in classical software engineering.\n\n![Solution sketch quantum module template](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/7870b15afcae629bfbc0d0022fcb758832b3b8eb/sketches/quantum_computing_patterns/quantum-module-template.svg)\n\nThe sketch shows the essential building blocks of a Quantum Module Template. The template requires two kinds of inputs: (i) the input values representing the problem to be solved as well as parameters affecting the circuit generation, as used in the[Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893), and (ii) behavior inputs partially specifying the behavior of the algorithm, provided in the form of a quantum circuit or a [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893). Much like the Quantum Module, the Quantum Module Template uses the input values to generate a quantum circuit, which is still incomplete as it does not include the behavior from the behavior inputs yet. If the behavior inputs are provided in the form of a quantum module, this module is used to generate a quantum circuit from the inputs. Finally, the quantum circuit is integrated into the incomplete main circuit. However, implementations of the template are not limited to the exemplary steps shown here.&quot;, &quot;Known Uses&quot;: &quot;Various quantum algorithms, e.g., the algorithm of Deutsch [[Collins et al. 1998]](https://doi.org/10.1103/PhysRevA.58.R1633) or the Grover search [[Grover 1996]](https://doi.org/10.1145/237814.237866), use an unspecified unitary gate as placeholder. Implementations of the generic behavior of these algorithms are available in [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html) and [Qiskit](https://qiskit.org/documentation). These algorithms need oracle circuits to replace the placeholder gate, which are described in the [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e) pattern. The oracle replacement is described in [[Weder et al. 2020]](https://doi.org/10.1109/UCC48980.2020.00046) in an Oracle Expansion Task for workflows using the Quantum Modeling Extension. Generic parts of QAOA [[Weigold et al. 2021]](https://doi.org/10.1007/978-3-030-87568-8_2), such as state preparation and the mixer operator are implemented in [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html) and [Qiskit](https://qiskit.org/documentation) and can be used by providing a quantum circuit encoding the cost function.&quot;, &quot;Related Pattern&quot;: &quot;A Quantum Module Template is a special kind of [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893) that additionally accepts behavior inputs, which are integrated into the generated quantum circuit. Quantum Module Templates can be used to integrate, e.g., [Oracles](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e) and [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) circuits into an executable quantum circuit allowing circuits to be built from smaller modules.&quot;}"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="paper_ref" value="IARIA, 2023"/>
            <column name="deployment_modeling_behavior_pattern"/>
            <column name="deployment_modeling_structure_pattern"/>
        </insert>
        <insert tableName="pattern">
            <column name="id" value="4074490a-4236-49ed-83d1-625ce58e2dbd"/>
            <column name="name" value="Hybrid Module"/>
            <column name="uri" value="https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/hybridModule"/>
            <column name="content" value="{&quot;Alias&quot;: &quot;–&quot;, &quot;Forces&quot;: &quot;Quantum algorithms typically require a classical computer for some parts of their computation. This means that they can have multiple quantum and classical parts. For example, VQAs, such as VQE and QAOA, alternate between quantum and classical computations [[Cerezo et al. 2021]](https://doi.org/10.1038/s42254-021-00348-9)[[Weigold et al. 2021]](https://doi.org/10.1007/978-3-030-87568-8_2). Both, the quantum and the classical part, are required for the algorithm to work correctly. This also includes the control flow of the algorithm, which is included in the classical part of the algorithm.\n\n\nIntegrating a quantum algorithm into an application requires the implementation of the entire algorithm. A dedicated interface is required to enable the integration into applications. Deploying the algorithm to a hybrid runtime, which can execute both the quantum and the classical part of the algorithm, even requires both parts to be deployed together.&quot;, &quot;Intent&quot;: &quot;How can the implementation of a quantum algorithm requiring both classical and quantum computations be packaged so that it can be integrated into applications? &quot;, &quot;Result&quot;: &quot;The entire quantum algorithm implementation is packaged as a Hybrid Module. It contains both the quantum and the classical parts, as well as the control flow logic. Hybrid Modules can be used to deploy the algorithm as a standalone service, e.g., in a hybrid runtime environment that can execute both the classical and the quantum part [[Riel 2022]](https://doi.org/10.1109/ESSDERC55479.2022.9947181). Furthermore, a Hybrid Module can be distributed as a library that implements the quantum algorithm and can be integrated into classical applications. It provides an interface for the application to use. To facilitate the integration of a Hybrid Module by problem-domain experts, a [Classical-Quantum Interface](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/8fcca2dc-fca0-47cf-9bd4-038cd2fe8fb8) can be used as the modules’ interface.&quot;, &quot;Context&quot;: &quot;Quantum algorithms often require classical computation for pre- and post-processing of the quantum computation results [[Leymann and Barzen 2020]](https://doi.org/10.1088/2058-9565/abae7d). This means that almost all quantum algorithms are hybrid. Thus, any implementation of a quantum algorithm has to contain both the quantum and the classical parts for the algorithm to be functional.&quot;, &quot;Examples&quot;: &quot;–&quot;, &quot;Solution&quot;: &quot;Package the entire quantum algorithm, i.e., both the quantum parts and the classical parts, as a Hybrid Module. This module can be composed of smaller modules, e.g., [Quantum Modules](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893). It also contains the control flow logic to orchestrate the quantum and classical computation. The Hybrid Module should provide an interface that facilitates its integration into applications. This interface should mainly accept the required problem-specific input values, i.e., the problem that should be processed by the algorithm. Moreover, the interface of a Hybrid Module can also allow behavior inputs to the classical as well as quantum computation, similar to the [Quantum Module Templates](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d5cda8c9-f39b-474a-9032-c17131884975).\n\n![Solution sketch hybrid module](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/7870b15afcae629bfbc0d0022fcb758832b3b8eb/sketches/quantum_computing_patterns/hybrid-module.svg)\n\nAn exemplary sketch of a Hybrid Module is shown in the sketch. It includes the control flow logic and implementations of classical and quantum parts with a loop between quantum and classical computation. The implementation of such a hybrid module can consist of multiple smaller modules, e.g., the three classical and one quantum computation steps shown can each be implemented in a separate module.&quot;, &quot;Known Uses&quot;: &quot;One concrete example are implementations of Shor’s algorithm [[Shor 1997]](https://doi.org/10.1137/s0097539795293172) which computes the prime factors of the input number. The period-finding calculated on the quantum computer and the classical post-processing performing the continued fraction expansion is packaged as a Hybrid Module in [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html), [Qiskit](https://qiskit.org/documentation) and [Q#](https://learn.microsoft.com/en-us/azure/quantum/\noverview-what-is-qsharp-and-qdk).\n\n\nOther examples of Hybrid Modules are implementations of VQAs [[Cerezo et al. 2021]](https://doi.org/10.1038/s42254-021-00348-9), e.g., QAOA and VQE implementations for the [Qiskit](https://qiskit.org/documentation) Runtime contain the full quantum algorithm implementation. [[Beisel et al. 2023]](https://doi.org/10.1007/978-3-031-26507-5_35) showcase a service ecosystem enabling a workflow-based composition of Hybrid Modules for VQAs.&quot;, &quot;Related Pattern&quot;: &quot;The quantum part of the algorithm implementation inside a Hybrid Module can be organized into [Quantum Modules](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893) and [Quantum Module Templates](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d5cda8c9-f39b-474a-9032-c17131884975). To facilitate their integration into applications by problem-domain experts without quantum computing knowledge, the Hybrid Module can expose a problem domain-specific [Classical-Quantum Interface](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/8fcca2dc-fca0-47cf-9bd4-038cd2fe8fb8).&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/7870b15afcae629bfbc0d0022fcb758832b3b8eb/icons/quantum_computing_patterns/hybrid-module.svg"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;–&quot;, &quot;Forces&quot;: &quot;Quantum algorithms typically require a classical computer for some parts of their computation. This means that they can have multiple quantum and classical parts. For example, VQAs, such as VQE and QAOA, alternate between quantum and classical computations [[Cerezo et al. 2021]](https://doi.org/10.1038/s42254-021-00348-9)[[Weigold et al. 2021]](https://doi.org/10.1007/978-3-030-87568-8_2). Both, the quantum and the classical part, are required for the algorithm to work correctly. This also includes the control flow of the algorithm, which is included in the classical part of the algorithm.\n\n\nIntegrating a quantum algorithm into an application requires the implementation of the entire algorithm. A dedicated interface is required to enable the integration into applications. Deploying the algorithm to a hybrid runtime, which can execute both the quantum and the classical part of the algorithm, even requires both parts to be deployed together.&quot;, &quot;Intent&quot;: &quot;How can the implementation of a quantum algorithm requiring both classical and quantum computations be packaged so that it can be integrated into applications? &quot;, &quot;Result&quot;: &quot;The entire quantum algorithm implementation is packaged as a Hybrid Module. It contains both the quantum and the classical parts, as well as the control flow logic. Hybrid Modules can be used to deploy the algorithm as a standalone service, e.g., in a hybrid runtime environment that can execute both the classical and the quantum part [[Riel 2022]](https://doi.org/10.1109/ESSDERC55479.2022.9947181). Furthermore, a Hybrid Module can be distributed as a library that implements the quantum algorithm and can be integrated into classical applications. It provides an interface for the application to use. To facilitate the integration of a Hybrid Module by problem-domain experts, a [Classical-Quantum Interface](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/8fcca2dc-fca0-47cf-9bd4-038cd2fe8fb8) can be used as the modules’ interface.&quot;, &quot;Context&quot;: &quot;Quantum algorithms often require classical computation for pre- and post-processing of the quantum computation results [[Leymann and Barzen 2020]](https://doi.org/10.1088/2058-9565/abae7d). This means that almost all quantum algorithms are hybrid. Thus, any implementation of a quantum algorithm has to contain both the quantum and the classical parts for the algorithm to be functional.&quot;, &quot;Examples&quot;: &quot;–&quot;, &quot;Solution&quot;: &quot;Package the entire quantum algorithm, i.e., both the quantum parts and the classical parts, as a Hybrid Module. This module can be composed of smaller modules, e.g., [Quantum Modules](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893). It also contains the control flow logic to orchestrate the quantum and classical computation. The Hybrid Module should provide an interface that facilitates its integration into applications. This interface should mainly accept the required problem-specific input values, i.e., the problem that should be processed by the algorithm. Moreover, the interface of a Hybrid Module can also allow behavior inputs to the classical as well as quantum computation, similar to the [Quantum Module Templates](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d5cda8c9-f39b-474a-9032-c17131884975).\n\n![Solution sketch hybrid module](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/7870b15afcae629bfbc0d0022fcb758832b3b8eb/sketches/quantum_computing_patterns/hybrid-module.svg)\n\nAn exemplary sketch of a Hybrid Module is shown in the sketch. It includes the control flow logic and implementations of classical and quantum parts with a loop between quantum and classical computation. The implementation of such a hybrid module can consist of multiple smaller modules, e.g., the three classical and one quantum computation steps shown can each be implemented in a separate module.&quot;, &quot;Known Uses&quot;: &quot;One concrete example are implementations of Shor’s algorithm [[Shor 1997]](https://doi.org/10.1137/s0097539795293172) which computes the prime factors of the input number. The period-finding calculated on the quantum computer and the classical post-processing performing the continued fraction expansion is packaged as a Hybrid Module in [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html), [Qiskit](https://qiskit.org/documentation) and [Q#](https://learn.microsoft.com/en-us/azure/quantum/\noverview-what-is-qsharp-and-qdk).\n\n\nOther examples of Hybrid Modules are implementations of VQAs [[Cerezo et al. 2021]](https://doi.org/10.1038/s42254-021-00348-9), e.g., QAOA and VQE implementations for the [Qiskit](https://qiskit.org/documentation) Runtime contain the full quantum algorithm implementation. [[Beisel et al. 2023]](https://doi.org/10.1007/978-3-031-26507-5_35) showcase a service ecosystem enabling a workflow-based composition of Hybrid Modules for VQAs.&quot;, &quot;Related Pattern&quot;: &quot;The quantum part of the algorithm implementation inside a Hybrid Module can be organized into [Quantum Modules](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893) and [Quantum Module Templates](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d5cda8c9-f39b-474a-9032-c17131884975). To facilitate their integration into applications by problem-domain experts without quantum computing knowledge, the Hybrid Module can expose a problem domain-specific [Classical-Quantum Interface](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/8fcca2dc-fca0-47cf-9bd4-038cd2fe8fb8).&quot;}"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="paper_ref" value="IARIA, 2023"/>
            <column name="deployment_modeling_behavior_pattern"/>
            <column name="deployment_modeling_structure_pattern"/>
        </insert>
        <insert tableName="pattern">
            <column name="id" value="8fcca2dc-fca0-47cf-9bd4-038cd2fe8fb8"/>
            <column name="name" value="Classical-Quantum Interface"/>
            <column name="uri" value="https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/classical-quantumInterface"/>
            <column name="content" value="{&quot;Alias&quot;: &quot;–&quot;, &quot;Forces&quot;: &quot;To integrate a quantum algorithm implementation into an application, a compatible interface is required. A [Hybrid Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/4074490a-4236-49ed-83d1-625ce58e2dbd) already provides an interface enabling its integration into applications, however, using this interface may still require considerable quantum computing knowledge. For example, it may require the problem instance to be provided in the form of a behavior input to the quantum part of an algorithm, or it may have parameters that otherwise influence the quantum part, e.g., by enabling certain error mitigation methods. The effects of the changes, e.g., on resource requirements or runtime, are difficult to estimate without knowledge of quantum computers. Thus, to facilitate the integration of quantum algorithms by problem-domain experts without quantum computing knowledge, such an interface is not sufficient.&quot;, &quot;Intent&quot;: &quot;How can a quantum algorithm implementation be used by developers without quantum computing knowledge?&quot;, &quot;Result&quot;: &quot;The quantum algorithm implementation can be utilized using a Classical-Quantum Interface. Problem domain experts can make use of this quantum algorithm implementation through the Classical-Quantum Interface created for their domain. The knowledge required to utilize the algorithm implementation is presented in the interface documentation, and the format of input parameters is familiar to problem-domain experts.&quot;, &quot;Context&quot;: &quot;Using a quantum algorithm implementation often requires in depth quantum computing knowledge. For example, the Grover search algorithm requires that the user provides a quantum circuit for the missing oracle [[Grover 1996]](https://doi.org/10.1145/237814.237866). Other algorithms, like QAOA, require choosing an ansatz, which also requires quantum computing knowledge [[Cerezo et al. 2021]](https://doi.org/10.1038/s42254-021-00348-9)[[Weigold et al. 2021]](https://doi.org/10.1007/978-3-030-87568-8_2). However, software developers who want to integrate a quantum algorithm implementation into an application have a deep understanding of the problem domain rather than deep knowledge of quantum computing.&quot;, &quot;Examples&quot;: &quot;–&quot;, &quot;Solution&quot;: &quot;Use a Classical-Quantum Interface that hides the quantum implementation details. Inputs can be provided to the interface in formats specific to the problem domain. These problem domain-specific inputs are internally converted into inputs in the formats required by the implementation of the quantum part.\n\n\nThe documentation of interface inputs that affect the quantum part requires special consideration, since understanding their impact on algorithm execution is important information when integrating the quantum algorithm implementation. Thus, the impact of these inputs on the algorithm should be documented in a comprehensible and easily understandable manner by the interface developer. For example, a parameter that increases the accuracy of the result, but also increases the number of gates in the generated circuits, which can result in increased errors with current quantum computers, could be documented as follows:\n\n\n&gt; “Increasing this parameter can increase the accuracy of the result. However, it also increases the probability of computation errors accumulating, which can negate any improvement in accuracy.“\n\n![Solution sketch classical-quantum interface](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/86db502508692e2de1af9a3dfbb2e5ff28e03201/sketches/quantum_computing_patterns/classical-quantum-interface.svg)\n\nThe sketch shows the interaction of a classical program with a quantum algorithm implemented as a [Hybrid Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/4074490a-4236-49ed-83d1-625ce58e2dbd) through a ClassicalL-Quantum Interface. It transforms the problem domain-specific input of the classical program into the inputs required by the quantum algorithm. This interface can also be integrated directly into the [Hybrid Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/4074490a-4236-49ed-83d1-625ce58e2dbd).&quot;, &quot;Known Uses&quot;: &quot;Domain-specific libraries for quantum computing are among the first having implemented this pattern. Examples for already implemented Classical-Quantum Interfaces can be found in the chemistry domain in [Qiskit Nature](https://qiskit.org/ecosystem/nature/index.html), [Amazon Braket](https://github.com/aws/amazon-braket-examples/blob/main/examples/hybrid_quantum_algorithms/VQE_Chemistry/VQE_chemistry_braket.ipynb), and [Q#](https://learn.microsoft.com/en-us/azure/quantum/user-guide/libraries/chemistry/). They offer transformation modules that map the electronic structure of molecules to qubits. Furthermore, [Qiskit](https://qiskit.org/documentation) provides a finance module enabling portfolio optimization by implementing a transformer that takes a generic optimization problem as input and outputs a cost operator that can be used in a quantum algorithm. As many classical problems can be formulated as such an optimization problem, this can be used as a Classical-Quantum Interface for different problem domains.&quot;, &quot;Related Pattern&quot;: &quot;The Classical-Quantum Interface enables the integration of quantum algorithm implementations into applications. It can be used as an interface for a quantum algorithm implemented as a [Hybrid Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/4074490a-4236-49ed-83d1-625ce58e2dbd). This interface provides a bridge between the different programming paradigms separated by the [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531). It is a special kind of Facade [Gamma et al. 1994] for quantum algorithms that not only hides the complexity of the algorithm, but also translates between the quantum computing domain and the problem domain.\n\n---\n\n[Gamma et al. 1994] E. Gamma, R. Helm, R. Johnson, and J. Vlissides, Design Patterns: Elements of Reusable Object-oriented Software. Addison-Wesley, 1994.&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/7870b15afcae629bfbc0d0022fcb758832b3b8eb/icons/quantum_computing_patterns/classical-quantum-interface.svg"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;–&quot;, &quot;Forces&quot;: &quot;To integrate a quantum algorithm implementation into an application, a compatible interface is required. A [Hybrid Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/4074490a-4236-49ed-83d1-625ce58e2dbd) already provides an interface enabling its integration into applications, however, using this interface may still require considerable quantum computing knowledge. For example, it may require the problem instance to be provided in the form of a behavior input to the quantum part of an algorithm, or it may have parameters that otherwise influence the quantum part, e.g., by enabling certain error mitigation methods. The effects of the changes, e.g., on resource requirements or runtime, are difficult to estimate without knowledge of quantum computers. Thus, to facilitate the integration of quantum algorithms by problem-domain experts without quantum computing knowledge, such an interface is not sufficient.&quot;, &quot;Intent&quot;: &quot;How can a quantum algorithm implementation be used by developers without quantum computing knowledge?&quot;, &quot;Result&quot;: &quot;The quantum algorithm implementation can be utilized using a Classical-Quantum Interface. Problem domain experts can make use of this quantum algorithm implementation through the Classical-Quantum Interface created for their domain. The knowledge required to utilize the algorithm implementation is presented in the interface documentation, and the format of input parameters is familiar to problem-domain experts.&quot;, &quot;Context&quot;: &quot;Using a quantum algorithm implementation often requires in depth quantum computing knowledge. For example, the Grover search algorithm requires that the user provides a quantum circuit for the missing oracle [[Grover 1996]](https://doi.org/10.1145/237814.237866). Other algorithms, like QAOA, require choosing an ansatz, which also requires quantum computing knowledge [[Cerezo et al. 2021]](https://doi.org/10.1038/s42254-021-00348-9)[[Weigold et al. 2021]](https://doi.org/10.1007/978-3-030-87568-8_2). However, software developers who want to integrate a quantum algorithm implementation into an application have a deep understanding of the problem domain rather than deep knowledge of quantum computing.&quot;, &quot;Examples&quot;: &quot;–&quot;, &quot;Solution&quot;: &quot;Use a Classical-Quantum Interface that hides the quantum implementation details. Inputs can be provided to the interface in formats specific to the problem domain. These problem domain-specific inputs are internally converted into inputs in the formats required by the implementation of the quantum part.\n\n\nThe documentation of interface inputs that affect the quantum part requires special consideration, since understanding their impact on algorithm execution is important information when integrating the quantum algorithm implementation. Thus, the impact of these inputs on the algorithm should be documented in a comprehensible and easily understandable manner by the interface developer. For example, a parameter that increases the accuracy of the result, but also increases the number of gates in the generated circuits, which can result in increased errors with current quantum computers, could be documented as follows:\n\n\n&gt; “Increasing this parameter can increase the accuracy of the result. However, it also increases the probability of computation errors accumulating, which can negate any improvement in accuracy.“\n\n![Solution sketch classical-quantum interface](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/86db502508692e2de1af9a3dfbb2e5ff28e03201/sketches/quantum_computing_patterns/classical-quantum-interface.svg)\n\nThe sketch shows the interaction of a classical program with a quantum algorithm implemented as a [Hybrid Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/4074490a-4236-49ed-83d1-625ce58e2dbd) through a ClassicalL-Quantum Interface. It transforms the problem domain-specific input of the classical program into the inputs required by the quantum algorithm. This interface can also be integrated directly into the [Hybrid Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/4074490a-4236-49ed-83d1-625ce58e2dbd).&quot;, &quot;Known Uses&quot;: &quot;Domain-specific libraries for quantum computing are among the first having implemented this pattern. Examples for already implemented Classical-Quantum Interfaces can be found in the chemistry domain in [Qiskit Nature](https://qiskit.org/ecosystem/nature/index.html), [Amazon Braket](https://github.com/aws/amazon-braket-examples/blob/main/examples/hybrid_quantum_algorithms/VQE_Chemistry/VQE_chemistry_braket.ipynb), and [Q#](https://learn.microsoft.com/en-us/azure/quantum/user-guide/libraries/chemistry/). They offer transformation modules that map the electronic structure of molecules to qubits. Furthermore, [Qiskit](https://qiskit.org/documentation) provides a finance module enabling portfolio optimization by implementing a transformer that takes a generic optimization problem as input and outputs a cost operator that can be used in a quantum algorithm. As many classical problems can be formulated as such an optimization problem, this can be used as a Classical-Quantum Interface for different problem domains.&quot;, &quot;Related Pattern&quot;: &quot;The Classical-Quantum Interface enables the integration of quantum algorithm implementations into applications. It can be used as an interface for a quantum algorithm implemented as a [Hybrid Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/4074490a-4236-49ed-83d1-625ce58e2dbd). This interface provides a bridge between the different programming paradigms separated by the [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531). It is a special kind of Facade [Gamma et al. 1994] for quantum algorithms that not only hides the complexity of the algorithm, but also translates between the quantum computing domain and the problem domain.\n\n---\n\n[Gamma et al. 1994] E. Gamma, R. Helm, R. Johnson, and J. Vlissides, Design Patterns: Elements of Reusable Object-oriented Software. Addison-Wesley, 1994.&quot;}"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="paper_ref" value="IARIA, 2023"/>
            <column name="deployment_modeling_behavior_pattern"/>
            <column name="deployment_modeling_structure_pattern"/>
        </insert>
        <insert tableName="pattern">
            <column name="id" value="aa90de15-b7e3-45a7-bb48-f0a5b8b2c479"/>
            <column name="name" value="Quantum Circuit Translator"/>
            <column name="uri" value="https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/quantumCircuitTranslator"/>
            <column name="content" value="{&quot;Alias&quot;: &quot;–&quot;, &quot;Forces&quot;: &quot;There are a multitude of quantum programming languages available for implementing quantum algorithms [[Vietz et al. 2021]](https://doi.org/10.1007/978-3-030-77980-1_10). A quantum circuit may be implemented in a programming language that is incompatible with the targeted quantum computer. The circuit needs to be re-implemented in a compatible quantum programming language and instruction set. However, a manual re-implementation is error-prone, time-consuming, and requires expertise in quantum computing, and, hence, is not feasible for real-world problem sizes. Therefore, an automatic translation, transforming unsupported gates into gates natively supported by the quantum computer, is required.&quot;, &quot;Intent&quot;: &quot;How can a quantum circuit be executed by different quantum computers with different instruction sets?&quot;, &quot;Result&quot;: &quot;A Quantum Circuit Translator is able to automatically translate a quantum circuit into a target format, enabling components with different circuit formats and instruction sets to use the same circuit. A Quantum Circuit Translator increases the reusability of [Quantum Modules](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893), as it enables their use with different quantum computers. However, the translated circuits do not need to be executed directly, but can instead be used as inputs for a [Quantum Module Template](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d5cda8c9-f39b-474a-9032-c17131884975). Therefore, a Quantum Circuit Translator enables the composition of quantum algorithms based on modules implemented in different programming languages. Thus, a Quantum Circuit Translator can be used to increase the interoperability of [Quantum Modules](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893).&quot;, &quot;Context&quot;: &quot;Quantum circuits can be implemented in different programming languages and with different quantum gates. However, quantum computers typically only support specific circuit formats and instruction sets, which hinders interoperability and leads to vendor lock-in [[Salm et al. 2020]](https://doi.org/10.1007/978-3-030-64846-6_5). Thus, executing a quantum circuit on different quantum computers often requires a translation of the quantum circuit.&quot;, &quot;Examples&quot;: &quot;–&quot;, &quot;Solution&quot;: &quot;Use a translator to convert the quantum circuit into the target language and transpile the circuit to the target instruction set, i.e., replace unsupported gates with equivalent gates from the target instruction set.\n\n![Solution sketch quantum circuit translator](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/86db502508692e2de1af9a3dfbb2e5ff28e03201/sketches/quantum_computing_patterns/quantum-circuit-translator.svg)\n\nThe solution sketch shows the application of a Quantum Circuit Translator that translates a quantum circuit between two programming languages and instruction sets. The SWAP gate connecting the outer qubit wires in the left quantum circuit has been decomposed into three C-NOT gates in the right target quantum circuit.&quot;, &quot;Known Uses&quot;: &quot;A widely used format for defining quantum circuits is OpenQASM [[Cross et al. 2022]](https://doi.org/10.1145/3505636), an open quantum assembly language. It can be imported and exported by many quantum software development kits (SDKs) such as [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html), [Qiskit](https://qiskit.org/documentation) and [Cirq](https://quantumai.google/cirq). For estimating whether a quantum circuit can be executed, the NISQ Analyzer [[Salm et al. 2020]](https://doi.org/10.1007/978-3-030-64846-6_5) needs the transpiled circuit for the respective quantum device. It includes multiple circuit translators. For the Python SDK Pennylane [[Bergholm et al. 2018]](https://arxiv.org/abs/1811.04968) there is a plugin enabling the support for IBM quantum computers without additional libraries. Explicit translation is supported by pytket [Pytket Extensions](https://github.com/CQCL/pytket-cirq) from and to [Cirq](https://quantumai.google/cirq). [Qconvert](https://github.com/quantastica/qconvert) can convert from pyQuil or OpenQASM to several other formats by using their web tool.&quot;, &quot;Related Pattern&quot;: &quot;The Quantum Circuit Translator pattern is related to the [Message Translator](pattern-languages/f6b807aa-5905-4435-aec6-324355a0483f/29f4224d-6b91-4218-aed6-0db3e5fa9dc2) pattern from the [enterprise integration pattern language](pattern-languages/f6b807aa-5905-4435-aec6-324355a0483f). With a [Canonical Data Model](pattern-languages/f6b807aa-5905-4435-aec6-324355a0483f/98ccd4dc-86a8-4652-b2c1-5b83b6f078e1) quantum circuits of any language can be translated into any other language using at most two translators for each language. A circuit translator can be used to translate circuits generated by a [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893) implemented in one programming language before using them with a [Quantum Module Template](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d5cda8c9-f39b-474a-9032-c17131884975) implemented in a different programming language.&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/7870b15afcae629bfbc0d0022fcb758832b3b8eb/icons/quantum_computing_patterns/quantum-circuit-translator.svg"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;–&quot;, &quot;Forces&quot;: &quot;There are a multitude of quantum programming languages available for implementing quantum algorithms [[Vietz et al. 2021]](https://doi.org/10.1007/978-3-030-77980-1_10). A quantum circuit may be implemented in a programming language that is incompatible with the targeted quantum computer. The circuit needs to be re-implemented in a compatible quantum programming language and instruction set. However, a manual re-implementation is error-prone, time-consuming, and requires expertise in quantum computing, and, hence, is not feasible for real-world problem sizes. Therefore, an automatic translation, transforming unsupported gates into gates natively supported by the quantum computer, is required.&quot;, &quot;Intent&quot;: &quot;How can a quantum circuit be executed by different quantum computers with different instruction sets?&quot;, &quot;Result&quot;: &quot;A Quantum Circuit Translator is able to automatically translate a quantum circuit into a target format, enabling components with different circuit formats and instruction sets to use the same circuit. A Quantum Circuit Translator increases the reusability of [Quantum Modules](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893), as it enables their use with different quantum computers. However, the translated circuits do not need to be executed directly, but can instead be used as inputs for a [Quantum Module Template](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d5cda8c9-f39b-474a-9032-c17131884975). Therefore, a Quantum Circuit Translator enables the composition of quantum algorithms based on modules implemented in different programming languages. Thus, a Quantum Circuit Translator can be used to increase the interoperability of [Quantum Modules](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893).&quot;, &quot;Context&quot;: &quot;Quantum circuits can be implemented in different programming languages and with different quantum gates. However, quantum computers typically only support specific circuit formats and instruction sets, which hinders interoperability and leads to vendor lock-in [[Salm et al. 2020]](https://doi.org/10.1007/978-3-030-64846-6_5). Thus, executing a quantum circuit on different quantum computers often requires a translation of the quantum circuit.&quot;, &quot;Examples&quot;: &quot;–&quot;, &quot;Solution&quot;: &quot;Use a translator to convert the quantum circuit into the target language and transpile the circuit to the target instruction set, i.e., replace unsupported gates with equivalent gates from the target instruction set.\n\n![Solution sketch quantum circuit translator](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/86db502508692e2de1af9a3dfbb2e5ff28e03201/sketches/quantum_computing_patterns/quantum-circuit-translator.svg)\n\nThe solution sketch shows the application of a Quantum Circuit Translator that translates a quantum circuit between two programming languages and instruction sets. The SWAP gate connecting the outer qubit wires in the left quantum circuit has been decomposed into three C-NOT gates in the right target quantum circuit.&quot;, &quot;Known Uses&quot;: &quot;A widely used format for defining quantum circuits is OpenQASM [[Cross et al. 2022]](https://doi.org/10.1145/3505636), an open quantum assembly language. It can be imported and exported by many quantum software development kits (SDKs) such as [Amazon Braket](https://docs.aws.amazon.com/braket/latest/developerguide/braket-using.html), [Qiskit](https://qiskit.org/documentation) and [Cirq](https://quantumai.google/cirq). For estimating whether a quantum circuit can be executed, the NISQ Analyzer [[Salm et al. 2020]](https://doi.org/10.1007/978-3-030-64846-6_5) needs the transpiled circuit for the respective quantum device. It includes multiple circuit translators. For the Python SDK Pennylane [[Bergholm et al. 2018]](https://arxiv.org/abs/1811.04968) there is a plugin enabling the support for IBM quantum computers without additional libraries. Explicit translation is supported by pytket [Pytket Extensions](https://github.com/CQCL/pytket-cirq) from and to [Cirq](https://quantumai.google/cirq). [Qconvert](https://github.com/quantastica/qconvert) can convert from pyQuil or OpenQASM to several other formats by using their web tool.&quot;, &quot;Related Pattern&quot;: &quot;The Quantum Circuit Translator pattern is related to the [Message Translator](pattern-languages/f6b807aa-5905-4435-aec6-324355a0483f/29f4224d-6b91-4218-aed6-0db3e5fa9dc2) pattern from the [enterprise integration pattern language](pattern-languages/f6b807aa-5905-4435-aec6-324355a0483f). With a [Canonical Data Model](pattern-languages/f6b807aa-5905-4435-aec6-324355a0483f/98ccd4dc-86a8-4652-b2c1-5b83b6f078e1) quantum circuits of any language can be translated into any other language using at most two translators for each language. A circuit translator can be used to translate circuits generated by a [Quantum Module](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/424c803a-aefb-4b54-8e45-d177fedac893) implemented in one programming language before using them with a [Quantum Module Template](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d5cda8c9-f39b-474a-9032-c17131884975) implemented in a different programming language.&quot;}"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="paper_ref" value="IARIA, 2023"/>
            <column name="deployment_modeling_behavior_pattern"/>
            <column name="deployment_modeling_structure_pattern"/>
        </insert>

        <insert tableName="directed_edge">
            <column name="id" value="b0384d36-b4d0-4ed7-ae17-833305f30e1e"/>
            <column name="description" value="&quot;The boundary of a quantum module directly corresponds to the Quantum-Classic Split&quot;"/>
            <column name="type" value="isRelatedTo"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="source_id" value="424c803a-aefb-4b54-8e45-d177fedac893"/>
            <column name="target_id" value="dd15032b-ce2b-40b6-80ac-97623255b531"/>
        </insert>
        <insert tableName="directed_edge">
            <column name="id" value="d0e38444-b7b0-4902-90cb-b4c3ead9b2f3"/>
            <column name="description" value="&quot;The quantum module only accepts inputs in known formats, while the quantum module template additionally accepts (arbitrary) quantum computing instructions that get integrated into the generated quantum circuit.&quot;"/>
            <column name="type" value="isVariationOf"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="source_id" value="d5cda8c9-f39b-474a-9032-c17131884975"/>
            <column name="target_id" value="424c803a-aefb-4b54-8e45-d177fedac893"/>
        </insert>
        <insert tableName="directed_edge">
            <column name="id" value="f9ba8237-240d-4290-8af4-d2b6b6ab13ea"/>
            <column name="description" value="&quot;A Quantum Module can be used as part of a Hybrid Module.&quot;"/>
            <column name="type" value="canBeUsedWith"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="source_id" value="424c803a-aefb-4b54-8e45-d177fedac893"/>
            <column name="target_id" value="4074490a-4236-49ed-83d1-625ce58e2dbd"/>
        </insert>
        <insert tableName="directed_edge">
            <column name="id" value="46ecfadb-6110-46df-82dc-a217d546628f"/>
            <column name="description" value="&quot;Quantum Modules and Quantum Module Templates can be used to build larger quantum circuits from small modules, provided they are compatible with each other.&quot;"/>
            <column name="type" value="canBeUsedWith"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="source_id" value="d5cda8c9-f39b-474a-9032-c17131884975"/>
            <column name="target_id" value="424c803a-aefb-4b54-8e45-d177fedac893"/>
        </insert>
        <insert tableName="directed_edge">
            <column name="id" value="ece451df-6563-401a-a6fa-314df54b5d19"/>
            <column name="description" value="&quot;Quantum Module Templates can accept Oracles as behavior inputs that get integrated into the final quantum circuit (this process is also called oracle expansion).&quot;"/>
            <column name="type" value="canBeUsedWith"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="source_id" value="d5cda8c9-f39b-474a-9032-c17131884975"/>
            <column name="target_id" value="1cc7e9d6-ab37-412e-8afa-604a25de296e"/>
        </insert>
        <insert tableName="directed_edge">
            <column name="id" value="1937aaec-0602-4db2-ab3b-a315f29734a9"/>
            <column name="description" value="&quot;A Quantum Module Template can be used as part of a Hybrid Module.&quot;"/>
            <column name="type" value="canBeUsedWith"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="source_id" value="d5cda8c9-f39b-474a-9032-c17131884975"/>
            <column name="target_id" value="4074490a-4236-49ed-83d1-625ce58e2dbd"/>
        </insert>
        <insert tableName="undirected_edge">
            <column name="id" value="c8f4cf52-cfec-4801-b66b-1a2a20540ab1"/>
            <column name="description" value="&quot;A Hybrid Module can be used together with a Classical-Quantum Interface to create a module that can directly be used by domain experts without quantum computing knowledge.&quot;"/>
            <column name="type" value="canBeUsedWith"/>
            <column name="p1_id" value="8fcca2dc-fca0-47cf-9bd4-038cd2fe8fb8"/>
            <column name="p2_id" value="4074490a-4236-49ed-83d1-625ce58e2dbd"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
        </insert>
        <insert tableName="directed_edge">
            <column name="id" value="ff85ec6b-1cc6-490c-9d0a-03822f707a31"/>
            <column name="description" value="&quot;The Classical-Quantum Interface bridges the gap between the quantum and the classical world.&quot;"/>
            <column name="type" value="isRelatedTo"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="source_id" value="8fcca2dc-fca0-47cf-9bd4-038cd2fe8fb8"/>
            <column name="target_id" value="dd15032b-ce2b-40b6-80ac-97623255b531"/>
        </insert>
        <insert tableName="directed_edge">
            <column name="id" value="1c5dfa20-065d-47b5-a9ff-3854c7c55c60"/>
            <column name="description" value="&quot;A Quantum Circuit Translator can be used to translate the circuits generated by a Quantum Module.&quot;"/>
            <column name="type" value="canBeUsedWith"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="source_id" value="aa90de15-b7e3-45a7-bb48-f0a5b8b2c479"/>
            <column name="target_id" value="424c803a-aefb-4b54-8e45-d177fedac893"/>
        </insert>
        <insert tableName="directed_edge">
            <column name="id" value="0e9d18cd-1714-4ee4-b3fc-6d741dfcad35"/>
            <column name="description" value="&quot;A Quantum Circuit Translator can be used to translate the behavior inputs for a Quantum Module Template.&quot;"/>
            <column name="type" value="canBeUsedWith"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="source_id" value="aa90de15-b7e3-45a7-bb48-f0a5b8b2c479"/>
            <column name="target_id" value="d5cda8c9-f39b-474a-9032-c17131884975"/>
        </insert>
    </changeSet>
</databaseChangeLog>
