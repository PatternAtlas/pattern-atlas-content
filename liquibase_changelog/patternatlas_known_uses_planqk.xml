<?xml version="1.1" encoding="UTF-8" standalone="no"?>
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
    xmlns:ext="http://www.liquibase.org/xml/ns/dbchangelog-ext"
    xmlns:pro="http://www.liquibase.org/xml/ns/pro"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd
                        http://www.liquibase.org/xml/ns/pro http://www.liquibase.org/xml/ns/pro/liquibase-pro-latest.xsd
                        http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">
    <changeSet author="alex" id="1684928287000-1">
        <update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;Create a uniform superposition of all possible states of a quantum register&quot;, &quot;Result&quot;: &quot;A [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) can be achieved by performing a single parallel operation on each qubit, increasing the depth of the entire circuit by only one.\n\n&quot;, &quot;Context&quot;: &quot;The power of quantum algorithms partially originates in the ability to represent multiple states at once, the so-called quantum parallelism.  \nTo realize quantum parallelism, some qubits of a quantum register must be brought into superposition.  \nMany algorithms start with obtaining an equally weighted superposition in (a part of) a quantum register. \nTherefore, for every state represented by (this part of) the quantum register,  the measurement probability is the same.&quot;, &quot;Solution&quot;: &quot;After initializing the quantum register as the unit vector $\\left|0 \\ldots 0\\right&gt;$, a Uniform Superposition is created via the Hadamard transformation:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}H^{\\otimes n} \\left( \\left| 0 \\right&gt;^{\\otimes n} \\right)= \\dfrac{1}{\\sqrt{2^n}} \\sum_{x=0}^{2^n-1} \\left|x \\right&gt;$$\nThe quantum register may also include ancilla bits that must not necessarily be brought into superposition.\nFor example, if the last part of the quantum register is used for ancilla qubits, a different [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) on the two parts of the register can be accomplished by using a tensor product operator $H^{\\otimes n}\\otimes U$ where the Hadamard transformation $H^{\\otimes n}$ only operates on the first part and $U$ operates on the ancilla qubits. If the ancilla qubits are not brought into superposition, $U$ is the Identity (e.g., $U=I^{\\otimes m}$):\n$$ \n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\nH^{\\otimes n} \\otimes I^{\\otimes m} \\left( \\left| 0 \\right&gt;^{\\otimes n} \\otimes \\left| 0 \\right&gt;^{\\otimes m} \\right)= \\frac{1}{\\sqrt{2^n}} \\sum_{x=0}^{2^n-1} \\left|x \\right&gt; \\otimes \\state{0}^{\\otimes m}\n$$&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;Countless quantum algorithms start with a  uniform superposition.\n\n[Grover's Algorithm (QC-Atlas)](http://localhost/#/algorithms/0e5af2cf-f3c8-48dd-9743-cfdea65f320f)\n[DÃ¼rr-HÃ¸yer Quantum Minimization Algorithm (PlanQK)](https://platform.planqk.de/algorithms/061f4eb3-d9ee-4f47-befc-9e242bf801ce/)\n[Quantum Phase Estimation (QC-Atlas)](http://localhost/#/algorithms/b61578ed-df66-44ec-954c-9bcf9906f490)\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n\n&quot;, &quot;Related Patterns&quot;: &quot;[Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) is a special case of [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d).  \nAfter a register is brought into uniform superposition, [Creating Entanglement](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3d1f3991-df47-4d42-8f9a-e6dcf4e3ccec) may be used. \nA [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee)can be computed on a register in uniform superposition.\nAn [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e) may  require its input to be in uniform superposition.&quot;}"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;Create a uniform superposition of all possible states of a quantum register&quot;, &quot;Result&quot;: &quot;A [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) can be achieved by performing a single parallel operation on each qubit, increasing the depth of the entire circuit by only one.\n\n&quot;, &quot;Context&quot;: &quot;The power of quantum algorithms partially originates in the ability to represent multiple states at once, the so-called quantum parallelism.  \nTo realize quantum parallelism, some qubits of a quantum register must be brought into superposition.  \nMany algorithms start with obtaining an equally weighted superposition in (a part of) a quantum register. \nTherefore, for every state represented by (this part of) the quantum register,  the measurement probability is the same.&quot;, &quot;Solution&quot;: &quot;After initializing the quantum register as the unit vector $\\left|0 \\ldots 0\\right&gt;$, a Uniform Superposition is created via the Hadamard transformation:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}H^{\\otimes n} \\left( \\left| 0 \\right&gt;^{\\otimes n} \\right)= \\dfrac{1}{\\sqrt{2^n}} \\sum_{x=0}^{2^n-1} \\left|x \\right&gt;$$\nThe quantum register may also include ancilla bits that must not necessarily be brought into superposition.\nFor example, if the last part of the quantum register is used for ancilla qubits, a different [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) on the two parts of the register can be accomplished by using a tensor product operator $H^{\\otimes n}\\otimes U$ where the Hadamard transformation $H^{\\otimes n}$ only operates on the first part and $U$ operates on the ancilla qubits. If the ancilla qubits are not brought into superposition, $U$ is the Identity (e.g., $U=I^{\\otimes m}$):\n$$ \n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\nH^{\\otimes n} \\otimes I^{\\otimes m} \\left( \\left| 0 \\right&gt;^{\\otimes n} \\otimes \\left| 0 \\right&gt;^{\\otimes m} \\right)= \\frac{1}{\\sqrt{2^n}} \\sum_{x=0}^{2^n-1} \\left|x \\right&gt; \\otimes \\state{0}^{\\otimes m}\n$$&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;Countless quantum algorithms start with a  uniform superposition.\n\n[Grover's Algorithm (QC-Atlas)](http://localhost/#/algorithms/0e5af2cf-f3c8-48dd-9743-cfdea65f320f)\n[DÃ¼rr-HÃ¸yer Quantum Minimization Algorithm (PlanQK)](https://platform.planqk.de/algorithms/061f4eb3-d9ee-4f47-befc-9e242bf801ce/)\n[Quantum Phase Estimation (QC-Atlas)](http://localhost/#/algorithms/b61578ed-df66-44ec-954c-9bcf9906f490)\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n\n&quot;, &quot;Related Patterns&quot;: &quot;[Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) is a special case of [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d).  \nAfter a register is brought into uniform superposition, [Creating Entanglement](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3d1f3991-df47-4d42-8f9a-e6dcf4e3ccec) may be used. \nA [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee)can be computed on a register in uniform superposition.\nAn [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e) may  require its input to be in uniform superposition.&quot;}"/>
            <where>id='2229a430-fe92-4411-9d72-d10dd1d8da14'</where>
        </update>
		<update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;Dynamic Encoding [[Schuld and Petruccione 2018](http://dx.doi.org/10.1007/978-3-319-96424-9)]&quot;, &quot;Intent&quot;: &quot;Represent a matrix as an operation on a quantum computer&quot;, &quot;Result&quot;: &quot;Since the eigenvectors $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\{\\state{v_i}\\}$ of the $n \\times n$ matrix $H$ form a basis, each state vector $\\ket{\\psi}$ can be written as a linear combination of these eigenvectors: \n$$ \\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{\\psi}= \\gamma_1 \\state{v_1} + \\ldots + \\gamma_n \\state{v_n}$$\nApplying $U$ to this state results in the following state [[Schuld and Petruccione 2018](http://dx.doi.org/10.1007/978-3-319-96424-9)]:\n$$\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}e^{-iHt} \\state{\\psi}= e^{-i \\lambda_1 t} \\gamma_1 \\state{v_1} + \\ldots + e^{-i \\lambda_n t} \\gamma_n \\state{v_n}$$\nIf $\\ket{\\psi}$ is an eigenvector of $H$ and thus, only one $\\gamma_i \\neq 0$, the state acquires a global phase shift: $U \\gamma_i \\ket{v_i} = e^{-i \\lambda_i t} \\gamma_i \\ket{v_i}$ (see original paper for a definition of phase shift). This nicely reflects that applying the matrix A to an eigenstate leads to a scaling factor.\nThe main drawback of this encoding is that the depth of the circuit that implements $U$ can be exponential.&quot;, &quot;Context&quot;: &quot;A matrix $A$ has to be represented on a quantum computer as an operation $U$. \nTherefore, it is not sufficient to represent the entries of the matrix by a data encoding pattern as this does not define an operation.&quot;, &quot;Solution&quot;: &quot;If $A$ is not Hermitian, encode\n$$H = \\left( \\begin{matrix}0 &amp; A\\\\ A^{\\dagger} &amp; 0 \\end{matrix} \\right) $$\ninstead of A. Since $H$ is hermitian, $U=e^{-iHt}$ is unitary and can be used to encode $H$ where $t$ specifies the time for which the operation is applied (usually $t$ is chosen to be small). &quot;, &quot;Variants&quot;: &quot;Enter your input for this section here.&quot;, &quot;Known Uses&quot;: &quot;This encoding is often used for the simulation of a quantum system, see [[Nielsen and Chuang 2002](https://doi.org/10.1119/1.1463744)] for various examples. The HHL algorithm for solving linear equations~ HHL algorithm [[Harrow, Hassidim and Lloyd 2009](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502)] is an example of an algorithm that uses _Matrix Encoding_ in conjunction with _Quantum Phase Estimation_. [Pennylane](https://pennylane.readthedocs.io/en/stable/code/api/pennylane.templates.subroutines.ApproxTimeEvolution.html) provides an implementation for this encoding.\n\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern can be used to define a unitary operation as input for [Quantum Phase Estimation](pattern-languages/a4ea9f6c-5b0a-4beb-a056-8b261d96ba80/a4ea9f6c-5b0a-4beb-a056-8b261d96ba80).&quot;}"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;Dynamic Encoding [[Schuld and Petruccione 2018](http://dx.doi.org/10.1007/978-3-319-96424-9)]&quot;, &quot;Intent&quot;: &quot;Represent a matrix as an operation on a quantum computer&quot;, &quot;Result&quot;: &quot;Since the eigenvectors $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\{\\state{v_i}\\}$ of the $n \\times n$ matrix $H$ form a basis, each state vector $\\ket{\\psi}$ can be written as a linear combination of these eigenvectors: \n$$ \\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{\\psi}= \\gamma_1 \\state{v_1} + \\ldots + \\gamma_n \\state{v_n}$$\nApplying $U$ to this state results in the following state [[Schuld and Petruccione 2018](http://dx.doi.org/10.1007/978-3-319-96424-9)]:\n$$\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}e^{-iHt} \\state{\\psi}= e^{-i \\lambda_1 t} \\gamma_1 \\state{v_1} + \\ldots + e^{-i \\lambda_n t} \\gamma_n \\state{v_n}$$\nIf $\\ket{\\psi}$ is an eigenvector of $H$ and thus, only one $\\gamma_i \\neq 0$, the state acquires a global phase shift: $U \\gamma_i \\ket{v_i} = e^{-i \\lambda_i t} \\gamma_i \\ket{v_i}$ (see original paper for a definition of phase shift). This nicely reflects that applying the matrix A to an eigenstate leads to a scaling factor.\nThe main drawback of this encoding is that the depth of the circuit that implements $U$ can be exponential.&quot;, &quot;Context&quot;: &quot;A matrix $A$ has to be represented on a quantum computer as an operation $U$. \nTherefore, it is not sufficient to represent the entries of the matrix by a data encoding pattern as this does not define an operation.&quot;, &quot;Solution&quot;: &quot;If $A$ is not Hermitian, encode\n$$H = \\left( \\begin{matrix}0 &amp; A\\\\ A^{\\dagger} &amp; 0 \\end{matrix} \\right) $$\ninstead of A. Since $H$ is hermitian, $U=e^{-iHt}$ is unitary and can be used to encode $H$ where $t$ specifies the time for which the operation is applied (usually $t$ is chosen to be small). &quot;, &quot;Variants&quot;: &quot;Enter your input for this section here.&quot;, &quot;Known Uses&quot;: &quot;This encoding is often used for the simulation of a quantum system, see [[Nielsen and Chuang 2002](https://doi.org/10.1119/1.1463744)] for various examples. The HHL algorithm for solving linear equations~ HHL algorithm [[Harrow, Hassidim and Lloyd 2009](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502)] is an example of an algorithm that uses _Matrix Encoding_ in conjunction with _Quantum Phase Estimation_. [Pennylane](https://pennylane.readthedocs.io/en/stable/code/api/pennylane.templates.subroutines.ApproxTimeEvolution.html) provides an implementation for this encoding.\n\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern can be used to define a unitary operation as input for [Quantum Phase Estimation](pattern-languages/a4ea9f6c-5b0a-4beb-a056-8b261d96ba80/a4ea9f6c-5b0a-4beb-a056-8b261d96ba80).&quot;}"/>
            <where>id='45d09c54-3f4a-453b-885d-2772443c8d72'</where>
        </update>
		<update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;This pattern has also been referred to as Unentangling or Copy-Uncompute.&quot;, &quot;Intent&quot;: &quot;Remove entanglement that resulted from a previous computation &quot;, &quot;Result&quot;: &quot;The resulting register $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{x} \\state{0} \\state{f(x)}$ contains the input $x$ and the computed function values $f(x)$.  \nThe previous entanglement (caused by the computation) is no longer present.&quot;, &quot;Context&quot;: &quot;Quantum algorithms often use ancilla qubits as temporary qubits for their computations. \nAfter a computation, these qubits are often still entangled with the computational basis of the quantum register.  \nThis prevents unrestricted access to the results of the computation.  \nThis is especially problematic if the performed calculations are only intermediate steps within a larger algorithm.\nFor example, assume a computation should produce a weighted superposition $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\sum \\alpha_i \\state{\\phi_i}$, but produces $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\sum \\alpha_i \\state{\\phi_i} \\state{\\psi_i}$ instead, where $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_i}$ denotes the state of the ancilla qubits. \nThe second part of the register containing the ancilla qubits cannot be discarded unless \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\sum \\alpha_i \\state{\\phi_i} \\state{\\psi_i} = \\left( \\sum \\alpha_i \\right) \\state{\\phi_i} \\state{\\psi_i}$$\nholds, i.e.,  unless the two parts of the register are separable.&quot;, &quot;Solution&quot;: &quot;When computing a function $f$, many algorithms map $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{x}\\state{0}\\state{0}$ to $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{x}\\state{g(x)}\\state{f(x)}$  [(Derovic et al. 2018)](https://arxiv.org/abs/1802.08227).  \nAs a result, the second part of the register represents a workspace containing the byproduct $g(x)$ of the computation of $f(x)$, which is not needed anymore.  \nThis garbage part of the register has to be reset, especially if the following parts of the algorithm expect a proper initialization of the workspace as $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{0 \\ldots 0}$.  \nMore specifically,  assume the following state to be the result of the computation $U_f$:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{x}\\state{0}\\state{0} \\xrightarrow{U_f} \\sum \\alpha_y \\state{x}\\state{y}\\state{f(x)}$$\n\n\nwith $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{g(x)} = \\sum \\alpha_y \\state{y}$ being the garbage state.\nThen, a fourth register is added and initialized as $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{0}$. \nThen, CNOT is applied (bitwise) to this fourth register controlled by the third register containing the actual results of the computation. \nThereby, $f(x)$ is copied to the fourth register which results in $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\sum \\alpha_y \\state{x} \\state{y} \\state{f(x)} \\state{f(x)}$.  \nTo reset the potentially entangled first three registers, the inverse operator $U^{-1}_f$ is applied to them, resulting in $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{x} \\state{0} \\state{0} \\state{f(x)}$.\nBy application of the SWAP operator,  the entries of the last two registers are swapped: $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{x} \\state{0} \\state{f(x)} \\state{0}$. \nThe fourth register is in the state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{0}$ again and can be discarded, leaving $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{x} \\state{0} \\state{f(x)}$ as final result (see [(Derovic et al. 2018)](https://arxiv.org/abs/1802.08227) for a more detailed description).\nHow a [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc) operation can be realized in several other situations is described in [(Proos and Zalka 2003)](https://www.researchgate.net/publication/2189624_Shor%27s_Discrete_Logarithm_Quantum_Algorithm_for_Elliptic_Curves).&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;Several algorithms like the Deutsch-Joza,  the HHL algorithm [(Harrow, Hassidim and Lloyd 2009)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502), and quantum walks make use of [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc).\n\n[Grover's Algorithm (QC-Atlas)](http://localhost/#/algorithms/0e5af2cf-f3c8-48dd-9743-cfdea65f320f)\n[Shor's Algorithm (QC-Atlas)](http://localhost/#/algorithms/b5df6c13-e619-496c-ada0-80fc3486f733)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)\n&quot;, &quot;Related Patterns&quot;: &quot;Applying an [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e) often results in a state where ancilla qubits are entangled with other qubits, and therefore, requires the application of [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc). \nA [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee) can show the same behavior as a special case of an oracle.&quot;}"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;This pattern has also been referred to as Unentangling or Copy-Uncompute.&quot;, &quot;Intent&quot;: &quot;Remove entanglement that resulted from a previous computation &quot;, &quot;Result&quot;: &quot;The resulting register $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{x} \\state{0} \\state{f(x)}$ contains the input $x$ and the computed function values $f(x)$.  \nThe previous entanglement (caused by the computation) is no longer present.&quot;, &quot;Context&quot;: &quot;Quantum algorithms often use ancilla qubits as temporary qubits for their computations. \nAfter a computation, these qubits are often still entangled with the computational basis of the quantum register.  \nThis prevents unrestricted access to the results of the computation.  \nThis is especially problematic if the performed calculations are only intermediate steps within a larger algorithm.\nFor example, assume a computation should produce a weighted superposition $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\sum \\alpha_i \\state{\\phi_i}$, but produces $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\sum \\alpha_i \\state{\\phi_i} \\state{\\psi_i}$ instead, where $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_i}$ denotes the state of the ancilla qubits. \nThe second part of the register containing the ancilla qubits cannot be discarded unless \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\sum \\alpha_i \\state{\\phi_i} \\state{\\psi_i} = \\left( \\sum \\alpha_i \\right) \\state{\\phi_i} \\state{\\psi_i}$$\nholds, i.e.,  unless the two parts of the register are separable.&quot;, &quot;Solution&quot;: &quot;When computing a function $f$, many algorithms map $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{x}\\state{0}\\state{0}$ to $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{x}\\state{g(x)}\\state{f(x)}$  [(Derovic et al. 2018)](https://arxiv.org/abs/1802.08227).  \nAs a result, the second part of the register represents a workspace containing the byproduct $g(x)$ of the computation of $f(x)$, which is not needed anymore.  \nThis garbage part of the register has to be reset, especially if the following parts of the algorithm expect a proper initialization of the workspace as $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{0 \\ldots 0}$.  \nMore specifically,  assume the following state to be the result of the computation $U_f$:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{x}\\state{0}\\state{0} \\xrightarrow{U_f} \\sum \\alpha_y \\state{x}\\state{y}\\state{f(x)}$$\n\n\nwith $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{g(x)} = \\sum \\alpha_y \\state{y}$ being the garbage state.\nThen, a fourth register is added and initialized as $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{0}$. \nThen, CNOT is applied (bitwise) to this fourth register controlled by the third register containing the actual results of the computation. \nThereby, $f(x)$ is copied to the fourth register which results in $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\sum \\alpha_y \\state{x} \\state{y} \\state{f(x)} \\state{f(x)}$.  \nTo reset the potentially entangled first three registers, the inverse operator $U^{-1}_f$ is applied to them, resulting in $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{x} \\state{0} \\state{0} \\state{f(x)}$.\nBy application of the SWAP operator,  the entries of the last two registers are swapped: $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{x} \\state{0} \\state{f(x)} \\state{0}$. \nThe fourth register is in the state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{0}$ again and can be discarded, leaving $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{x} \\state{0} \\state{f(x)}$ as final result (see [(Derovic et al. 2018)](https://arxiv.org/abs/1802.08227) for a more detailed description).\nHow a [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc) operation can be realized in several other situations is described in [(Proos and Zalka 2003)](https://www.researchgate.net/publication/2189624_Shor%27s_Discrete_Logarithm_Quantum_Algorithm_for_Elliptic_Curves).&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;Several algorithms like the Deutsch-Joza,  the HHL algorithm [(Harrow, Hassidim and Lloyd 2009)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502), and quantum walks make use of [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc).\n\n[Grover's Algorithm (QC-Atlas)](http://localhost/#/algorithms/0e5af2cf-f3c8-48dd-9743-cfdea65f320f)\n[Shor's Algorithm (QC-Atlas)](http://localhost/#/algorithms/b5df6c13-e619-496c-ada0-80fc3486f733)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)\n&quot;, &quot;Related Patterns&quot;: &quot;Applying an [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e) often results in a state where ancilla qubits are entangled with other qubits, and therefore, requires the application of [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc). \nA [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee) can show the same behavior as a special case of an oracle.&quot;}"/>
            <where>id='d4f7c247-e2bb-4301-ad06-f758fa58f2dc'</where>
        </update>
		<update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;This pattern has also been referred to as State Preparation. &quot;, &quot;Intent&quot;: &quot;Initialize the input of a quantum register, taking into account the prerequisites of the subsequent steps of the algorithm.&quot;, &quot;Result&quot;: &quot;More advanced states may be prepared which build on the previously described initialization techniques.\nFor example, in [(Cortese and Braje 2018)](https://arxiv.org/abs/1803.01958) various algorithms for loading classical bits into a quantum register are presented.  \nComplex vectors can be loaded as described in [(Nielsen and Chuang 2002)](https://doi.org/10.1119/1.1463744). \n[(Derovic et al. 2018)](https://arxiv.org/abs/1802.08227) describes how a real-valued vector can be loaded; therefore, it is also possible to load a matrix that is represented as a set of vectors [(Kerenidis and Prakash 2016)](https://arxiv.org/abs/1603.08675).&quot;, &quot;Context&quot;: &quot;Usually, the underlying problem to be solved by a quantum algorithm is represented by specific parameters. \nThese parameters must be given as input data to the algorithm in order to solve the problem.\nIn most algorithms, the process of loading the input data is part of the quantum algorithm itself,  which is defined as a unitary transformation $U$ and measurements.  \nIn this case, the overall algorithm $U = U_n \\circ \\ldots  \\circ U_{i}  \\circ U_{i-1} \\circ \\ldots  \\circ U_1,$  can be split up into two parts. \nThe operators of the first part  $U_1, \\ldots , U_{i-1}$ encode the input data into the quantum register according to a defined encoding,  whereas the operators of the second part $U_i, \\ldots , U_n$ are used to solve the problem.  \nSince $U_{i-1} \\circ  \\ldots  \\circ U_1$ set the register to an initial state, this step is referred to as state preparation.&quot;, &quot;Solution&quot;: &quot;Frequently, the unit vector $\\left| 0 \\ldots 0\\right&gt;$ is used as initialization of a quantum register.  \nSome qubits of the register can be used as so-called ancilla bits (working qubits) which may be used for the storage of intermediate results or quantum error correction. \nFor example, to compute the function table of a Boolean function $f:\\{0, 1\\}^n \\rightarrow \\{0, 1\\}^m$, the overall register is initialized as $\\left| 0 \\right&gt;^{\\otimes n}\\left| 0 \\right&gt;^{\\otimes m}$ (including $m$ ancilla bits in the second part of the register).  \nTo expose membership in an indicator function-based set (e.g., in decision problems) often an initialization with $\\left| 0 \\right&gt;^{\\otimes n}\\left| 1 \\right&gt;$ is chosen.  \nThe membership to the set is then indicated by changing the sign of the qubits representing members of this set. &quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;Initialization is the first step in every quantum algorithm.\n\n[Grover's Algorithm (QC-Atlas)](http://localhost/#/algorithms/0e5af2cf-f3c8-48dd-9743-cfdea65f320f)\n[Shor's Algorithm (QC-Atlas)](http://localhost/#/algorithms/b5df6c13-e619-496c-ada0-80fc3486f733)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)\n&quot;, &quot;Related Patterns&quot;: &quot;Patterns like [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750) or [Quantum Associative Memory (QuAM)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/482714a7-8409-4165-93fe-72b02c2ae99c) further refine [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d).  \n[Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) is often used as an initial state.  \nAn initialized register may be used to compute a [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee).&quot;}"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;This pattern has also been referred to as State Preparation. &quot;, &quot;Intent&quot;: &quot;Initialize the input of a quantum register, taking into account the prerequisites of the subsequent steps of the algorithm.&quot;, &quot;Result&quot;: &quot;More advanced states may be prepared which build on the previously described initialization techniques.\nFor example, in [(Cortese and Braje 2018)](https://arxiv.org/abs/1803.01958) various algorithms for loading classical bits into a quantum register are presented.  \nComplex vectors can be loaded as described in [(Nielsen and Chuang 2002)](https://doi.org/10.1119/1.1463744). \n[(Derovic et al. 2018)](https://arxiv.org/abs/1802.08227) describes how a real-valued vector can be loaded; therefore, it is also possible to load a matrix that is represented as a set of vectors [(Kerenidis and Prakash 2016)](https://arxiv.org/abs/1603.08675).&quot;, &quot;Context&quot;: &quot;Usually, the underlying problem to be solved by a quantum algorithm is represented by specific parameters. \nThese parameters must be given as input data to the algorithm in order to solve the problem.\nIn most algorithms, the process of loading the input data is part of the quantum algorithm itself,  which is defined as a unitary transformation $U$ and measurements.  \nIn this case, the overall algorithm $U = U_n \\circ \\ldots  \\circ U_{i}  \\circ U_{i-1} \\circ \\ldots  \\circ U_1,$  can be split up into two parts. \nThe operators of the first part  $U_1, \\ldots , U_{i-1}$ encode the input data into the quantum register according to a defined encoding,  whereas the operators of the second part $U_i, \\ldots , U_n$ are used to solve the problem.  \nSince $U_{i-1} \\circ  \\ldots  \\circ U_1$ set the register to an initial state, this step is referred to as state preparation.&quot;, &quot;Solution&quot;: &quot;Frequently, the unit vector $\\left| 0 \\ldots 0\\right&gt;$ is used as initialization of a quantum register.  \nSome qubits of the register can be used as so-called ancilla bits (working qubits) which may be used for the storage of intermediate results or quantum error correction. \nFor example, to compute the function table of a Boolean function $f:\\{0, 1\\}^n \\rightarrow \\{0, 1\\}^m$, the overall register is initialized as $\\left| 0 \\right&gt;^{\\otimes n}\\left| 0 \\right&gt;^{\\otimes m}$ (including $m$ ancilla bits in the second part of the register).  \nTo expose membership in an indicator function-based set (e.g., in decision problems) often an initialization with $\\left| 0 \\right&gt;^{\\otimes n}\\left| 1 \\right&gt;$ is chosen.  \nThe membership to the set is then indicated by changing the sign of the qubits representing members of this set. &quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;Initialization is the first step in every quantum algorithm.\n\n[Grover's Algorithm (QC-Atlas)](http://localhost/#/algorithms/0e5af2cf-f3c8-48dd-9743-cfdea65f320f)\n[Shor's Algorithm (QC-Atlas)](http://localhost/#/algorithms/b5df6c13-e619-496c-ada0-80fc3486f733)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)\n&quot;, &quot;Related Patterns&quot;: &quot;Patterns like [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750) or [Quantum Associative Memory (QuAM)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/482714a7-8409-4165-93fe-72b02c2ae99c) further refine [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d).  \n[Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) is often used as an initial state.  \nAn initialized register may be used to compute a [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee).&quot;}"/>
            <where>id='312bc9d3-26c0-40ae-b90b-56effd136c0d'</where>
        </update>
		<update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;Enforce a strong correlation between qubits by entangling them.&quot;, &quot;Result&quot;: &quot;Unitary transformations that create entanglement must include multi-qubit operators such as CNOT.  \nSuch operators typically have a lower gate fidelity than single qubit operators and therefore increase the overall gate error.&quot;, &quot;Context&quot;: &quot;Entanglement is a unique characteristic of quantum mechanics and one of the causes for the power of quantum algorithms [(BruÃ and Macchiavello 2011)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.83.052313). \nAlthough entanglement is not necessarily needed for a powerful quantum algorithm [(Biham et al. 2004)](https://www.sciencedirect.com/science/article/pii/S0304397504001926), it is required to achieve an exponential speedup over classical algorithms [(Jozsa and Linden 2003)](https://royalsocietypublishing.org/doi/abs/10.1098/rspa.2002.1097).  \nConsequently, a quantum register is often entangled for further processing after the [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d).&quot;, &quot;Solution&quot;: &quot;There exist numerous approaches for the creation of an entangled state.\nFor example, entanglement can be created by a Boolean function $f:\\{0, 1\\}^n \\rightarrow \\{0, 1\\}^m$, a corresponding unitary operation\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}U_f: \\{0, 1\\}^{n+m} \\rightarrow \\{0, 1\\}^{n+m}, U_f \\left(\\left| x,y \\right&gt; \\right) =  \\left| x,y\\oplus f(x) \\right&gt;$$ \nand a [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) in the first $n$ qubits of the quantum register:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}U_f \\left(H^{\\otimes n} \\otimes I^{\\otimes m} \\right) \\left( \\left| 0 \\right&gt;^{\\otimes n} \\otimes \\left|0 \\right&gt; ^{\\otimes m} \\right) $$ \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}= U_f \\left( \\dfrac{1}{\\sqrt{2^n}} \\sum_{x=0}^{2^n-1} \\left|x \\right&gt; \\otimes \\state{0}^{\\otimes m} \\right) $$\nThe resulting state is entangled.\nFor $f = id$, $U_{f}=CNOT$ and consequently $CNOT \\left(H \\otimes I \\right) \\left( \\left| 0 \\right&gt; \\otimes \\left|0 \\right&gt; \\right)$ is entangled.\n\n&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;Most algorithms use entangled states.\nA [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee) may create an entangled state, by making use of the above-defined unitary operation $U_f$ of a Boolean function $f$.\n\n[Quantum Phase Estimation (QC-Atlas)](http://localhost/#/algorithms/b61578ed-df66-44ec-954c-9bcf9906f490)\n[Grover's Algorithm (QC-Atlas)](http://localhost/#/algorithms/0e5af2cf-f3c8-48dd-9743-cfdea65f320f)\n[Deutsch algorithm (PlanQK)](https://platform.planqk.de/algorithms/533c90a5-5fbb-487b-b64d-a8f331aafb10/)\n&quot;, &quot;Related Patterns&quot;: &quot;A quantum register must make use of [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) before entanglement can be created.\nApplying $U_{f}$ as described above computes a [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee) and makes use of [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14).&quot;}"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;Enforce a strong correlation between qubits by entangling them.&quot;, &quot;Result&quot;: &quot;Unitary transformations that create entanglement must include multi-qubit operators such as CNOT.  \nSuch operators typically have a lower gate fidelity than single qubit operators and therefore increase the overall gate error.&quot;, &quot;Context&quot;: &quot;Entanglement is a unique characteristic of quantum mechanics and one of the causes for the power of quantum algorithms [(BruÃ and Macchiavello 2011)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.83.052313). \nAlthough entanglement is not necessarily needed for a powerful quantum algorithm [(Biham et al. 2004)](https://www.sciencedirect.com/science/article/pii/S0304397504001926), it is required to achieve an exponential speedup over classical algorithms [(Jozsa and Linden 2003)](https://royalsocietypublishing.org/doi/abs/10.1098/rspa.2002.1097).  \nConsequently, a quantum register is often entangled for further processing after the [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d).&quot;, &quot;Solution&quot;: &quot;There exist numerous approaches for the creation of an entangled state.\nFor example, entanglement can be created by a Boolean function $f:\\{0, 1\\}^n \\rightarrow \\{0, 1\\}^m$, a corresponding unitary operation\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}U_f: \\{0, 1\\}^{n+m} \\rightarrow \\{0, 1\\}^{n+m}, U_f \\left(\\left| x,y \\right&gt; \\right) =  \\left| x,y\\oplus f(x) \\right&gt;$$ \nand a [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) in the first $n$ qubits of the quantum register:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}U_f \\left(H^{\\otimes n} \\otimes I^{\\otimes m} \\right) \\left( \\left| 0 \\right&gt;^{\\otimes n} \\otimes \\left|0 \\right&gt; ^{\\otimes m} \\right) $$ \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}= U_f \\left( \\dfrac{1}{\\sqrt{2^n}} \\sum_{x=0}^{2^n-1} \\left|x \\right&gt; \\otimes \\state{0}^{\\otimes m} \\right) $$\nThe resulting state is entangled.\nFor $f = id$, $U_{f}=CNOT$ and consequently $CNOT \\left(H \\otimes I \\right) \\left( \\left| 0 \\right&gt; \\otimes \\left|0 \\right&gt; \\right)$ is entangled.\n\n&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;Most algorithms use entangled states.\nA [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee) may create an entangled state, by making use of the above-defined unitary operation $U_f$ of a Boolean function $f$.\n\n[Quantum Phase Estimation (QC-Atlas)](http://localhost/#/algorithms/b61578ed-df66-44ec-954c-9bcf9906f490)\n[Grover's Algorithm (QC-Atlas)](http://localhost/#/algorithms/0e5af2cf-f3c8-48dd-9743-cfdea65f320f)\n[Deutsch algorithm (PlanQK)](https://platform.planqk.de/algorithms/533c90a5-5fbb-487b-b64d-a8f331aafb10/)\n&quot;, &quot;Related Patterns&quot;: &quot;A quantum register must make use of [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) before entanglement can be created.\nApplying $U_{f}$ as described above computes a [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee) and makes use of [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14).&quot;}"/>
            <where>id='3d1f3991-df47-4d42-8f9a-e6dcf4e3ccec'</where>
        </update>
		<update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;Increase the probability of finding a solution&quot;, &quot;Result&quot;: &quot;The probability of measuring a solution is increased.&quot;, &quot;Context&quot;: &quot;For a specific indicator function $f$ the corresponding function table may list all possible solutions of a problem, i.e.  $f(x)=1 \\Leftrightarrow x$ is a solution to the problem.  \nWhen the corresponding state is measured, a solution can be found with a certain probability.\nSince measuring destroys the state, the computation has to be repeated if no solution is found by the measurement in order to be able to do another measurement of the state.\nTo keep computational costs low, a mechanism without measurements is required. &quot;, &quot;Solution&quot;: &quot;The overall state is transformed such that the probability of measuring certain values of interest increases with every iteration by modifying their amplitude [(Brassard et al. 2002)](https://arxiv.org/abs/quant-ph/0005055).\nThis is done via the help of a phase shift $S_G^\\pi$, which changes the sign of the phase of elements in the set of solutions $G$ while all other elements remain unchanged.\nAnother phase shift that is used is $S_0^\\pi$ which changes only the sign of the zero state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{0}$.\nSuppose there is an algorithm $U$ for computing approximate solutions (without any measurements).\nThe following unitary operation can be defined: \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}Q = -U S_0^\\pi U^{-1} S_G^\\pi$$\nIf the success probability of the algorithm $U$ is $t$, the average amount of iterations required to find a solution is $1/t$.\nIt is assumed that $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}U\\state{0}$ has a non-zero amplitude in $G$, otherwise, there cannot be a speedup.\nIf U indeed has this property, the above-defined unitary operation $Q$ will create a solution within $O(\\sqrt{1/t})$ iterations, i.e., a quadratic speedup can be achieved.\nThe amount of iterations to be realized by $Q$ is about $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\frac{\\pi}{4} \\frac{1}{P_G U \\state{0}}$,\nwhere $P_G$ is the projection onto the subspace spanned by $G$.\n\n&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;Examples of algorithms that use amplitude amplification are the algorithms of Grover and Simon, as well as the HHL algorithm [(Harrow, Hassidim and Lloyd 2009)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502).\nAmplitude amplification is also used in the state preparation algorithm of [(Sanders et al. 2019)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.020502).\nIn [(Brassard et al. 2002)](https://arxiv.org/abs/quant-ph/0005055), more algorithms making use of amplitude amplification are discussed.\n\n[Grover's Algorithm (QC-Atlas)](http://localhost/#/algorithms/0e5af2cf-f3c8-48dd-9743-cfdea65f320f)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)\n&quot;, &quot;Related Patterns&quot;: &quot;A [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee) $S_G^\\pi$ which is also a special case of a [Phase Shift](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/c6560c51-d2e3-4595-b9c3-b609c75c0b82) is used within the unitary operation $Q$.\nA unitary operation that implements amplitude amplifications can be provided as an [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e).\n\n&quot;}"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;Increase the probability of finding a solution&quot;, &quot;Result&quot;: &quot;The probability of measuring a solution is increased.&quot;, &quot;Context&quot;: &quot;For a specific indicator function $f$ the corresponding function table may list all possible solutions of a problem, i.e.  $f(x)=1 \\Leftrightarrow x$ is a solution to the problem.  \nWhen the corresponding state is measured, a solution can be found with a certain probability.\nSince measuring destroys the state, the computation has to be repeated if no solution is found by the measurement in order to be able to do another measurement of the state.\nTo keep computational costs low, a mechanism without measurements is required. &quot;, &quot;Solution&quot;: &quot;The overall state is transformed such that the probability of measuring certain values of interest increases with every iteration by modifying their amplitude [(Brassard et al. 2002)](https://arxiv.org/abs/quant-ph/0005055).\nThis is done via the help of a phase shift $S_G^\\pi$, which changes the sign of the phase of elements in the set of solutions $G$ while all other elements remain unchanged.\nAnother phase shift that is used is $S_0^\\pi$ which changes only the sign of the zero state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{0}$.\nSuppose there is an algorithm $U$ for computing approximate solutions (without any measurements).\nThe following unitary operation can be defined: \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}Q = -U S_0^\\pi U^{-1} S_G^\\pi$$\nIf the success probability of the algorithm $U$ is $t$, the average amount of iterations required to find a solution is $1/t$.\nIt is assumed that $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}U\\state{0}$ has a non-zero amplitude in $G$, otherwise, there cannot be a speedup.\nIf U indeed has this property, the above-defined unitary operation $Q$ will create a solution within $O(\\sqrt{1/t})$ iterations, i.e., a quadratic speedup can be achieved.\nThe amount of iterations to be realized by $Q$ is about $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\frac{\\pi}{4} \\frac{1}{P_G U \\state{0}}$,\nwhere $P_G$ is the projection onto the subspace spanned by $G$.\n\n&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;Examples of algorithms that use amplitude amplification are the algorithms of Grover and Simon, as well as the HHL algorithm [(Harrow, Hassidim and Lloyd 2009)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502).\nAmplitude amplification is also used in the state preparation algorithm of [(Sanders et al. 2019)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.020502).\nIn [(Brassard et al. 2002)](https://arxiv.org/abs/quant-ph/0005055), more algorithms making use of amplitude amplification are discussed.\n\n[Grover's Algorithm (QC-Atlas)](http://localhost/#/algorithms/0e5af2cf-f3c8-48dd-9743-cfdea65f320f)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)\n&quot;, &quot;Related Patterns&quot;: &quot;A [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee) $S_G^\\pi$ which is also a special case of a [Phase Shift](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/c6560c51-d2e3-4595-b9c3-b609c75c0b82) is used within the unitary operation $Q$.\nA unitary operation that implements amplitude amplifications can be provided as an [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e).\n\n&quot;}"/>
            <where>id='96b4d28a-a5ce-4c96-85df-d42587b13c57'</where>
        </update>
		<update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;Enter your input for this section here.&quot;, &quot;Intent&quot;: &quot;Compute a function table of a finite Boolean function&quot;, &quot;Result&quot;: &quot;For the general case of $m&gt;1$, the register is in a superposition of all data values in the first register and their corresponding data values in the second register. \nIn the special case of a one-dimensional decision function $f$, the register contains a superposition of all computational bases, where the sign indicates the outcome of the decision function: \nA minus sign indicates an outcome of 0 whereas a plus sign indicates an outcome of 1 - this is also referred to as \&quot;phase kickback\&quot;.&quot;, &quot;Context&quot;: &quot;A classical algorithm must evaluate a given function $f:\\{0, 1\\}^n \\rightarrow \\{0, 1\\}^m$ for each value of the domain for computing a function table. \nBy exploiting quantum parallelism, a quantum algorithm is able to compute all values of such a finite Boolean function in a single step. \nThis is useful to speed-up algorithms that reveal global properties of a respective function $f$. \nNote that for $m=1$, a Boolean function $f:\\{0, 1\\}^n \\rightarrow \\{0, 1\\}$ is often an indicator function which can be used to solve a decision problem.&quot;, &quot;Solution&quot;: &quot;For the computation of the function table, the quantum register is split into two parts: \nThe first part consists of $n$ qubits $x$ which represent the domain of the Boolean function $f$ in the computational basis.  \nThe second part of the register contains $m$ qubits $y$ which will be used to represent the values of $f$.\nThe unitary operator implementing the computation of the function table is then defined as:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}U_f \\left| x,y\\right&gt;=\\left| x, y\\oplus f(x) \\right&gt; $$\nAs described in [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14), the register is first brought in uniform superposition by initializing it as $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{0}^{\\otimes n} \\otimes \\left| 0 \\right&gt;^{\\otimes m}$, and applying the Hadamard transformation  $H^{\\otimes n}$ on the first part, leaving the second part of the register in the $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\left| 0 \\right&gt;^{\\otimes m}$ state.  \nThen, the operator $U_f$ is applied only once to the complete register generating the following function table:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{0}^{\\otimes n}  \\state{0}^{\\otimes m}  \\xrightarrow{H^{\\otimes n} \\otimes I} \\left(  \\frac{1}{\\sqrt{2^n}} \\sum_x \\state{x} \\right) \\otimes \\state{0}^{\\otimes m} $$\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\xrightarrow{U_f} \\frac{1}{\\sqrt{2^n}} \\sum_x \\state{x}\\state{f(x)} $$\nIf $f$ is an one-dimensional function (e.g., for solving a decision problem), the register is initialized as $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{0}^{\\otimes n} \\state{1}$.  \nAfterward, the Hadamard operation is performed on the complete register, i.e. the operator $H^{\\otimes n+1}$ is used.  \nApplication of $U_f$ results in the following state:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}  \\state{0}^{\\otimes n}  \\state{1}  \\xrightarrow{H^{\\otimes n} \\otimes H} \\left(  \\frac{1}{\\sqrt{2^n}} \\sum_x \\state{x} \\right) \\otimes \\state{-}$$\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\xrightarrow{U_f} \\left(  \\frac{1}{\\sqrt{2^n}} \\sum_{x=0}^{2^n-1} (-1)^{f(x)} \\state{x}  \\right) \\otimes \\state{-} $$&quot;, &quot;Variants&quot;: &quot;Enter your input for this section here.&quot;, &quot;Known Uses&quot;: &quot;Many algorithms, including the algorithms of Deutsch, Deutsch-Jozsa, Grover, and Shor make use of function tables.\n\n[Deutsch algorithm (PlanQK)](https://platform.planqk.de/algorithms/533c90a5-5fbb-487b-b64d-a8f331aafb10/)\n[Grover's Algorithm (QC-Atlas)](http://localhost/#/algorithms/0e5af2cf-f3c8-48dd-9743-cfdea65f320f)\n[Shor's Algorithm (QC-Atlas)](http://localhost/#/algorithms/b5df6c13-e619-496c-ada0-80fc3486f733)\n&quot;, &quot;Related Patterns&quot;: &quot;This pattern uses [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) and [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) to prepare the initial state of the quantum register. \nFunction tables can be further generalized as [Amplitude Amplification](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/96b4d28a-a5ce-4c96-85df-d42587b13c57). \nThe computation of the function table is done by an [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e). \nOften, [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc) is required to dissolve the created entanglement for subsequent steps of the algorithm.&quot;}"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;Enter your input for this section here.&quot;, &quot;Intent&quot;: &quot;Compute a function table of a finite Boolean function&quot;, &quot;Result&quot;: &quot;For the general case of $m&gt;1$, the register is in a superposition of all data values in the first register and their corresponding data values in the second register. \nIn the special case of a one-dimensional decision function $f$, the register contains a superposition of all computational bases, where the sign indicates the outcome of the decision function: \nA minus sign indicates an outcome of 0 whereas a plus sign indicates an outcome of 1 - this is also referred to as \&quot;phase kickback\&quot;.&quot;, &quot;Context&quot;: &quot;A classical algorithm must evaluate a given function $f:\\{0, 1\\}^n \\rightarrow \\{0, 1\\}^m$ for each value of the domain for computing a function table. \nBy exploiting quantum parallelism, a quantum algorithm is able to compute all values of such a finite Boolean function in a single step. \nThis is useful to speed-up algorithms that reveal global properties of a respective function $f$. \nNote that for $m=1$, a Boolean function $f:\\{0, 1\\}^n \\rightarrow \\{0, 1\\}$ is often an indicator function which can be used to solve a decision problem.&quot;, &quot;Solution&quot;: &quot;For the computation of the function table, the quantum register is split into two parts: \nThe first part consists of $n$ qubits $x$ which represent the domain of the Boolean function $f$ in the computational basis.  \nThe second part of the register contains $m$ qubits $y$ which will be used to represent the values of $f$.\nThe unitary operator implementing the computation of the function table is then defined as:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}U_f \\left| x,y\\right&gt;=\\left| x, y\\oplus f(x) \\right&gt; $$\nAs described in [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14), the register is first brought in uniform superposition by initializing it as $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{0}^{\\otimes n} \\otimes \\left| 0 \\right&gt;^{\\otimes m}$, and applying the Hadamard transformation  $H^{\\otimes n}$ on the first part, leaving the second part of the register in the $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\left| 0 \\right&gt;^{\\otimes m}$ state.  \nThen, the operator $U_f$ is applied only once to the complete register generating the following function table:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{0}^{\\otimes n}  \\state{0}^{\\otimes m}  \\xrightarrow{H^{\\otimes n} \\otimes I} \\left(  \\frac{1}{\\sqrt{2^n}} \\sum_x \\state{x} \\right) \\otimes \\state{0}^{\\otimes m} $$\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\xrightarrow{U_f} \\frac{1}{\\sqrt{2^n}} \\sum_x \\state{x}\\state{f(x)} $$\nIf $f$ is an one-dimensional function (e.g., for solving a decision problem), the register is initialized as $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{0}^{\\otimes n} \\state{1}$.  \nAfterward, the Hadamard operation is performed on the complete register, i.e. the operator $H^{\\otimes n+1}$ is used.  \nApplication of $U_f$ results in the following state:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}  \\state{0}^{\\otimes n}  \\state{1}  \\xrightarrow{H^{\\otimes n} \\otimes H} \\left(  \\frac{1}{\\sqrt{2^n}} \\sum_x \\state{x} \\right) \\otimes \\state{-}$$\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\xrightarrow{U_f} \\left(  \\frac{1}{\\sqrt{2^n}} \\sum_{x=0}^{2^n-1} (-1)^{f(x)} \\state{x}  \\right) \\otimes \\state{-} $$&quot;, &quot;Variants&quot;: &quot;Enter your input for this section here.&quot;, &quot;Known Uses&quot;: &quot;Many algorithms, including the algorithms of Deutsch, Deutsch-Jozsa, Grover, and Shor make use of function tables.\n\n[Deutsch algorithm (PlanQK)](https://platform.planqk.de/algorithms/533c90a5-5fbb-487b-b64d-a8f331aafb10/)\n[Grover's Algorithm (QC-Atlas)](http://localhost/#/algorithms/0e5af2cf-f3c8-48dd-9743-cfdea65f320f)\n[Shor's Algorithm (QC-Atlas)](http://localhost/#/algorithms/b5df6c13-e619-496c-ada0-80fc3486f733)\n&quot;, &quot;Related Patterns&quot;: &quot;This pattern uses [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) and [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) to prepare the initial state of the quantum register. \nFunction tables can be further generalized as [Amplitude Amplification](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/96b4d28a-a5ce-4c96-85df-d42587b13c57). \nThe computation of the function table is done by an [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e). \nOften, [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc) is required to dissolve the created entanglement for subsequent steps of the algorithm.&quot;}"/>
            <where>id='3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee'</where>
        </update>
		<update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;This pattern has also been referred to as Qubit Encoding [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420) since each qubit represents a single data point.\nThe resulting encoding of this pattern is not entangled, thus, another alias for this pattern is (Tensor) Product Encoding [(Leymann and Barzen 2020)](https://iopscience.iop.org/article/10.1088/2058-9565/abae7d). \n\n&quot;, &quot;Intent&quot;: &quot;\&quot;Represent each data point by a separate qubit\&quot; [(Weigold et al. 2021)](https://ieeexplore.ieee.org/document/9425837/)\n\n&quot;, &quot;Result&quot;: &quot;This creates the following separable state ([Weigold et al. 2021](https://ieeexplore.ieee.org/document/9425837/)): \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\n  \\state{\\psi} = \\bigColVec{\\cos{x_0} \\\\ \\sin{x_0}} \n  \\otimes \\bigColVec{\\cos{x_1} \\\\ \\sin{x_1}} \n  \\otimes \\ldots \n  \\otimes \\bigColVec{\\cos{x_n} \\\\ \\sin{x_n}}\n$$  \n\n\nIt can easily be seen that one qubit is needed per data point which is not optimal. To load the data, the rotations on the qubits can be performed in parallel, thus, the depth of the circuit is optimal. \n\n&quot;, &quot;Context&quot;: &quot;In the current NISQ era, an algorithm requires an encoding schema that is efficient in terms of operations. \nThis enables to perform more operations within the decoherence time after encoding the data. \n\n&quot;, &quot;Solution&quot;: &quot;As a first step, each data point of the input is normalized to the interval $[0,\\frac{\\pi}{2}]$.\nTo encode the data points, a rotation around the y-axis is used (see solution sketch) for which the angle depends on the value of the normalized data point. \n\n![sketch](https://quantumcomputingpatterns.org/assets/sketches/angle_encoding_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [âExpanding Data Encoding Patterns For Quantum Algorithms.â](https://ieeexplore.ieee.org/document/9425837/) In: 2021 IEEE 18th International Conference on Software Architecture Companion (ICSA-C), IEEE, 2021.\n&quot;, &quot;Variants&quot;: &quot;A variant of this pattern is presented in [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420) where the relative phase, another property of qubits, is exploited to produce a more dense encoding which requires only half of the qubits to encode the same amount of data points. \n\n&quot;, &quot;Known Uses&quot;: &quot;A classification algorithm based on the encoding of this pattern can be found in [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420) and [(Grant et al. 2018)](https://www.nature.com/articles/s41534-018-0116-9). \nAdditionally, this encoding has been applied in quantum image processing: \nHere, angle encoding is used to represent a pixel's color information in the flexible representation of quantum image (FRQI) while the position is represented by an additional register [(Yan, Iliyasu and Venegas-Andraca 2015)](https://link.springer.com/content/pdf/10.1007/s11128-015-1195-6.pdf).\nFor quantum neural networks, a so-called quantum neuron (quron) makes use of this encoding [(Schuld, Sinayskiy and Petruccione 2014)](https://link.springer.com/article/10.1007/s11128-014-0809-8).\nA state preparation routine to create this encoding is provided by  [PennyLane](https://pennylane.readthedocs.io/en/stable/introduction/templates.html) where a rotation on the axis x, y, or z can be chosen. \nSince the state preparation is straightforward (see solution sketch), this encoding can easily be implemented using default qubit rotations [(Leymann and Barzen 2020)](https://iopscience.iop.org/article/10.1088/2058-9565/abae7d).\n\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n&quot;, &quot;Related Patterns&quot;: &quot;As this pattern provides a concrete encoding strategy, it specifies [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d).\n\n&quot;}"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;This pattern has also been referred to as Qubit Encoding [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420) since each qubit represents a single data point.\nThe resulting encoding of this pattern is not entangled, thus, another alias for this pattern is (Tensor) Product Encoding [(Leymann and Barzen 2020)](https://iopscience.iop.org/article/10.1088/2058-9565/abae7d). \n\n&quot;, &quot;Intent&quot;: &quot;\&quot;Represent each data point by a separate qubit\&quot; [(Weigold et al. 2021)](https://ieeexplore.ieee.org/document/9425837/)\n\n&quot;, &quot;Result&quot;: &quot;This creates the following separable state ([Weigold et al. 2021](https://ieeexplore.ieee.org/document/9425837/)): \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\n  \\state{\\psi} = \\bigColVec{\\cos{x_0} \\\\ \\sin{x_0}} \n  \\otimes \\bigColVec{\\cos{x_1} \\\\ \\sin{x_1}} \n  \\otimes \\ldots \n  \\otimes \\bigColVec{\\cos{x_n} \\\\ \\sin{x_n}}\n$$  \n\n\nIt can easily be seen that one qubit is needed per data point which is not optimal. To load the data, the rotations on the qubits can be performed in parallel, thus, the depth of the circuit is optimal. \n\n&quot;, &quot;Context&quot;: &quot;In the current NISQ era, an algorithm requires an encoding schema that is efficient in terms of operations. \nThis enables to perform more operations within the decoherence time after encoding the data. \n\n&quot;, &quot;Solution&quot;: &quot;As a first step, each data point of the input is normalized to the interval $[0,\\frac{\\pi}{2}]$.\nTo encode the data points, a rotation around the y-axis is used (see solution sketch) for which the angle depends on the value of the normalized data point. \n\n![sketch](https://quantumcomputingpatterns.org/assets/sketches/angle_encoding_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [âExpanding Data Encoding Patterns For Quantum Algorithms.â](https://ieeexplore.ieee.org/document/9425837/) In: 2021 IEEE 18th International Conference on Software Architecture Companion (ICSA-C), IEEE, 2021.\n&quot;, &quot;Variants&quot;: &quot;A variant of this pattern is presented in [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420) where the relative phase, another property of qubits, is exploited to produce a more dense encoding which requires only half of the qubits to encode the same amount of data points. \n\n&quot;, &quot;Known Uses&quot;: &quot;A classification algorithm based on the encoding of this pattern can be found in [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420) and [(Grant et al. 2018)](https://www.nature.com/articles/s41534-018-0116-9). \nAdditionally, this encoding has been applied in quantum image processing: \nHere, angle encoding is used to represent a pixel's color information in the flexible representation of quantum image (FRQI) while the position is represented by an additional register [(Yan, Iliyasu and Venegas-Andraca 2015)](https://link.springer.com/content/pdf/10.1007/s11128-015-1195-6.pdf).\nFor quantum neural networks, a so-called quantum neuron (quron) makes use of this encoding [(Schuld, Sinayskiy and Petruccione 2014)](https://link.springer.com/article/10.1007/s11128-014-0809-8).\nA state preparation routine to create this encoding is provided by  [PennyLane](https://pennylane.readthedocs.io/en/stable/introduction/templates.html) where a rotation on the axis x, y, or z can be chosen. \nSince the state preparation is straightforward (see solution sketch), this encoding can easily be implemented using default qubit rotations [(Leymann and Barzen 2020)](https://iopscience.iop.org/article/10.1088/2058-9565/abae7d).\n\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n&quot;, &quot;Related Patterns&quot;: &quot;As this pattern provides a concrete encoding strategy, it specifies [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d).\n\n&quot;}"/>
            <where>id='e595558d-bfea-4b82-9f47-a38a2097b245'</where>
        </update>
		<update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;Achieve a computational speedup on computation when verification of a solution is simple.&quot;, &quot;Result&quot;: &quot;This pattern requires that an oracle is given which can verify the solutions.\n\n&quot;, &quot;Context&quot;: &quot;There are many problems for which finding a solution is hard, but for an alleged solution it is easy to verify whether it is correct. \nFor example, determining the factorization of a certain number is hard when the number is huge, but multiplying prime numbers to verify that their product equals the number is simple.\nThus, to check if a list of prime numbers is the factorization of a specific number, multiplying the prime numbers is sufficient to verify the factorization. \n\n&quot;, &quot;Solution&quot;: &quot;For certain problems, finding a solution can be done faster by exploiting quantum parallelism:\nFirst, all possible solutions are created, then this list of solutions is searched for correct solutions by verifying the correctness of each solution. \nThe Grover algorithm is used for searching through the possible solutions relying on an oracle to verify whether the possible solutions are correct.\nThis means that $O(\\sqrt{N})$ applications of the oracle are needed to determine the solution. \n\n&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;This technique can be applied for e.g., cracking keys, finding Hamiltonian cycles,  solving 3-SAT, or the traveling salesman problem.\n\n[Grover's Algorithm (QC-Atlas)](http://localhost/#/algorithms/0e5af2cf-f3c8-48dd-9743-cfdea65f320f)\n[DÃ¼rr-HÃ¸yer Quantum Minimization Algorithm (PlanQK)](https://platform.planqk.de/algorithms/061f4eb3-d9ee-4f47-befc-9e242bf801ce/)\n&quot;, &quot;Related Patterns&quot;: &quot;An [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e) is used to verify solutions.\nThe Grover algorithm used for the scanning increases the probability to measure a correct solution via [Amplitude Amplification](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/96b4d28a-a5ce-4c96-85df-d42587b13c57). \n\n&quot;}"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;Achieve a computational speedup on computation when verification of a solution is simple.&quot;, &quot;Result&quot;: &quot;This pattern requires that an oracle is given which can verify the solutions.\n\n&quot;, &quot;Context&quot;: &quot;There are many problems for which finding a solution is hard, but for an alleged solution it is easy to verify whether it is correct. \nFor example, determining the factorization of a certain number is hard when the number is huge, but multiplying prime numbers to verify that their product equals the number is simple.\nThus, to check if a list of prime numbers is the factorization of a specific number, multiplying the prime numbers is sufficient to verify the factorization. \n\n&quot;, &quot;Solution&quot;: &quot;For certain problems, finding a solution can be done faster by exploiting quantum parallelism:\nFirst, all possible solutions are created, then this list of solutions is searched for correct solutions by verifying the correctness of each solution. \nThe Grover algorithm is used for searching through the possible solutions relying on an oracle to verify whether the possible solutions are correct.\nThis means that $O(\\sqrt{N})$ applications of the oracle are needed to determine the solution. \n\n&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;This technique can be applied for e.g., cracking keys, finding Hamiltonian cycles,  solving 3-SAT, or the traveling salesman problem.\n\n[Grover's Algorithm (QC-Atlas)](http://localhost/#/algorithms/0e5af2cf-f3c8-48dd-9743-cfdea65f320f)\n[DÃ¼rr-HÃ¸yer Quantum Minimization Algorithm (PlanQK)](https://platform.planqk.de/algorithms/061f4eb3-d9ee-4f47-befc-9e242bf801ce/)\n&quot;, &quot;Related Patterns&quot;: &quot;An [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e) is used to verify solutions.\nThe Grover algorithm used for the scanning increases the probability to measure a correct solution via [Amplitude Amplification](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/96b4d28a-a5ce-4c96-85df-d42587b13c57). \n\n&quot;}"/>
            <where>id='ddd64fb6-b324-45eb-8e21-8193dc311841'</where>
        </update>
		<update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;Distinguish the important aspects of a state in an efficient manner\n\n&quot;, &quot;Result&quot;: &quot;A phase shift of some states in $G$ cannot be detected by measurement, since the amplitudes of the states do not change.  \nBut the phase-shifted states can be used for further computations to increase the probability to measure a \&quot;good\&quot; solution. Since only the phase and not the measurable amplitude of the states is changed, this operation has no classical equivalent.\n\n&quot;, &quot;Context&quot;: &quot;In an iterative algorithm wherein each iteration the solution shall be improved, the parts of the computational basis improving the solution should be indicated. One possible indication is a phase shift.\n\n&quot;, &quot;Solution&quot;: &quot;According to [(Rieffel and Polak 2014)](https://mitpress.mit.edu/books/quantum-computing) the subsequent operator $S_G^\\phi$ can be implemented efficiently regarding the number of applied gates:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\sum_{x=0}^{N-1} \\alpha_x \\state{x}  \\xrightarrow{S_G^\\phi}  \\sum_{x\\in G}e^{i\\phi} \\alpha_x \\state{x} + \\sum_{x\\notin G} \\alpha_x \\state{x}$$\nThis operator marks the qubits which are improving the solution (and, thus, are in the ``good'' subset $G \\subseteq \\{0, ..., N - 1\\})$ by a phase shift with a phase $\\phi$, while leaving the remaining qubits untouched. &quot;, &quot;Variants&quot;: &quot;Another variant of this solution is to modify the operator such that it applies a phase shift on the qubits in $G$ with a different phase, i.e. $\\phi = \\phi (x)$.\n\n&quot;, &quot;Known Uses&quot;: &quot;For example, in the prominent algorithms of Grover and Deutsch-Jozsa, a phase shift is used.\n\n[Grover's Algorithm (QC-Atlas)](http://localhost/#/algorithms/0e5af2cf-f3c8-48dd-9743-cfdea65f320f)\n[DÃ¼rr-HÃ¸yer Quantum Minimization Algorithm (PlanQK)](https://platform.planqk.de/algorithms/061f4eb3-d9ee-4f47-befc-9e242bf801ce/)\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)&quot;, &quot;Related Patterns&quot;: &quot;For a specific indicator function $f$ specifying a set of \&quot;good\&quot; states in $G$, a [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee) based on this indicator function is a phase shift. \nTo perform an [Amplitude Amplification](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/96b4d28a-a5ce-4c96-85df-d42587b13c57), two phase shifts are needed.\nA phase shift can be used as an [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e).\n\n&quot;}"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;Distinguish the important aspects of a state in an efficient manner\n\n&quot;, &quot;Result&quot;: &quot;A phase shift of some states in $G$ cannot be detected by measurement, since the amplitudes of the states do not change.  \nBut the phase-shifted states can be used for further computations to increase the probability to measure a \&quot;good\&quot; solution. Since only the phase and not the measurable amplitude of the states is changed, this operation has no classical equivalent.\n\n&quot;, &quot;Context&quot;: &quot;In an iterative algorithm wherein each iteration the solution shall be improved, the parts of the computational basis improving the solution should be indicated. One possible indication is a phase shift.\n\n&quot;, &quot;Solution&quot;: &quot;According to [(Rieffel and Polak 2014)](https://mitpress.mit.edu/books/quantum-computing) the subsequent operator $S_G^\\phi$ can be implemented efficiently regarding the number of applied gates:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\sum_{x=0}^{N-1} \\alpha_x \\state{x}  \\xrightarrow{S_G^\\phi}  \\sum_{x\\in G}e^{i\\phi} \\alpha_x \\state{x} + \\sum_{x\\notin G} \\alpha_x \\state{x}$$\nThis operator marks the qubits which are improving the solution (and, thus, are in the ``good'' subset $G \\subseteq \\{0, ..., N - 1\\})$ by a phase shift with a phase $\\phi$, while leaving the remaining qubits untouched. &quot;, &quot;Variants&quot;: &quot;Another variant of this solution is to modify the operator such that it applies a phase shift on the qubits in $G$ with a different phase, i.e. $\\phi = \\phi (x)$.\n\n&quot;, &quot;Known Uses&quot;: &quot;For example, in the prominent algorithms of Grover and Deutsch-Jozsa, a phase shift is used.\n\n[Grover's Algorithm (QC-Atlas)](http://localhost/#/algorithms/0e5af2cf-f3c8-48dd-9743-cfdea65f320f)\n[DÃ¼rr-HÃ¸yer Quantum Minimization Algorithm (PlanQK)](https://platform.planqk.de/algorithms/061f4eb3-d9ee-4f47-befc-9e242bf801ce/)\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)&quot;, &quot;Related Patterns&quot;: &quot;For a specific indicator function $f$ specifying a set of \&quot;good\&quot; states in $G$, a [Function Table](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee) based on this indicator function is a phase shift. \nTo perform an [Amplitude Amplification](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/96b4d28a-a5ce-4c96-85df-d42587b13c57), two phase shifts are needed.\nA phase shift can be used as an [Oracle](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/1cc7e9d6-ab37-412e-8afa-604a25de296e).\n\n&quot;}"/>
            <where>id='c6560c51-d2e3-4595-b9c3-b609c75c0b82'</where>
        </update>
		<update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;\&quot;Approximate the solution of an optimization problem\&quot; [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)\n&quot;, &quot;Result&quot;: &quot;This approach is applicable for NISQ devices and can be adjusted for a particular problem domain. \nSince NISQ devices are limited by their hardware, only small values for $p$ can be chosen as this hyperparameter determines the width of the circuit.\nNevertheless, choosing suitable mixing and phase-separating operators is not trivial for a problem at hand and, currently, an open research question. The convergence of the solution depends on the chosen operators (based on which the ansatz is constructed), the objective function, and the optimization strategy for updating the parameters. \n\n&quot;, &quot;Context&quot;: &quot;To solve a combinatorial optimization problem, a bit string $z=z_1\\ldots z_n$ must be found that fulfills a maximum number of $m$ clauses by assigning every binary variable $z_i$ to either 0 or 1. \nEach of the $m$ clauses involves a subset of these variables. \nThe domain, e.g., all feasible solutions, is either every possible bit string $z$ of length $n$ or a subset of the bit strings. \nFor a bit string $z$, the value of the objective function $C(z)$ equals the number of clauses that it fulfills: \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\n    C(z)=\\sum_{j=1}^m C_{j}(z) \\text{ where }  \n    C_{\\alpha}(z) = \n    \\begin{cases}\n    1,&amp; \\text{if }C_{\\alpha}\\text{ is fulfilled by z}\\\\\n    0,              &amp; \\text{otherwise}\n\\end{cases}\n\n\n$$\n\n\nFor larger problem instances, a brute force approach (which evaluates the objective function of every solution to find the best solution) is computationally too expensive. \nTherefore, a heuristic approach that approximates the best solution is also acceptable. \n\n&quot;, &quot;Solution&quot;: &quot;An [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7) approach is used to solve the problem: \nAs a first step, the quantum register is initialized with $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{s}$ (see solution sketch) which is either a single solution or a superposition of multiple solutions. \nPreparing the state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{s}$ is assumed to be efficient, i.e., in constant or at most logarithmic depth. \nNote that this assumption does not hold for all quantum states. \nAfter the [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d), an ansatz is applied. \nTo construct the circuit of the ansatz, a *phase-separating operator* $U(C,\\gamma)$ as well as a *mixing operator* $U(B,\\beta)$ are used where $\\gamma$ and $\\beta$ are the parameter sets.\nThe phase-separating operator applies a [Phase Shift](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/c6560c51-d2e3-4595-b9c3-b609c75c0b82) where the phase of a computational basis state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{y}$ is changed according to its value of the objective function $C(y)$:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\n     U(C,\\gamma) \\state{y} = f(y)\\state{y}\n$$  \n\n\nE.g., an operator $U(C,\\gamma)$ can be defined that applies a shift for every clause fulfilled by a solution $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{y}$.  \n\n\nThe second operator is the mixing operator which alters the amplitude of the solutions. \nThereby, it provides transitions between solutions and especially allows to transition between an arbitrary pair of solutions within the problem domain for some well-chosen parameter $\\beta^*$. \nAs a result, this operator \nreflects the domain's structure. \n\n\nEach iteration on the quantum computer starts with an [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) of the state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{s}$ and, then, applies an ansatz circuit which is based on $C(\\gamma)$ and $B(\\beta)$. \nThe ansatz circuit consists of $p$ alternating unitaries which are drawn from the operators and lead to the following state: \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\n\\state{\\gamma, \\beta} = U(B,\\beta_p)U(C,\\gamma_p) \\ldots U(B,\\beta_1)U(C,\\gamma_1) \\state{s}\n$$  \n\n\nIn the first iteration, the parameter sets $\\gamma, \\beta$ are chosen randomly and $p\\in \\mathbb{N}$ defines a hyperparameter.  \nMeasuring this state gives $z$ as a single solution which can be evaluated by the objective function $C$. \nSampling this state allows to determine the expectation values for $\\gamma$ and $\\beta$ which is by definition smaller or equal to the maximum of the objective function:  \n\n\n$$\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\n    \\left&lt; C\\right&gt;_{\\state{\\gamma, \\beta}} =\n    \\left&lt; \\gamma, \\beta |C |\\gamma, \\beta \\right&gt;\n    = \\bigg \\langle \\sum x_z \\state{z} \\bigg  |  \\sum x_z f(z)\\state{z} \\bigg \\rangle \\\\\n    = \\sum |x_z|^2 f(z) \\leq \\sum |x_z|^2 f(z') = f(z') = C_{max}\n$$\n\n\nBased on the expectation values, the parameters $\\gamma$ and $\\beta$ can be optimized until the termination condition is satisfied. \n&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;In the original publication [Hadfield et al. 2019](https://www.mdpi.com/1999-4893/12/2/34), various applications of this approach are discussed for different optimization problems. \nUse-cases of this pattern can be found in [Wang et al. 2020](https://link.aps.org/doi/10.1103/PhysRevA.101.012320) and [Fingerhuth, Babej and Ing 2018](https://arxiv.org/abs/1810.13411).\n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern is a refinement of [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7); the varied parameters for the ansatz are $\\beta$ and $\\gamma$. \nNote that [Phase Shift](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/c6560c51-d2e3-4595-b9c3-b609c75c0b82) [Leymann 2019](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf) is used within the ansatz to mark solutions based on their value of the objective function. \nTo encode solutions, [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750) [Weigold et al. 2020](https://hillside.net/plop/2020/papers/weigold.pdf) is used. \nThis pattern can be combined with [Warm Start](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3ea9e187-e91b-4852-84eb-b35b5c480892).  \n\n&quot;}"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;\&quot;Approximate the solution of an optimization problem\&quot; [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)\n&quot;, &quot;Result&quot;: &quot;This approach is applicable for NISQ devices and can be adjusted for a particular problem domain. \nSince NISQ devices are limited by their hardware, only small values for $p$ can be chosen as this hyperparameter determines the width of the circuit.\nNevertheless, choosing suitable mixing and phase-separating operators is not trivial for a problem at hand and, currently, an open research question. The convergence of the solution depends on the chosen operators (based on which the ansatz is constructed), the objective function, and the optimization strategy for updating the parameters. \n\n&quot;, &quot;Context&quot;: &quot;To solve a combinatorial optimization problem, a bit string $z=z_1\\ldots z_n$ must be found that fulfills a maximum number of $m$ clauses by assigning every binary variable $z_i$ to either 0 or 1. \nEach of the $m$ clauses involves a subset of these variables. \nThe domain, e.g., all feasible solutions, is either every possible bit string $z$ of length $n$ or a subset of the bit strings. \nFor a bit string $z$, the value of the objective function $C(z)$ equals the number of clauses that it fulfills: \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\n    C(z)=\\sum_{j=1}^m C_{j}(z) \\text{ where }  \n    C_{\\alpha}(z) = \n    \\begin{cases}\n    1,&amp; \\text{if }C_{\\alpha}\\text{ is fulfilled by z}\\\\\n    0,              &amp; \\text{otherwise}\n\\end{cases}\n\n\n$$\n\n\nFor larger problem instances, a brute force approach (which evaluates the objective function of every solution to find the best solution) is computationally too expensive. \nTherefore, a heuristic approach that approximates the best solution is also acceptable. \n\n&quot;, &quot;Solution&quot;: &quot;An [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7) approach is used to solve the problem: \nAs a first step, the quantum register is initialized with $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{s}$ (see solution sketch) which is either a single solution or a superposition of multiple solutions. \nPreparing the state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{s}$ is assumed to be efficient, i.e., in constant or at most logarithmic depth. \nNote that this assumption does not hold for all quantum states. \nAfter the [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d), an ansatz is applied. \nTo construct the circuit of the ansatz, a *phase-separating operator* $U(C,\\gamma)$ as well as a *mixing operator* $U(B,\\beta)$ are used where $\\gamma$ and $\\beta$ are the parameter sets.\nThe phase-separating operator applies a [Phase Shift](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/c6560c51-d2e3-4595-b9c3-b609c75c0b82) where the phase of a computational basis state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{y}$ is changed according to its value of the objective function $C(y)$:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\n     U(C,\\gamma) \\state{y} = f(y)\\state{y}\n$$  \n\n\nE.g., an operator $U(C,\\gamma)$ can be defined that applies a shift for every clause fulfilled by a solution $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{y}$.  \n\n\nThe second operator is the mixing operator which alters the amplitude of the solutions. \nThereby, it provides transitions between solutions and especially allows to transition between an arbitrary pair of solutions within the problem domain for some well-chosen parameter $\\beta^*$. \nAs a result, this operator \nreflects the domain's structure. \n\n\nEach iteration on the quantum computer starts with an [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) of the state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{s}$ and, then, applies an ansatz circuit which is based on $C(\\gamma)$ and $B(\\beta)$. \nThe ansatz circuit consists of $p$ alternating unitaries which are drawn from the operators and lead to the following state: \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\n\\state{\\gamma, \\beta} = U(B,\\beta_p)U(C,\\gamma_p) \\ldots U(B,\\beta_1)U(C,\\gamma_1) \\state{s}\n$$  \n\n\nIn the first iteration, the parameter sets $\\gamma, \\beta$ are chosen randomly and $p\\in \\mathbb{N}$ defines a hyperparameter.  \nMeasuring this state gives $z$ as a single solution which can be evaluated by the objective function $C$. \nSampling this state allows to determine the expectation values for $\\gamma$ and $\\beta$ which is by definition smaller or equal to the maximum of the objective function:  \n\n\n$$\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\n    \\left&lt; C\\right&gt;_{\\state{\\gamma, \\beta}} =\n    \\left&lt; \\gamma, \\beta |C |\\gamma, \\beta \\right&gt;\n    = \\bigg \\langle \\sum x_z \\state{z} \\bigg  |  \\sum x_z f(z)\\state{z} \\bigg \\rangle \\\\\n    = \\sum |x_z|^2 f(z) \\leq \\sum |x_z|^2 f(z') = f(z') = C_{max}\n$$\n\n\nBased on the expectation values, the parameters $\\gamma$ and $\\beta$ can be optimized until the termination condition is satisfied. \n&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;In the original publication [Hadfield et al. 2019](https://www.mdpi.com/1999-4893/12/2/34), various applications of this approach are discussed for different optimization problems. \nUse-cases of this pattern can be found in [Wang et al. 2020](https://link.aps.org/doi/10.1103/PhysRevA.101.012320) and [Fingerhuth, Babej and Ing 2018](https://arxiv.org/abs/1810.13411).\n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern is a refinement of [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7); the varied parameters for the ansatz are $\\beta$ and $\\gamma$. \nNote that [Phase Shift](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/c6560c51-d2e3-4595-b9c3-b609c75c0b82) [Leymann 2019](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf) is used within the ansatz to mark solutions based on their value of the objective function. \nTo encode solutions, [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750) [Weigold et al. 2020](https://hillside.net/plop/2020/papers/weigold.pdf) is used. \nThis pattern can be combined with [Warm Start](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3ea9e187-e91b-4852-84eb-b35b5c480892).  \n\n&quot;}"/>
            <where>id='b657ea73-63c0-4800-a69d-a91925e19ac6'</where>
        </update>
		<update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;An alias for this pattern is Quantum Variational Eigensolver (QVE) [(Mitarai et al. 2018)](https://arxiv.org/abs/1803.00745v3).\n&quot;, &quot;Intent&quot;: &quot;\&quot;Approximate the lowest eigenvalue of a matrix\&quot; [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)&quot;, &quot;Result&quot;: &quot;Since a [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7) approach is used, the convergence of the overall algorithm depends on the objective function, the ansatz, and the chosen optimization strategy. \nBased on the outcome of this algorithm (an approximation of the lowest eigenvalue), a follow-up algorithm for finding other eigenvalues of $H$ can be applied (see known uses).\nIf all eigenvalues are known, a principal component analysis can be done to perform a dimension reduction. \n\n&quot;, &quot;Context&quot;: &quot;A hermitian matrix $H$ is given, for which the lowest eigenvalue has to be determined.\nSince the current NISQ devices cannot provide the resources needed to make use of the quantum phase estimation algorithm, an alternative approach must be used. \n\n&quot;, &quot;Solution&quot;: &quot;As a first step, $H$ is re-written as a weighted sum of Pauli strings: \n\n\n$$\n    H=\\sum_{\\alpha} h_\\alpha P_\\alpha\n$$  \n\n\nUsing the iterative structure of the  [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7), a suitable ansatz is chosen for the preparation of trial states. \nPopular choices include the unitary coupled cluster ansatz [(Taube and Bartlett 2006)](https://onlinelibrary.wiley.com/doi/10.1002/qua.21198) or an ansatz inspired by hardware [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265). \nThe objective function is then defined as follows:\n\n\n$$C(\\theta) = \\left&lt;\\psi(\\theta)|H|\\psi(\\theta) \\right&gt; = \\sum_{\\alpha} h_\\alpha \\left&lt; \\psi(\\theta)|P_\\alpha|\\psi(\\theta) \\right&gt;$$\n\n\ni.e., the solution is evaluated by the sum of the expectation values of the Pauli string. \nThe variational principle guarantees that the sum of expectation values is greater than or equal to the smallest eigenvalue which must be approximated. \nIf the termination condition has not been fulfilled by $C(\\theta)$, the parameters are further optimized and updated as described in the [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7). \n\n&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;[Higgott, Wang and Brierley 2019](https://quantum-journal.org/papers/q-2019-07-01-156/) extends the initial description of this algorithm [Peruzzo et al. 2014](https://www.nature.com/articles/ncomms5213) by an approach for finding other eigenvalues of $H$. \nThis pattern is especially important for applications in which the ground state of a quantum chemical system has to be determined and has been experimentally applied for various quantum chemistry systems [Cao et al. 2019](https://pubs.acs.org/doi/10.1021/acs.chemrev.8b00803). \n\n[Variational Quantum Eigensolver (QC-Atlas)](http://localhost/#/algorithms/379ec44e-1ce5-11eb-adf2-0242ac160002)&quot;, &quot;Related Patterns&quot;: &quot;This patterns uses the structure described in the [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7). \n\n&quot;}"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;An alias for this pattern is Quantum Variational Eigensolver (QVE) [(Mitarai et al. 2018)](https://arxiv.org/abs/1803.00745v3).\n&quot;, &quot;Intent&quot;: &quot;\&quot;Approximate the lowest eigenvalue of a matrix\&quot; [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)&quot;, &quot;Result&quot;: &quot;Since a [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7) approach is used, the convergence of the overall algorithm depends on the objective function, the ansatz, and the chosen optimization strategy. \nBased on the outcome of this algorithm (an approximation of the lowest eigenvalue), a follow-up algorithm for finding other eigenvalues of $H$ can be applied (see known uses).\nIf all eigenvalues are known, a principal component analysis can be done to perform a dimension reduction. \n\n&quot;, &quot;Context&quot;: &quot;A hermitian matrix $H$ is given, for which the lowest eigenvalue has to be determined.\nSince the current NISQ devices cannot provide the resources needed to make use of the quantum phase estimation algorithm, an alternative approach must be used. \n\n&quot;, &quot;Solution&quot;: &quot;As a first step, $H$ is re-written as a weighted sum of Pauli strings: \n\n\n$$\n    H=\\sum_{\\alpha} h_\\alpha P_\\alpha\n$$  \n\n\nUsing the iterative structure of the  [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7), a suitable ansatz is chosen for the preparation of trial states. \nPopular choices include the unitary coupled cluster ansatz [(Taube and Bartlett 2006)](https://onlinelibrary.wiley.com/doi/10.1002/qua.21198) or an ansatz inspired by hardware [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265). \nThe objective function is then defined as follows:\n\n\n$$C(\\theta) = \\left&lt;\\psi(\\theta)|H|\\psi(\\theta) \\right&gt; = \\sum_{\\alpha} h_\\alpha \\left&lt; \\psi(\\theta)|P_\\alpha|\\psi(\\theta) \\right&gt;$$\n\n\ni.e., the solution is evaluated by the sum of the expectation values of the Pauli string. \nThe variational principle guarantees that the sum of expectation values is greater than or equal to the smallest eigenvalue which must be approximated. \nIf the termination condition has not been fulfilled by $C(\\theta)$, the parameters are further optimized and updated as described in the [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7). \n\n&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;[Higgott, Wang and Brierley 2019](https://quantum-journal.org/papers/q-2019-07-01-156/) extends the initial description of this algorithm [Peruzzo et al. 2014](https://www.nature.com/articles/ncomms5213) by an approach for finding other eigenvalues of $H$. \nThis pattern is especially important for applications in which the ground state of a quantum chemical system has to be determined and has been experimentally applied for various quantum chemistry systems [Cao et al. 2019](https://pubs.acs.org/doi/10.1021/acs.chemrev.8b00803). \n\n[Variational Quantum Eigensolver (QC-Atlas)](http://localhost/#/algorithms/379ec44e-1ce5-11eb-adf2-0242ac160002)&quot;, &quot;Related Patterns&quot;: &quot;This patterns uses the structure described in the [Variational Quantum Algorithm (VQA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bc795a9b-7977-4e01-b513-f9f5aba38aa7). \n\n&quot;}"/>
            <where>id='27a5d147-a323-4c6a-84ef-45d80cae923d'</where>
        </update>
		<update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;Enter your input for this section here.&quot;, &quot;Intent&quot;: &quot; \&quot;Use a quantum random access memory to access a superposition of data values at once\&quot; [(Weigold et al. 2021)](https://ieeexplore.ieee.org/document/9425837/)\n\n&quot;, &quot;Result&quot;: &quot;To apply this encoding, $l$ qubits are needed to represent the data values in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750). \nFor the address register, additionally $\\lceil log(n) \\rceil$ qubits are needed containing up to $n$ addresses. \nSince \\textsc{Basis Encoding} is used to represent the data values, the computational properties are similar to other digital encodings (e.g., [Quantum Associative Memory (QuAM)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/482714a7-8409-4165-93fe-72b02c2ae99c) and [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750)): \nSince a set of data values is represented in superposition, the data values can be manipulated at once (using quantum parallelism). \nFurthermore, multiple arithmetic operations (e.g., addition or multiplication) for [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750) are known that can also be applied to values in superposition.\n \n\nNote that algorithms that specify the usage of a QRAM share the following assumption: \nState preparation via the QRAM is efficient and, therefore, of logarithmic runtime [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232). \nHowever, to our best knowledge, there are currently no commercial hardware implementations for QRAM.\nThus, a different state preparation routine has to load the data in the specified encoding. \nA major disadvantage today is that currently no state preparation routine for an arbitrary state is known to be as efficient as the logarithmic runtime of a QRAM. \nAs a result, a theoretically exponential speed-up of an algorithm using QRAM is only possible if the state preparation can be realized by an efficient state preparation method. \n\n&quot;, &quot;Context&quot;: &quot;For accessing the values of input data, a random access memory is needed.\n\n&quot;, &quot;Solution&quot;: &quot;When a classical random access memory (RAM) gets an address to a memory index, it transfers the data value stored at this address into a specified output register. \nThe functionality of quantum random access memory (QRAM) is similar, however, the registers are not classical but quantum registers [(Johnston, Harrigan and Gimeno-Segovia 2019)](https://www.oreilly.com/library/view/programming-quantum-computers/9781492039679/). \nConsequently, the address and output registers can be in  superposition instead of only single values.\nThe solution sketch demonstrates the loading process of a QRAM [(Giovannetti, Lloyd and Maccone 2008)](https://arxiv.org/abs/0708.1879) holding a superposition of the first two addresses ($\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\frac{1}{\\sqrt{2}}\\state{00} + \\frac{1}{\\sqrt{2}}\\state{01})$ as input register. \nLoading the data values of the corresponding addresses results in the following state:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{\\psi} = \\frac{1}{\\sqrt{2}} \\state{00}\\state{010} + \\frac{1}{\\sqrt{2}}\\state{01}\\state{110}\n$$  \n\n\nLoading $m$ of $n$ data values using a QRAM can be generalized as follows [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232): \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\n  \\frac{1}{\\sqrt{m}}\\sum_{i=0}^{m-1}\n    \\state{a}_i\\state{0} \\ \\underrightarrow{QRAM}  \\frac{1}{\\sqrt{m}}\\sum_{i=0}^{m-1}\n \\state{a}_i\\state{x_a}\n $$  \n\n\nThereby,  the  first register specifies the  address  register  containing a  superposition  of $m$ addresses, and the second register is specified as output register.\nFurthermore, $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{a}_i$ denotes the $i$-th data value address which has to be loaded \nand $x_a$ is the data value stored at this address.\nThe task of the QRAM is to load each data value $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{x_a}$ of the addresses in the first register to the output register. \nConsequently, $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{a}_i\\state{x_a}$ is part of the combined output state of both registers.\nIn dependence of the address values and their corresponding data values, this could create entanglement.\n\n![](https://quantumcomputingpatterns.org/assets/sketches/qram_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [âExpanding Data Encoding Patterns For Quantum Algorithms.â](https://ieeexplore.ieee.org/document/9425837/) In: 2021 IEEE 18th International Conference on Software Architecture Companion (ICSA-C), IEEE, 2021.&quot;, &quot;Variants&quot;: &quot;Enter your input for this section here.&quot;, &quot;Known Uses&quot;: &quot;An alternative state preparation to realize [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13) can be found in [(Cortese and Braje 2018)](https://arxiv.org/abs/1803.01958) (circuit family \\#3) or [(Prakash 2014)](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2014/EECS-2014-211.pdf).\nAlgorithms for solving semi-definite programs [(Mitarai, Kitagawa and Fujii 2019)](http://arxiv.org/pdf/1805.11250v2)  use [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13). \nA QRAM is required or assumed in various other algorithms [(Giovannetti, Lloyd and Maccone 2008)](https://arxiv.org/abs/0708.1879), [(Rebentrost, Mohseni and Lloyd 2014)](http://www.ncbi.nlm.nih.gov/pubmed/25302877) , [(Wiebe, Kapoor and Svore 2014)](https://arxiv.org/abs/1412.3489), [(Lloyd, Mohseni and Rebentrost 2013)](https://arxiv.org/abs/1307.0401). \nA prominent example of an algorithm that uses this encoding is the HHL algorithm for solving linear equations [(Harrow, Hassidim and Lloyd 2009)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502) which uses [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13) as an intermediate representation for eigenvalues [(Mitarai, Kitagawa and Fujii 2019)](http://arxiv.org/pdf/1805.11250v2).  \n\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)\n&quot;, &quot;Related Patterns&quot;: &quot;This pattern is a refinement of [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) which makes use of [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750). Since the address and output register of QRAM Encoding may be entangled, [Creating Entanglement](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3d1f3991-df47-4d42-8f9a-e6dcf4e3ccec) can be realized with this pattern.&quot;}"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;Enter your input for this section here.&quot;, &quot;Intent&quot;: &quot; \&quot;Use a quantum random access memory to access a superposition of data values at once\&quot; [(Weigold et al. 2021)](https://ieeexplore.ieee.org/document/9425837/)\n\n&quot;, &quot;Result&quot;: &quot;To apply this encoding, $l$ qubits are needed to represent the data values in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750). \nFor the address register, additionally $\\lceil log(n) \\rceil$ qubits are needed containing up to $n$ addresses. \nSince \\textsc{Basis Encoding} is used to represent the data values, the computational properties are similar to other digital encodings (e.g., [Quantum Associative Memory (QuAM)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/482714a7-8409-4165-93fe-72b02c2ae99c) and [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750)): \nSince a set of data values is represented in superposition, the data values can be manipulated at once (using quantum parallelism). \nFurthermore, multiple arithmetic operations (e.g., addition or multiplication) for [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750) are known that can also be applied to values in superposition.\n \n\nNote that algorithms that specify the usage of a QRAM share the following assumption: \nState preparation via the QRAM is efficient and, therefore, of logarithmic runtime [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232). \nHowever, to our best knowledge, there are currently no commercial hardware implementations for QRAM.\nThus, a different state preparation routine has to load the data in the specified encoding. \nA major disadvantage today is that currently no state preparation routine for an arbitrary state is known to be as efficient as the logarithmic runtime of a QRAM. \nAs a result, a theoretically exponential speed-up of an algorithm using QRAM is only possible if the state preparation can be realized by an efficient state preparation method. \n\n&quot;, &quot;Context&quot;: &quot;For accessing the values of input data, a random access memory is needed.\n\n&quot;, &quot;Solution&quot;: &quot;When a classical random access memory (RAM) gets an address to a memory index, it transfers the data value stored at this address into a specified output register. \nThe functionality of quantum random access memory (QRAM) is similar, however, the registers are not classical but quantum registers [(Johnston, Harrigan and Gimeno-Segovia 2019)](https://www.oreilly.com/library/view/programming-quantum-computers/9781492039679/). \nConsequently, the address and output registers can be in  superposition instead of only single values.\nThe solution sketch demonstrates the loading process of a QRAM [(Giovannetti, Lloyd and Maccone 2008)](https://arxiv.org/abs/0708.1879) holding a superposition of the first two addresses ($\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\frac{1}{\\sqrt{2}}\\state{00} + \\frac{1}{\\sqrt{2}}\\state{01})$ as input register. \nLoading the data values of the corresponding addresses results in the following state:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{\\psi} = \\frac{1}{\\sqrt{2}} \\state{00}\\state{010} + \\frac{1}{\\sqrt{2}}\\state{01}\\state{110}\n$$  \n\n\nLoading $m$ of $n$ data values using a QRAM can be generalized as follows [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232): \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\n  \\frac{1}{\\sqrt{m}}\\sum_{i=0}^{m-1}\n    \\state{a}_i\\state{0} \\ \\underrightarrow{QRAM}  \\frac{1}{\\sqrt{m}}\\sum_{i=0}^{m-1}\n \\state{a}_i\\state{x_a}\n $$  \n\n\nThereby,  the  first register specifies the  address  register  containing a  superposition  of $m$ addresses, and the second register is specified as output register.\nFurthermore, $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{a}_i$ denotes the $i$-th data value address which has to be loaded \nand $x_a$ is the data value stored at this address.\nThe task of the QRAM is to load each data value $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{x_a}$ of the addresses in the first register to the output register. \nConsequently, $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{a}_i\\state{x_a}$ is part of the combined output state of both registers.\nIn dependence of the address values and their corresponding data values, this could create entanglement.\n\n![](https://quantumcomputingpatterns.org/assets/sketches/qram_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [âExpanding Data Encoding Patterns For Quantum Algorithms.â](https://ieeexplore.ieee.org/document/9425837/) In: 2021 IEEE 18th International Conference on Software Architecture Companion (ICSA-C), IEEE, 2021.&quot;, &quot;Variants&quot;: &quot;Enter your input for this section here.&quot;, &quot;Known Uses&quot;: &quot;An alternative state preparation to realize [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13) can be found in [(Cortese and Braje 2018)](https://arxiv.org/abs/1803.01958) (circuit family \\#3) or [(Prakash 2014)](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2014/EECS-2014-211.pdf).\nAlgorithms for solving semi-definite programs [(Mitarai, Kitagawa and Fujii 2019)](http://arxiv.org/pdf/1805.11250v2)  use [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13). \nA QRAM is required or assumed in various other algorithms [(Giovannetti, Lloyd and Maccone 2008)](https://arxiv.org/abs/0708.1879), [(Rebentrost, Mohseni and Lloyd 2014)](http://www.ncbi.nlm.nih.gov/pubmed/25302877) , [(Wiebe, Kapoor and Svore 2014)](https://arxiv.org/abs/1412.3489), [(Lloyd, Mohseni and Rebentrost 2013)](https://arxiv.org/abs/1307.0401). \nA prominent example of an algorithm that uses this encoding is the HHL algorithm for solving linear equations [(Harrow, Hassidim and Lloyd 2009)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502) which uses [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13) as an intermediate representation for eigenvalues [(Mitarai, Kitagawa and Fujii 2019)](http://arxiv.org/pdf/1805.11250v2).  \n\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)\n&quot;, &quot;Related Patterns&quot;: &quot;This pattern is a refinement of [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) which makes use of [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750). Since the address and output register of QRAM Encoding may be entangled, [Creating Entanglement](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3d1f3991-df47-4d42-8f9a-e6dcf4e3ccec) can be realized with this pattern.&quot;}"/>
            <where>id='d9c57511-1101-4707-99bf-36f43a12cb13'</where>
        </update>
		<update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;This encoding has also been referred to as Wavefunction Encoding by [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420). Every quantum system is described by its wavefunction $\\psi$ which also defines the measurement probabilities. By expressing that the wavefunction is used to encode data, it is therefore implied that amplitudes of the quantum system are used to represent data values.&quot;, &quot;Intent&quot;: &quot;Encode data in a compact manner that do not require calculations&quot;, &quot;Result&quot;: &quot;A data input vector of length $l$ can be represented by $\\lceil log_2(l)\\rceil$ qubits - this is indeed a very compact representation. For an arbitrary state represented by $n$ qubits (which represents $2^n$ data values), it is known that at least $2^n$ parallel operations are needed [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232). Current state preparation routines perform slightly better than $2^n$ operations [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232). However, depending on the data it maystill be possible to realize an encoding in a logarithmic runtime. For example, a [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) can be created by applying a Hadamard gate to each of the $n$ qubits - which can be done in parallel and thus in a single step. This represents a $2^n$-dimensional vector in which all data entries are $\\frac{1}{\\sqrt{n}}$. Similarly, sparse data vectors can also be prepared more efficiently [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232).It must be noted that if the output is also encoded in the amplitude, multiple measurements must be taken toobtain a good estimate of the output result. The number of measurements scales with the number of amplitudes -as $n$ qubits contain $2^n$ amplitudes, this is costly [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232).&quot;, &quot;Context&quot;: &quot;A numerical input data vector $(x_0, \\ldots, x_{n-1})^T$ must be encoded for an algorithm.&quot;, &quot;Solution&quot;: &quot;Use amplitudes to encode the data. As the squared moduli of the amplitudes of a quantum state must sum up to 1, the input vector needs to be normalized to length 1. This is illustrated in Fig. 5 for a 2-dimensional input vector that contains 2 data points. To associate each amplitude with a component of the input vector, the dimension of the vector must be equal to a power of two because the vector space of an $n$ qubit register has dimension $2^n$. If this is not the case, the input vector can be padded with additional zeros to increase the dimension of it. Using a suitable state preparation routine (see Known Uses), the input vector is encoded in the amplitudes of the quantum state as follows: \n$| \\psi \\rangle  = \\sum_{i=0}^{n-1} x_i | i \\rangle$.\nAs the amplitudes depend on the data, the process of encoding the data (but not the encoding itself) is often referred to as arbitrary state preparation.\n\n![](https://quantumcomputingpatterns.org/assets/sketches/amplitude_encoding_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [Data Encoding Patterns for Quantum Algorithms.](https://hillside.net/plop/2020/papers/weigold.pdf) In: The Hillside Group (Hrsg): Proceedings of the 27th Conference on Pattern Languages of Programs (PLoP '20).\n&quot;, &quot;Variants&quot;: &quot;Enter your input for this section here.&quot;, &quot;Known Uses&quot;: &quot;[Amplitude Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/502147ec-45fa-403f-8f52-e196b3359399) is required by many quantum machine learning algorithms [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420). Another example is the algorithm of Harrow, Hassidim and Lloyd [(Harrow, Hassidim and Lloyd 2009)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502) (often referred to as HHL algorithm) for solving linear equations. The pre-condition that the data values can be normalized is a common assumption in machine learning [(Schuld et al. 2017)](http://dx.doi.org/10.1209/0295-5075/119/60002), e.g. in support vector machine.There are various ways to construct a state preparation routine for this encoding. For example, [(Plesch and Brukner 2011)](http://dx.doi.org/10.1103/PhysRevA.83.032302) and [(Iten et al. 2016)](http://dx.doi.org/10.1103/PhysRevA.93.032318) use the Schmidt Decomposition. For the latter, an implementation in Mathematica was presented [(Iten et al. 2019)](https://arxiv.org/abs/1904.01072). [(Shende et al. 2006)](https://ieeexplore.ieee.org/document/1629135) presented an alternative way to construct an arbitrary quantum state which was implemented by Qiskit [(Qis 2020)](https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations). PennyLane offers a loading routine for [Amplitude Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/502147ec-45fa-403f-8f52-e196b3359399) [Pen 2020](https://pennylane.readthedocs.io/en/stable/introduction/templates.html). The library also includes an arbitrary state preparation routine that uses the algorithm proposed by [(MÃ¶ttÃ¶nen and Vartiainen 2005)](https://arxiv.org/abs/quant-ph/0504100). The state preparation routine by [(MÃ¶ttÃ¶nen and Vartiainen 2005)](https://arxiv.org/abs/quant-ph/0504100) requires an exponential number of operations to encode $2^n$ data values. Q# provides functionality to compute a state preparation routine that approximates the desired amplitude encoding [(QSh 2020)](https://docs.microsoft.com/en-us/qsharp/api/).\n\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern refines [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d). The encoding is more compact (in terms of qubits) than [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750), [Angle Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/e595558d-bfea-4b82-9f47-a38a2097b245) or  [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13).&quot;}"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;This encoding has also been referred to as Wavefunction Encoding by [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420). Every quantum system is described by its wavefunction $\\psi$ which also defines the measurement probabilities. By expressing that the wavefunction is used to encode data, it is therefore implied that amplitudes of the quantum system are used to represent data values.&quot;, &quot;Intent&quot;: &quot;Encode data in a compact manner that do not require calculations&quot;, &quot;Result&quot;: &quot;A data input vector of length $l$ can be represented by $\\lceil log_2(l)\\rceil$ qubits - this is indeed a very compact representation. For an arbitrary state represented by $n$ qubits (which represents $2^n$ data values), it is known that at least $2^n$ parallel operations are needed [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232). Current state preparation routines perform slightly better than $2^n$ operations [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232). However, depending on the data it maystill be possible to realize an encoding in a logarithmic runtime. For example, a [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) can be created by applying a Hadamard gate to each of the $n$ qubits - which can be done in parallel and thus in a single step. This represents a $2^n$-dimensional vector in which all data entries are $\\frac{1}{\\sqrt{n}}$. Similarly, sparse data vectors can also be prepared more efficiently [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232).It must be noted that if the output is also encoded in the amplitude, multiple measurements must be taken toobtain a good estimate of the output result. The number of measurements scales with the number of amplitudes -as $n$ qubits contain $2^n$ amplitudes, this is costly [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232).&quot;, &quot;Context&quot;: &quot;A numerical input data vector $(x_0, \\ldots, x_{n-1})^T$ must be encoded for an algorithm.&quot;, &quot;Solution&quot;: &quot;Use amplitudes to encode the data. As the squared moduli of the amplitudes of a quantum state must sum up to 1, the input vector needs to be normalized to length 1. This is illustrated in Fig. 5 for a 2-dimensional input vector that contains 2 data points. To associate each amplitude with a component of the input vector, the dimension of the vector must be equal to a power of two because the vector space of an $n$ qubit register has dimension $2^n$. If this is not the case, the input vector can be padded with additional zeros to increase the dimension of it. Using a suitable state preparation routine (see Known Uses), the input vector is encoded in the amplitudes of the quantum state as follows: \n$| \\psi \\rangle  = \\sum_{i=0}^{n-1} x_i | i \\rangle$.\nAs the amplitudes depend on the data, the process of encoding the data (but not the encoding itself) is often referred to as arbitrary state preparation.\n\n![](https://quantumcomputingpatterns.org/assets/sketches/amplitude_encoding_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [Data Encoding Patterns for Quantum Algorithms.](https://hillside.net/plop/2020/papers/weigold.pdf) In: The Hillside Group (Hrsg): Proceedings of the 27th Conference on Pattern Languages of Programs (PLoP '20).\n&quot;, &quot;Variants&quot;: &quot;Enter your input for this section here.&quot;, &quot;Known Uses&quot;: &quot;[Amplitude Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/502147ec-45fa-403f-8f52-e196b3359399) is required by many quantum machine learning algorithms [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420). Another example is the algorithm of Harrow, Hassidim and Lloyd [(Harrow, Hassidim and Lloyd 2009)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502) (often referred to as HHL algorithm) for solving linear equations. The pre-condition that the data values can be normalized is a common assumption in machine learning [(Schuld et al. 2017)](http://dx.doi.org/10.1209/0295-5075/119/60002), e.g. in support vector machine.There are various ways to construct a state preparation routine for this encoding. For example, [(Plesch and Brukner 2011)](http://dx.doi.org/10.1103/PhysRevA.83.032302) and [(Iten et al. 2016)](http://dx.doi.org/10.1103/PhysRevA.93.032318) use the Schmidt Decomposition. For the latter, an implementation in Mathematica was presented [(Iten et al. 2019)](https://arxiv.org/abs/1904.01072). [(Shende et al. 2006)](https://ieeexplore.ieee.org/document/1629135) presented an alternative way to construct an arbitrary quantum state which was implemented by Qiskit [(Qis 2020)](https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations). PennyLane offers a loading routine for [Amplitude Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/502147ec-45fa-403f-8f52-e196b3359399) [Pen 2020](https://pennylane.readthedocs.io/en/stable/introduction/templates.html). The library also includes an arbitrary state preparation routine that uses the algorithm proposed by [(MÃ¶ttÃ¶nen and Vartiainen 2005)](https://arxiv.org/abs/quant-ph/0504100). The state preparation routine by [(MÃ¶ttÃ¶nen and Vartiainen 2005)](https://arxiv.org/abs/quant-ph/0504100) requires an exponential number of operations to encode $2^n$ data values. Q# provides functionality to compute a state preparation routine that approximates the desired amplitude encoding [(QSh 2020)](https://docs.microsoft.com/en-us/qsharp/api/).\n\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern refines [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d). The encoding is more compact (in terms of qubits) than [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750), [Angle Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/e595558d-bfea-4b82-9f47-a38a2097b245) or  [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13).&quot;}"/>
            <where>id='502147ec-45fa-403f-8f52-e196b3359399'</where>
        </update>
		<update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;Approximate the solution of an optimization problem [Weigold et al. 2021](https://www.springer.com/de/book/9783030648459)\n\n&quot;, &quot;Result&quot;: &quot;The depth of the overall circuit is at most $mp + p$ [(Farhi and Goldstone 2014)](http://arxiv.org/pdf/1411.4028v1) which is rather shallow. \nThis is one reason why this algorithm is considered a promising candidate for NISQ devices. \nFrom a theoretical point of view, it can be noticed that the algorithm approximates the best solution if suitable small values for the parameters $\\gamma, \\beta$ are chosen with  $p\\rightarrow \\infty$. \nNevertheless, note that the performance of the algorithm also depends on the objective function and the optimization strategy. \n\n&quot;, &quot;Context&quot;: &quot;To solve a combinatorial optimization problem, a bit string $z=z_1\\ldots z_n$ must be found which assigns each binary variable $z_i$ to either 0 or 1 and fulfills a maximum number of $m$ clauses. \nHereby, each clause involves a subset of the variables.\nIn contrast to the potentially constrained domain of solutions in [Alternating Operator Ansatz (AOA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/b657ea73-63c0-4800-a69d-a91925e19ac6), every bit string $z=z_1\\ldots z_n$ of length $n$ is a solution to the problem. \n\n&quot;, &quot;Solution&quot;: &quot;The overall structure of the *Quantum Approximate Optimization Algorithm (QAOA)* [(Farhi and Goldstone 2014)](http://arxiv.org/pdf/1411.4028v1) approach is depicted in the solution sketch.\n\nFirst, a [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) realizing all possible solutions in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/de5b0951-2b66-4312-bf06-7082d3232e6e) is prepared.\nE.g., the solution with all binary values assigned to 0 is represented by $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{0 \\ldots 0 0}$ and is contained in the superposition. \n\n\nThen, an ansatz circuit is applied that is constructed based on the two operators $U(C,\\gamma)$ and $U(B,\\beta)$:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\n    U(C,\\gamma) = e^{i\\gamma C} = \\prod_{\\alpha=1}^{m} e^{-i\\gamma C_\\alpha}; \n    \\ U(B,\\beta) = e^{-i\\beta B} = \\prod_{j=1}^{n}e^{-i\\beta \\sigma_x^{j}}\n$$  \n\n\nThe first operator is a phase shift $e^{-i\\gamma}$ on every computational basis state for every clause that is fulfilled. \nHowever, this marks but does not change the amplitude of computational basis states (which each represent a solution), thus, the second operator $U(B,\\gamma)$ is required. \n$U(B,\\gamma)$ defines a rotation around the $X$-axis for every qubit whereby the angle for the rotation depends on $\\gamma$. \nBased on the structure defined in [Alternating Operator Ansatz (AOA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/b657ea73-63c0-4800-a69d-a91925e19ac6), a trial state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\gamma,\\beta}$ is prepared. \nMeasuring this state results in a single bitstring, i.e., a solution that can be evaluated by the objective function. \nThe parameters $\\beta$ and $\\gamma$ which are initialized randomly for the first iteration can then be adjusted. \nThis iterative process continues until the termination condition is satisfied. \n\n![](https://quantumcomputingpatterns.org/assets/sketches/variational_solution_qaoa.png)\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2 ) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;This algorithm was first proposed by Farhi, Goldstone, and Gutmann [(Farhi and Goldstone 2014)](http://arxiv.org/pdf/1411.4028v1) and applied to the problem of finding a maximum cut of a graph (MaxCut). \nIn a follow-up paper, an advantage over classical algorithms for the *bounded occurrence problem* [(Farhi, Goldstone and Gutmann 2015)](https://arxiv.org/abs/1412.6062) was shown. \nShortly afterward, a classical algorithm [(Barak et al. 2015)](http://arxiv.org/abs/1505.03424) was published from which even better results can be expected for this particular problem instance. \n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)&quot;, &quot;Related Patterns&quot;: &quot;In this pattern [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) is used to represent the bitstrings of solutions in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750).\nThe higher-level structure of this pattern is described by [Alternating Operator Ansatz (AOA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/b657ea73-63c0-4800-a69d-a91925e19ac6) which also uses [Phase Shift](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/c6560c51-d2e3-4595-b9c3-b609c75c0b82) . \n\n&quot;}"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;Approximate the solution of an optimization problem [Weigold et al. 2021](https://www.springer.com/de/book/9783030648459)\n\n&quot;, &quot;Result&quot;: &quot;The depth of the overall circuit is at most $mp + p$ [(Farhi and Goldstone 2014)](http://arxiv.org/pdf/1411.4028v1) which is rather shallow. \nThis is one reason why this algorithm is considered a promising candidate for NISQ devices. \nFrom a theoretical point of view, it can be noticed that the algorithm approximates the best solution if suitable small values for the parameters $\\gamma, \\beta$ are chosen with  $p\\rightarrow \\infty$. \nNevertheless, note that the performance of the algorithm also depends on the objective function and the optimization strategy. \n\n&quot;, &quot;Context&quot;: &quot;To solve a combinatorial optimization problem, a bit string $z=z_1\\ldots z_n$ must be found which assigns each binary variable $z_i$ to either 0 or 1 and fulfills a maximum number of $m$ clauses. \nHereby, each clause involves a subset of the variables.\nIn contrast to the potentially constrained domain of solutions in [Alternating Operator Ansatz (AOA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/b657ea73-63c0-4800-a69d-a91925e19ac6), every bit string $z=z_1\\ldots z_n$ of length $n$ is a solution to the problem. \n\n&quot;, &quot;Solution&quot;: &quot;The overall structure of the *Quantum Approximate Optimization Algorithm (QAOA)* [(Farhi and Goldstone 2014)](http://arxiv.org/pdf/1411.4028v1) approach is depicted in the solution sketch.\n\nFirst, a [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) realizing all possible solutions in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/de5b0951-2b66-4312-bf06-7082d3232e6e) is prepared.\nE.g., the solution with all binary values assigned to 0 is represented by $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{0 \\ldots 0 0}$ and is contained in the superposition. \n\n\nThen, an ansatz circuit is applied that is constructed based on the two operators $U(C,\\gamma)$ and $U(B,\\beta)$:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\n    U(C,\\gamma) = e^{i\\gamma C} = \\prod_{\\alpha=1}^{m} e^{-i\\gamma C_\\alpha}; \n    \\ U(B,\\beta) = e^{-i\\beta B} = \\prod_{j=1}^{n}e^{-i\\beta \\sigma_x^{j}}\n$$  \n\n\nThe first operator is a phase shift $e^{-i\\gamma}$ on every computational basis state for every clause that is fulfilled. \nHowever, this marks but does not change the amplitude of computational basis states (which each represent a solution), thus, the second operator $U(B,\\gamma)$ is required. \n$U(B,\\gamma)$ defines a rotation around the $X$-axis for every qubit whereby the angle for the rotation depends on $\\gamma$. \nBased on the structure defined in [Alternating Operator Ansatz (AOA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/b657ea73-63c0-4800-a69d-a91925e19ac6), a trial state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\gamma,\\beta}$ is prepared. \nMeasuring this state results in a single bitstring, i.e., a solution that can be evaluated by the objective function. \nThe parameters $\\beta$ and $\\gamma$ which are initialized randomly for the first iteration can then be adjusted. \nThis iterative process continues until the termination condition is satisfied. \n\n![](https://quantumcomputingpatterns.org/assets/sketches/variational_solution_qaoa.png)\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2 ) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;This algorithm was first proposed by Farhi, Goldstone, and Gutmann [(Farhi and Goldstone 2014)](http://arxiv.org/pdf/1411.4028v1) and applied to the problem of finding a maximum cut of a graph (MaxCut). \nIn a follow-up paper, an advantage over classical algorithms for the *bounded occurrence problem* [(Farhi, Goldstone and Gutmann 2015)](https://arxiv.org/abs/1412.6062) was shown. \nShortly afterward, a classical algorithm [(Barak et al. 2015)](http://arxiv.org/abs/1505.03424) was published from which even better results can be expected for this particular problem instance. \n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)&quot;, &quot;Related Patterns&quot;: &quot;In this pattern [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) is used to represent the bitstrings of solutions in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750).\nThe higher-level structure of this pattern is described by [Alternating Operator Ansatz (AOA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/b657ea73-63c0-4800-a69d-a91925e19ac6) which also uses [Phase Shift](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/c6560c51-d2e3-4595-b9c3-b609c75c0b82) . \n\n&quot;}"/>
            <where>id='da93f915-7f4c-49df-99d0-80d91f26a337'</where>
        </update>
		<update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;Enter your input for this section here.&quot;, &quot;Intent&quot;: &quot;Split computational tasks into a quantum part running on a quantum computer and a classical part running on a classical computer.&quot;, &quot;Result&quot;: &quot;Since the part running on a classical computer and the part on a quantum computer can depend on each other, e.g., in an iterative solution, several interactions between the systems may be needed.\nConsequently, if a classical computer and a quantum computer are connected via a queue, the queuing time, i.e., the time messages are waiting in the queue, also contributes to the overall runtime. \n\n&quot;, &quot;Context&quot;: &quot;There are many quantum algorithms that require pre-processing or post-processing which must be done on a classical device.\nThus, it is often necessary to split the algorithms into quantum parts and classical parts. \nSimilarly, to run a quantum algorithm on a quantum computer that contains a small number of, possibly noisy, qubits, it may also be beneficial to split the algorithm into a quantum part of reasonable size and a classical part [(Preskill 2018)](https://quantum-journal.org/papers/q-2018-08-06-79/).\n\n &quot;, &quot;Solution&quot;: &quot;The main idea is to split an algorithm into quantum parts and classical parts. \nHowever, how an algorithm can be split depends on the problem and its implementation.\n\n&quot;, &quot;Variants&quot;: &quot;Enter your input for this section here.&quot;, &quot;Known Uses&quot;: &quot;Prominent quantum algorithms that depend on classical pre-processing or post-processing are Shorâs algorithm [(Shor 1994)](https://ieeexplore.ieee.org/document/365700) and Simonâs algorithm [(Simon 1997)](https://epubs.siam.org/doi/10.1137/S0097539796298637).\nAnother example is the algorithm stated in [(Farhi, Goldstone and Gutmann 2014)](https://arxiv.org/abs/1411.4028) which is used to solve combinatorial optimization problems and therefore uses classical pre-processing.\nTo enable factorization on NISQ devices the algorithm presented in [(Anschuetz et al. 2018)](https://link.springer.com/chapter/10.1007/978-3-030-14082-3_7) uses a quantum-classic split.\n\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n[Quantum-Assisted Genetic Algorithm (PlanQK)](https://platform.planqk.de/algorithms/efc367a5-cc55-438a-995d-9bc6eca63e5e/)\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)\n[Quantum Generative Adversarial Network (PlanQK)](https://platform.planqk.de/algorithms/c83040fe-e0a7-42d4-be3c-77e223bfdaeb/)\n[Shor's Algorithm (QC-Atlas)](http://localhost/#/algorithms/b5df6c13-e619-496c-ada0-80fc3486f733)&quot;, &quot;Related Patterns&quot;: &quot;To pass Information from the classical part of an algorithm to its quantum parts, proper [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) is needed.\n\n&quot;}"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;Enter your input for this section here.&quot;, &quot;Intent&quot;: &quot;Split computational tasks into a quantum part running on a quantum computer and a classical part running on a classical computer.&quot;, &quot;Result&quot;: &quot;Since the part running on a classical computer and the part on a quantum computer can depend on each other, e.g., in an iterative solution, several interactions between the systems may be needed.\nConsequently, if a classical computer and a quantum computer are connected via a queue, the queuing time, i.e., the time messages are waiting in the queue, also contributes to the overall runtime. \n\n&quot;, &quot;Context&quot;: &quot;There are many quantum algorithms that require pre-processing or post-processing which must be done on a classical device.\nThus, it is often necessary to split the algorithms into quantum parts and classical parts. \nSimilarly, to run a quantum algorithm on a quantum computer that contains a small number of, possibly noisy, qubits, it may also be beneficial to split the algorithm into a quantum part of reasonable size and a classical part [(Preskill 2018)](https://quantum-journal.org/papers/q-2018-08-06-79/).\n\n &quot;, &quot;Solution&quot;: &quot;The main idea is to split an algorithm into quantum parts and classical parts. \nHowever, how an algorithm can be split depends on the problem and its implementation.\n\n&quot;, &quot;Variants&quot;: &quot;Enter your input for this section here.&quot;, &quot;Known Uses&quot;: &quot;Prominent quantum algorithms that depend on classical pre-processing or post-processing are Shorâs algorithm [(Shor 1994)](https://ieeexplore.ieee.org/document/365700) and Simonâs algorithm [(Simon 1997)](https://epubs.siam.org/doi/10.1137/S0097539796298637).\nAnother example is the algorithm stated in [(Farhi, Goldstone and Gutmann 2014)](https://arxiv.org/abs/1411.4028) which is used to solve combinatorial optimization problems and therefore uses classical pre-processing.\nTo enable factorization on NISQ devices the algorithm presented in [(Anschuetz et al. 2018)](https://link.springer.com/chapter/10.1007/978-3-030-14082-3_7) uses a quantum-classic split.\n\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n[Quantum-Assisted Genetic Algorithm (PlanQK)](https://platform.planqk.de/algorithms/efc367a5-cc55-438a-995d-9bc6eca63e5e/)\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)\n[Quantum Generative Adversarial Network (PlanQK)](https://platform.planqk.de/algorithms/c83040fe-e0a7-42d4-be3c-77e223bfdaeb/)\n[Shor's Algorithm (QC-Atlas)](http://localhost/#/algorithms/b5df6c13-e619-496c-ada0-80fc3486f733)&quot;, &quot;Related Patterns&quot;: &quot;To pass Information from the classical part of an algorithm to its quantum parts, proper [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) is needed.\n\n&quot;}"/>
            <where>id='dd15032b-ce2b-40b6-80ac-97623255b531'</where>
        </update>
		<update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;Phase estimation algorithm (PEA)&quot;, &quot;Intent&quot;: &quot;Approximate the eigenvalue of a unitary matrix.&quot;, &quot;Result&quot;: &quot;If $\\varphi$ is a rational number, the ancilla register contains the eigenvalue in [Basis Encoding](#/patterns/0) (assuming a proper number of anchillae). Otherwise, an approximation is produced with a probability of at least $\\frac{4}{\\pi}$. Increasing the precision of the approximation by adding more ancillae is costly because this also increases the number of required controlled-$U$ operations. Because  of  these  demanding  hardware requirements, this algorithm is often regarded as non-suitable for NISQ devices.&quot;, &quot;Context&quot;: &quot;Given a unitary matrix $U$ and one of its eigenstates, the corresponding eigenvalue should be determined. The eigenstate $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{v}$ is given on a register in [Basis Encoding](#/patterns/0). Applying $U$ to the eigenstate $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{v}$ results in a global phase: \n$$U\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{v} = e^{2\\pi i \\varphi} \\state{v}$$\nwhere the eigenvalue $\\lambda = e^{2\\pi i \\varphi}$ is uniquely determined by $\\varphi \\in [0,1]$. Therefore, it is sufficient to estimate $\\varphi$.&quot;, &quot;Solution&quot;: &quot;Use the circuit shown in the pattern sketch to estimate the approximation of $\\theta$. First, a register of $m$ ancillae is brought into an [Uniform Superposition](#/patterns/16). Next, controlled versions of powers of $U$ are applied on the register of the eigenstate following the scheme depicted inthe pattern sketch. Each application of a controlled-$U$ operation results in a _phase kickback_ of the control qubit, i.e., this qubit acquires a relative phase of $\\varphi$. This results in the overall state:\n$$\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi} = \n    \\sum_{y=0}^{2^m-1}e^{2\\pi \\varphi y}\\state{y}$$\n where $\\varphi$ is encoded in the relative phase. \nTo extract this information, the inverse of the quantum fourier transformation is applied on the ancilla register. &quot;, &quot;Variants&quot;: &quot;The second register can also be initialized as an arbitrary quantum state which is always a linear combination of eigenvectors. In this case, the algorithm approximates a superposition of eigenvalues for these eigenvectors in the output register. Other variants of this algorithm further improve the depth of the circuit or require fewer measurements. &quot;, &quot;Known Uses&quot;: &quot;_Quantum Phase Estimation_ is at the heart of many algorithms [[Cleve et al. 1998](https://royalsocietypublishing.org/doi/abs/10.1098/rspa.1998.0164)]. One prominent example which we review in a later section is the HHL algorithm [[Harrow, Hassidim and Lloyd 2009](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502)]. Other QML algorithms follow a similar scheme [[Schuld and Petruccione 2018](http://dx.doi.org/10.1007/978-3-319-96424-9), [Duan et al. 2020](https://www.sciencedirect.com/science/article/abs/pii/S037596012030462X)], e.g., quantum support vector machine (QSVM) [[Rebentrost et al. 2014](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.113.130503)] or quantum principal component analysis (QPCA) [[Lloyd et al. 2014](https://www.nature.com/articles/nphys3029)]. [Qiskit]( https://qiskit.org/documentation/stubs/qiskit.circuit.library.PhaseEstimation.html) provides an implementation for this pattern.\n\n[Shor's Algorithm (QC-Atlas)](http://localhost/#/algorithms/b5df6c13-e619-496c-ada0-80fc3486f733)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern uses [Amplitude Encoding](#/patterns/2) and [Matrix Encoding](#/patterns/11) and produces an output in [Basis Encoding](#/patterns/0).&quot;}"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;Phase estimation algorithm (PEA)&quot;, &quot;Intent&quot;: &quot;Approximate the eigenvalue of a unitary matrix.&quot;, &quot;Result&quot;: &quot;If $\\varphi$ is a rational number, the ancilla register contains the eigenvalue in [Basis Encoding](#/patterns/0) (assuming a proper number of anchillae). Otherwise, an approximation is produced with a probability of at least $\\frac{4}{\\pi}$. Increasing the precision of the approximation by adding more ancillae is costly because this also increases the number of required controlled-$U$ operations. Because  of  these  demanding  hardware requirements, this algorithm is often regarded as non-suitable for NISQ devices.&quot;, &quot;Context&quot;: &quot;Given a unitary matrix $U$ and one of its eigenstates, the corresponding eigenvalue should be determined. The eigenstate $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{v}$ is given on a register in [Basis Encoding](#/patterns/0). Applying $U$ to the eigenstate $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{v}$ results in a global phase: \n$$U\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{v} = e^{2\\pi i \\varphi} \\state{v}$$\nwhere the eigenvalue $\\lambda = e^{2\\pi i \\varphi}$ is uniquely determined by $\\varphi \\in [0,1]$. Therefore, it is sufficient to estimate $\\varphi$.&quot;, &quot;Solution&quot;: &quot;Use the circuit shown in the pattern sketch to estimate the approximation of $\\theta$. First, a register of $m$ ancillae is brought into an [Uniform Superposition](#/patterns/16). Next, controlled versions of powers of $U$ are applied on the register of the eigenstate following the scheme depicted inthe pattern sketch. Each application of a controlled-$U$ operation results in a _phase kickback_ of the control qubit, i.e., this qubit acquires a relative phase of $\\varphi$. This results in the overall state:\n$$\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi} = \n    \\sum_{y=0}^{2^m-1}e^{2\\pi \\varphi y}\\state{y}$$\n where $\\varphi$ is encoded in the relative phase. \nTo extract this information, the inverse of the quantum fourier transformation is applied on the ancilla register. &quot;, &quot;Variants&quot;: &quot;The second register can also be initialized as an arbitrary quantum state which is always a linear combination of eigenvectors. In this case, the algorithm approximates a superposition of eigenvalues for these eigenvectors in the output register. Other variants of this algorithm further improve the depth of the circuit or require fewer measurements. &quot;, &quot;Known Uses&quot;: &quot;_Quantum Phase Estimation_ is at the heart of many algorithms [[Cleve et al. 1998](https://royalsocietypublishing.org/doi/abs/10.1098/rspa.1998.0164)]. One prominent example which we review in a later section is the HHL algorithm [[Harrow, Hassidim and Lloyd 2009](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502)]. Other QML algorithms follow a similar scheme [[Schuld and Petruccione 2018](http://dx.doi.org/10.1007/978-3-319-96424-9), [Duan et al. 2020](https://www.sciencedirect.com/science/article/abs/pii/S037596012030462X)], e.g., quantum support vector machine (QSVM) [[Rebentrost et al. 2014](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.113.130503)] or quantum principal component analysis (QPCA) [[Lloyd et al. 2014](https://www.nature.com/articles/nphys3029)]. [Qiskit]( https://qiskit.org/documentation/stubs/qiskit.circuit.library.PhaseEstimation.html) provides an implementation for this pattern.\n\n[Shor's Algorithm (QC-Atlas)](http://localhost/#/algorithms/b5df6c13-e619-496c-ada0-80fc3486f733)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern uses [Amplitude Encoding](#/patterns/2) and [Matrix Encoding](#/patterns/11) and produces an output in [Basis Encoding](#/patterns/0).&quot;}"/>
            <where>id='a4ea9f6c-5b0a-4beb-a056-8b261d96ba80'</where>
        </update>
		<update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;Select one branch of a superposition to proceed with&quot;, &quot;Result&quot;: &quot;As the resulting approach is probabilistic, thus, the average number of iterations needed depends on the amplitude of the selected branch. In the example above, the algorithm proceeds with a probability of 50\\%.&quot;, &quot;Context&quot;: &quot;As quantum operations are unitary, they perform linear transformations. However, sometimes a non-linear transformation is desirable. For example, if the result of a computation is stored in one branch of the superposition, e.g.,\n$$\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{\\psi}=\\frac{1}{\\sqrt{2}}\\state{1}\\state{f(x)} + \\frac{1}{\\sqrt{2}} \\state{0}\\state{g(x)}$$\n one would like to proceed with $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{1}\\state{f(x)}$ and discard the rest of the superposition.&quot;, &quot;Solution&quot;: &quot;Use measurement to force the quantum state to collapse into one of the two branches. \nFor the example above, measuring the first qubit in the computational basis results in either $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{0}$ or $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{1}$. If the measurement indicates that the preferred branch was selected (i.e., $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{1}$ for our example)), one can proceed with further calculations (shown in the pattern sketch). Otherwise, the current computation is discarded and restarted from the beginning, i.e., by first resetting each qubit to $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{0}$ followed by the operations of the rest of the circuit.&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;A non-linear transformation can be favorable for designing quantum neural networks [[Cao et al. 2017](https://arxiv.org/abs/1711.11240)]. The HHL algorithm [[Harrow, Hassidim and Lloyd 2009](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502)] and various other algorithms that build on it, for example, the Quantum Support Vector Machine [Duan et al. 2020](https://www.sciencedirect.com/science/article/abs/pii/S037596012030462X)], use this technique._Post-Selective Measurements_ are also used in repeat-until-success circuits [[Paetznick and Svore](https://arxiv.org/abs/1311.1074)] that restore the state before the measurement via a recovery operation instead of restarting the whole computation. OpenQASM 3.0 introduces the functionality to explicitly model such an approach through the usage of measurements within a _while_ loop [[Cross et al. 2021](https://arxiv.org/abs/2104.14722)].\n\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)&quot;, &quot;Related Patterns&quot;: &quot;[Amplitude Amplification](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/96b4d28a-a5ce-4c96-85df-d42587b13c57) can be used to increase the probability to select a particular branch.&quot;}"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;Select one branch of a superposition to proceed with&quot;, &quot;Result&quot;: &quot;As the resulting approach is probabilistic, thus, the average number of iterations needed depends on the amplitude of the selected branch. In the example above, the algorithm proceeds with a probability of 50\\%.&quot;, &quot;Context&quot;: &quot;As quantum operations are unitary, they perform linear transformations. However, sometimes a non-linear transformation is desirable. For example, if the result of a computation is stored in one branch of the superposition, e.g.,\n$$\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{\\psi}=\\frac{1}{\\sqrt{2}}\\state{1}\\state{f(x)} + \\frac{1}{\\sqrt{2}} \\state{0}\\state{g(x)}$$\n one would like to proceed with $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{1}\\state{f(x)}$ and discard the rest of the superposition.&quot;, &quot;Solution&quot;: &quot;Use measurement to force the quantum state to collapse into one of the two branches. \nFor the example above, measuring the first qubit in the computational basis results in either $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{0}$ or $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{1}$. If the measurement indicates that the preferred branch was selected (i.e., $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{1}$ for our example)), one can proceed with further calculations (shown in the pattern sketch). Otherwise, the current computation is discarded and restarted from the beginning, i.e., by first resetting each qubit to $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{0}$ followed by the operations of the rest of the circuit.&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;A non-linear transformation can be favorable for designing quantum neural networks [[Cao et al. 2017](https://arxiv.org/abs/1711.11240)]. The HHL algorithm [[Harrow, Hassidim and Lloyd 2009](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502)] and various other algorithms that build on it, for example, the Quantum Support Vector Machine [Duan et al. 2020](https://www.sciencedirect.com/science/article/abs/pii/S037596012030462X)], use this technique._Post-Selective Measurements_ are also used in repeat-until-success circuits [[Paetznick and Svore](https://arxiv.org/abs/1311.1074)] that restore the state before the measurement via a recovery operation instead of restarting the whole computation. OpenQASM 3.0 introduces the functionality to explicitly model such an approach through the usage of measurements within a _while_ loop [[Cross et al. 2021](https://arxiv.org/abs/2104.14722)].\n\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)&quot;, &quot;Related Patterns&quot;: &quot;[Amplitude Amplification](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/96b4d28a-a5ce-4c96-85df-d42587b13c57) can be used to increase the probability to select a particular branch.&quot;}"/>
            <where>id='1c95912a-128b-44e7-b2d4-930f7ba11060'</where>
        </update>
		<update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot; \&quot;Fine-tune an optimization algorithm by warm starting it\&quot; [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)&quot;, &quot;Result&quot;: &quot;Using the warm starting approach, a proceeding optimization is initialized with the classical approximation result which should be nearer to the optimum than a random starting point. \nThe warm starting procedure should also be taken into account for the overall runtime complexity. \n\n&quot;, &quot;Context&quot;: &quot;The best solution for an optimization problem must be found or approximated. \nFor classical methods, the *Unique Game Conjecture* (UGC) states that there is a theoretical upper bound for the approximation ratio which can not be further improved.\nThis implies that classical methods can only approximate up to this bound, i.e., up to a certain extent. \nHowever, since the UGC is not true when entanglement is used, quantum algorithms have the potential to surpass these bounds, i.e., they can approximate better solutions than classical algorithms. \n\n&quot;, &quot;Solution&quot;: &quot;Start by using a classical approach to approximate the best solution. \nThe classical approximation result can often be found as a solution for a related problem, e.g., by weakening or eliminating constraints of the problem.  \n\n&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;Warm starting was shown to be beneficial for the MaxCut problem [Tate et al. 2020](https://www.researchgate.net/publication/344911160_Bridging_Classical_and_Quantum_with_SDP_initialized_warm-starts_for_QAOA) and another optimization use case [Egger, Marecek and Woerner 2020](https://arxiv.org/abs/2009.10095).\nThe approach presented in [Barkoutsos 2018](https://arxiv.org/abs/1805.04340) can also be regarded as a warm start for [Variational Quantum Eigensolver (VQE)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/27a5d147-a323-4c6a-84ef-45d80cae923d) [Egger, Marecek and Woerner 2020](https://arxiv.org/abs/2009.10095).\n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)&quot;, &quot;Related Patterns&quot;: &quot;Warm start can be used to provide initial starting solutions for [Quantum Approximate Optimization Algorithm (QAOA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/da93f915-7f4c-49df-99d0-80d91f26a337) or [Variational Quantum Eigensolver (VQE)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/27a5d147-a323-4c6a-84ef-45d80cae923d). \n\n&quot;}"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot; \&quot;Fine-tune an optimization algorithm by warm starting it\&quot; [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)&quot;, &quot;Result&quot;: &quot;Using the warm starting approach, a proceeding optimization is initialized with the classical approximation result which should be nearer to the optimum than a random starting point. \nThe warm starting procedure should also be taken into account for the overall runtime complexity. \n\n&quot;, &quot;Context&quot;: &quot;The best solution for an optimization problem must be found or approximated. \nFor classical methods, the *Unique Game Conjecture* (UGC) states that there is a theoretical upper bound for the approximation ratio which can not be further improved.\nThis implies that classical methods can only approximate up to this bound, i.e., up to a certain extent. \nHowever, since the UGC is not true when entanglement is used, quantum algorithms have the potential to surpass these bounds, i.e., they can approximate better solutions than classical algorithms. \n\n&quot;, &quot;Solution&quot;: &quot;Start by using a classical approach to approximate the best solution. \nThe classical approximation result can often be found as a solution for a related problem, e.g., by weakening or eliminating constraints of the problem.  \n\n&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;Warm starting was shown to be beneficial for the MaxCut problem [Tate et al. 2020](https://www.researchgate.net/publication/344911160_Bridging_Classical_and_Quantum_with_SDP_initialized_warm-starts_for_QAOA) and another optimization use case [Egger, Marecek and Woerner 2020](https://arxiv.org/abs/2009.10095).\nThe approach presented in [Barkoutsos 2018](https://arxiv.org/abs/1805.04340) can also be regarded as a warm start for [Variational Quantum Eigensolver (VQE)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/27a5d147-a323-4c6a-84ef-45d80cae923d) [Egger, Marecek and Woerner 2020](https://arxiv.org/abs/2009.10095).\n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)&quot;, &quot;Related Patterns&quot;: &quot;Warm start can be used to provide initial starting solutions for [Quantum Approximate Optimization Algorithm (QAOA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/da93f915-7f4c-49df-99d0-80d91f26a337) or [Variational Quantum Eigensolver (VQE)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/27a5d147-a323-4c6a-84ef-45d80cae923d). \n\n&quot;}"/>
            <where>id='3ea9e187-e91b-4852-84eb-b35b5c480892'</where>
        </update>
		<update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;\&quot;Optimize the parameters of a quantum circuit on a classical computer\&quot; [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)\n\n&quot;, &quot;Result&quot;: &quot;However, choosing $f$, the observables for measuring the qubits and an ansatz is not trivial.\nThe convergence of the algorithm depends on multiple factors: the objective function and the optimization strategy for updating the parameters. \nRegarding the objective function, one major obstacle for the convergence of the solution are regions of the function which contain only a small norm of the gradient (these regions are also referred to as *barren plateaus*). \nThese regions can significantly influence how fast the solution converges [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265) or in the worst case, result in non-convergence of the algorithm. \nSince the optimization procedure is performed classically, the classical computation can impact the overall runtime. \n\n&quot;, &quot;Context&quot;: &quot;The best solution for a problem must be found or approximated across all possible solutions. \nAn individual solution can be evaluated by an objective function $C$ that is also given.  \nBy definition, this function is *faithful*, i.e, its minimum value indicates the best solution [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265). \nPreferably, $C$ is also *operationally meaningful* which means that solutions can be compared: smaller values of $C$ also indicate better solutions. \nSince the number of possible solutions increases exponentially with the size of the problems, it is too expensive in terms of computations to evaluate all possible solutions. \n\n&quot;, &quot;Solution&quot;: &quot;A hybrid setup is used to evaluate and optimize solutions. \nOn the quantum computer, an initial state is created that may also encode or be varied according to a set of input data $x$ (refer to the quantum circuit in the upper part of the solution sketch). \nOn this state, an ansatz $U(\\theta)$ is applied which is a circuit that depends on a set of parameters $\\theta$. \nThis results in the  $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$ state. \nA canonical example of an ansatz is to apply multiple one-qubit operations defining a rotation in the Bloch Sphere around a rotation angle that depends on $\\theta$.\nHowever, plenty of other parameterized circuits have been proposed as an ansatz. \nThen, based on the expectation values of the output state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$, the objective function $C$ for the parameter values $\\theta$ is calculated by the classical computer: \n\n\n$$\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\nC(\\theta)=\\sum_i f_i(\\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}})\n$$  \n\n\nwhere $O_i$ is the observable and $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}}$ the expectation value of the $i$-th measurement to which the function $f$ assigns an overall cost.\nIf $C(\\theta)$ is sufficiently low, i.e., the termination criteria are fulfilled, the algorithm ends. \nOtherwise, the parameter set $\\theta$ is optimized further for the next iteration. \n\n![](https://quantumcomputingpatterns.org/assets/sketches/variational_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;A plethora of algorithms make use of this pattern, e.g., in quantum machine learning this technique was used for developing quantum classifiers [(Mitarai et al. 2018)](https://arxiv.org/abs/1803.00745v3), \nas well as a quantum version of neural networks [(Farhi and Neven 2018)](https://arxiv.org/abs/1802.06002) or support vector machine [(HavlÃ­Äek et al. 2019)](https://www.nature.com/articles/s41586-019-0980-2), [(Schuld and Killoran 2019)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.040504). \nA variational algorithm for factorization has been presented in [(Anschuetz et al. 2018)](https://arxiv.org/abs/1808.08927). \n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n[Variational Quantum Eigensolver (QC-Atlas)](http://localhost/#/algorithms/379ec44e-1ce5-11eb-adf2-0242ac160002)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern is a refinement of [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf). \nWithin the quantum computation, [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf) is used.  \n \n&quot;}"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;\&quot;Optimize the parameters of a quantum circuit on a classical computer\&quot; [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)\n\n&quot;, &quot;Result&quot;: &quot;However, choosing $f$, the observables for measuring the qubits and an ansatz is not trivial.\nThe convergence of the algorithm depends on multiple factors: the objective function and the optimization strategy for updating the parameters. \nRegarding the objective function, one major obstacle for the convergence of the solution are regions of the function which contain only a small norm of the gradient (these regions are also referred to as *barren plateaus*). \nThese regions can significantly influence how fast the solution converges [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265) or in the worst case, result in non-convergence of the algorithm. \nSince the optimization procedure is performed classically, the classical computation can impact the overall runtime. \n\n&quot;, &quot;Context&quot;: &quot;The best solution for a problem must be found or approximated across all possible solutions. \nAn individual solution can be evaluated by an objective function $C$ that is also given.  \nBy definition, this function is *faithful*, i.e, its minimum value indicates the best solution [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265). \nPreferably, $C$ is also *operationally meaningful* which means that solutions can be compared: smaller values of $C$ also indicate better solutions. \nSince the number of possible solutions increases exponentially with the size of the problems, it is too expensive in terms of computations to evaluate all possible solutions. \n\n&quot;, &quot;Solution&quot;: &quot;A hybrid setup is used to evaluate and optimize solutions. \nOn the quantum computer, an initial state is created that may also encode or be varied according to a set of input data $x$ (refer to the quantum circuit in the upper part of the solution sketch). \nOn this state, an ansatz $U(\\theta)$ is applied which is a circuit that depends on a set of parameters $\\theta$. \nThis results in the  $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$ state. \nA canonical example of an ansatz is to apply multiple one-qubit operations defining a rotation in the Bloch Sphere around a rotation angle that depends on $\\theta$.\nHowever, plenty of other parameterized circuits have been proposed as an ansatz. \nThen, based on the expectation values of the output state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$, the objective function $C$ for the parameter values $\\theta$ is calculated by the classical computer: \n\n\n$$\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\nC(\\theta)=\\sum_i f_i(\\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}})\n$$  \n\n\nwhere $O_i$ is the observable and $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}}$ the expectation value of the $i$-th measurement to which the function $f$ assigns an overall cost.\nIf $C(\\theta)$ is sufficiently low, i.e., the termination criteria are fulfilled, the algorithm ends. \nOtherwise, the parameter set $\\theta$ is optimized further for the next iteration. \n\n![](https://quantumcomputingpatterns.org/assets/sketches/variational_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;A plethora of algorithms make use of this pattern, e.g., in quantum machine learning this technique was used for developing quantum classifiers [(Mitarai et al. 2018)](https://arxiv.org/abs/1803.00745v3), \nas well as a quantum version of neural networks [(Farhi and Neven 2018)](https://arxiv.org/abs/1802.06002) or support vector machine [(HavlÃ­Äek et al. 2019)](https://www.nature.com/articles/s41586-019-0980-2), [(Schuld and Killoran 2019)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.040504). \nA variational algorithm for factorization has been presented in [(Anschuetz et al. 2018)](https://arxiv.org/abs/1808.08927). \n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n[Variational Quantum Eigensolver (QC-Atlas)](http://localhost/#/algorithms/379ec44e-1ce5-11eb-adf2-0242ac160002)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern is a refinement of [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf). \nWithin the quantum computation, [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf) is used.  \n \n&quot;}"/>
            <where>id='bc795a9b-7977-4e01-b513-f9f5aba38aa7'</where>
        </update>
		<update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;Enter your input for this section here.&quot;, &quot;Intent&quot;: &quot;Encode data in a compact manner that do not require calculations&quot;, &quot;Result&quot;: &quot;The resulting encoding is a digital encoding and therefore suitable for arithmetic computations [(Leymann and Barzen 2020)](http://iopscience.iop.org/10.1088/2058-9565/abae7d). For input $n$ numbers that are approximated by $l$ digits, $l$ qubits are needed for this representation. Each of then encoded input values is represented by a basis vector with an amplitude of1ân.All other $2^{lân}$ amplitudes of the register are zero - in our example, $|000\\rangle$, $|001\\rangle$,$|100\\rangle$,$|101\\rangle$, and $|111\\rangle$. The amplitude vector is therefore often sparse for this encoding [(Schuld and Petruccione 2018)](http://dx.doi.org/10.1007/978-3-319-96424-9). &quot;, &quot;Context&quot;: &quot;A quantum algorithm requires multiple numerical values $X$ as input for further calculations.&quot;, &quot;Solution&quot;: &quot;Use a quantum associative memory (QuAM) to prepare a superposition of basis encoded values inthe same qubit register [(Leymann and Barzen 2020a)](http://iopscience.iop.org/10.1088/2058-9565/abae7d).  Note that the quantum register is an equally weighted superposition of the basis encoded values.\nBoth branches have a load and a storage part (see sketch). An additional element is first prepared into the loadpart of both branches. Next, the processing branch is split in such a manner, that the new element gets a properamplitude such that it can be brought into superposition with the already added elements. Finally, an [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc) cleans the processing branch to be ready for the next iteration (see [(Ventura and Martinez 2000)](https://www.sciencedirect.com/science/article/pii/S0020025599001012) for details. )\n\n![](https://quantumcomputingpatterns.org/assets/sketches/quam_solution.png)\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [Data Encoding Patterns for Quantum Algorithms.](https://hillside.net/plop/2020/papers/weigold.pdf) In: The Hillside Group (Hrsg): Proceedings of the 27th Conference on Pattern Languages of Programs (PLoP '20).&quot;, &quot;Variants&quot;: &quot;Enter your input for this section here.&quot;, &quot;Known Uses&quot;: &quot;The presented state preparation routine based on [(Ventura and Martinez 2000)](https://www.sciencedirect.com/science/article/pii/S0020025599001012) can be used whenever multiple data values need to be represented in  [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750). Shorâs algorithm [(Shor 1999)](https://epubs.siam.org/doi/abs/10.1137/S0036144598347011) for the factorization of prime numbers, a quantum version of the Fourier transform [(Coppersmith 2002)](http://arxiv.org/abs/quant-ph/0201067), and Groverâs algorithm [(Grover 1996)](http://dx.doi.org/10.1145/237814.237866) for unstructured search rely on this encoding. Various algorithms extend or use Groverâs algorithm and therefore also make use of this encoding.\n\n[Shor's Algorithm (QC-Atlas)](http://localhost/#/algorithms/b5df6c13-e619-496c-ada0-80fc3486f733)\n[Grover's Algorithm (QC-Atlas)](http://localhost/#/algorithms/0e5af2cf-f3c8-48dd-9743-cfdea65f320f)&quot;, &quot;Related Patterns&quot;: &quot;This pattern refines [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) and makes use of [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc).  [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) creates a superposition of all computational basis states. Each of the computational basis states also represents a value in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750).&quot;}"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;Enter your input for this section here.&quot;, &quot;Intent&quot;: &quot;Encode data in a compact manner that do not require calculations&quot;, &quot;Result&quot;: &quot;The resulting encoding is a digital encoding and therefore suitable for arithmetic computations [(Leymann and Barzen 2020)](http://iopscience.iop.org/10.1088/2058-9565/abae7d). For input $n$ numbers that are approximated by $l$ digits, $l$ qubits are needed for this representation. Each of then encoded input values is represented by a basis vector with an amplitude of1ân.All other $2^{lân}$ amplitudes of the register are zero - in our example, $|000\\rangle$, $|001\\rangle$,$|100\\rangle$,$|101\\rangle$, and $|111\\rangle$. The amplitude vector is therefore often sparse for this encoding [(Schuld and Petruccione 2018)](http://dx.doi.org/10.1007/978-3-319-96424-9). &quot;, &quot;Context&quot;: &quot;A quantum algorithm requires multiple numerical values $X$ as input for further calculations.&quot;, &quot;Solution&quot;: &quot;Use a quantum associative memory (QuAM) to prepare a superposition of basis encoded values inthe same qubit register [(Leymann and Barzen 2020a)](http://iopscience.iop.org/10.1088/2058-9565/abae7d).  Note that the quantum register is an equally weighted superposition of the basis encoded values.\nBoth branches have a load and a storage part (see sketch). An additional element is first prepared into the loadpart of both branches. Next, the processing branch is split in such a manner, that the new element gets a properamplitude such that it can be brought into superposition with the already added elements. Finally, an [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc) cleans the processing branch to be ready for the next iteration (see [(Ventura and Martinez 2000)](https://www.sciencedirect.com/science/article/pii/S0020025599001012) for details. )\n\n![](https://quantumcomputingpatterns.org/assets/sketches/quam_solution.png)\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [Data Encoding Patterns for Quantum Algorithms.](https://hillside.net/plop/2020/papers/weigold.pdf) In: The Hillside Group (Hrsg): Proceedings of the 27th Conference on Pattern Languages of Programs (PLoP '20).&quot;, &quot;Variants&quot;: &quot;Enter your input for this section here.&quot;, &quot;Known Uses&quot;: &quot;The presented state preparation routine based on [(Ventura and Martinez 2000)](https://www.sciencedirect.com/science/article/pii/S0020025599001012) can be used whenever multiple data values need to be represented in  [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750). Shorâs algorithm [(Shor 1999)](https://epubs.siam.org/doi/abs/10.1137/S0036144598347011) for the factorization of prime numbers, a quantum version of the Fourier transform [(Coppersmith 2002)](http://arxiv.org/abs/quant-ph/0201067), and Groverâs algorithm [(Grover 1996)](http://dx.doi.org/10.1145/237814.237866) for unstructured search rely on this encoding. Various algorithms extend or use Groverâs algorithm and therefore also make use of this encoding.\n\n[Shor's Algorithm (QC-Atlas)](http://localhost/#/algorithms/b5df6c13-e619-496c-ada0-80fc3486f733)\n[Grover's Algorithm (QC-Atlas)](http://localhost/#/algorithms/0e5af2cf-f3c8-48dd-9743-cfdea65f320f)&quot;, &quot;Related Patterns&quot;: &quot;This pattern refines [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) and makes use of [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc).  [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) creates a superposition of all computational basis states. Each of the computational basis states also represents a value in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750).&quot;}"/>
            <where>id='482714a7-8409-4165-93fe-72b02c2ae99c'</where>
        </update>
		<update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;This pattern has also been referred to as Black Box.&quot;, &quot;Intent&quot;: &quot;Re-use a computation of a quantum algorithm without necessarily knowing the implementation.&quot;, &quot;Result&quot;: &quot;Concrete implementations of oracles add to the overall depth to the overall quantum algorithm but are often neglected in the runtime of an oracle-based algorithm.  &quot;, &quot;Context&quot;: &quot;A Divide-and-Conquer approach is a commonly used method that simplifies solving a  complex problem.   \nIn such an approach, an oracle can be used as an reusable part of a quantum algorithm - a black blox with hidden internals.\nMultiple oracles can be used as building blocks to compose larger algorithms.&quot;, &quot;Solution&quot;: &quot;The concrete implementation of an oracle is highly problem-specific.\nAs a consequence, there are many different types of oracles, of which several are discussed in [(Gilyen et al. 2019)](https://epubs.siam.org/doi/abs/10.1137/1.9781611975482.87). &quot;, &quot;Variants&quot;: &quot;Enter your input for this section here.&quot;, &quot;Known Uses&quot;: &quot;Oracles are used in the algorithms of Deutsch, Deutsch-Jozsa, Bernstein-Vazirani,  Simon,  Grover, and many others. In [(Mosca 2008)](https://arxiv.org/abs/0808.0369), further usages are given.   \n\n[Shor's Algorithm (QC-Atlas)](http://localhost/#/algorithms/b5df6c13-e619-496c-ada0-80fc3486f733)\n[Grover's Algorithm (QC-Atlas)](http://localhost/#/algorithms/0e5af2cf-f3c8-48dd-9743-cfdea65f320f)\n[DÃ¼rr-HÃ¸yer Quantum Minimization Algorithm (PlanQK)](https://platform.planqk.de/algorithms/061f4eb3-d9ee-4f47-befc-9e242bf801ce/)\n[Deutsch algorithm (PlanQK)](https://platform.planqk.de/algorithms/533c90a5-5fbb-487b-b64d-a8f331aafb10/)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)&quot;, &quot;Related Patterns&quot;: &quot;An oracle requires correct [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) of the problem-specific input. \nTypically, an [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc) is used after an oracle was applied.&quot;}"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;This pattern has also been referred to as Black Box.&quot;, &quot;Intent&quot;: &quot;Re-use a computation of a quantum algorithm without necessarily knowing the implementation.&quot;, &quot;Result&quot;: &quot;Concrete implementations of oracles add to the overall depth to the overall quantum algorithm but are often neglected in the runtime of an oracle-based algorithm.  &quot;, &quot;Context&quot;: &quot;A Divide-and-Conquer approach is a commonly used method that simplifies solving a  complex problem.   \nIn such an approach, an oracle can be used as an reusable part of a quantum algorithm - a black blox with hidden internals.\nMultiple oracles can be used as building blocks to compose larger algorithms.&quot;, &quot;Solution&quot;: &quot;The concrete implementation of an oracle is highly problem-specific.\nAs a consequence, there are many different types of oracles, of which several are discussed in [(Gilyen et al. 2019)](https://epubs.siam.org/doi/abs/10.1137/1.9781611975482.87). &quot;, &quot;Variants&quot;: &quot;Enter your input for this section here.&quot;, &quot;Known Uses&quot;: &quot;Oracles are used in the algorithms of Deutsch, Deutsch-Jozsa, Bernstein-Vazirani,  Simon,  Grover, and many others. In [(Mosca 2008)](https://arxiv.org/abs/0808.0369), further usages are given.   \n\n[Shor's Algorithm (QC-Atlas)](http://localhost/#/algorithms/b5df6c13-e619-496c-ada0-80fc3486f733)\n[Grover's Algorithm (QC-Atlas)](http://localhost/#/algorithms/0e5af2cf-f3c8-48dd-9743-cfdea65f320f)\n[DÃ¼rr-HÃ¸yer Quantum Minimization Algorithm (PlanQK)](https://platform.planqk.de/algorithms/061f4eb3-d9ee-4f47-befc-9e242bf801ce/)\n[Deutsch algorithm (PlanQK)](https://platform.planqk.de/algorithms/533c90a5-5fbb-487b-b64d-a8f331aafb10/)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)&quot;, &quot;Related Patterns&quot;: &quot;An oracle requires correct [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) of the problem-specific input. \nTypically, an [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc) is used after an oracle was applied.&quot;}"/>
            <where>id='1cc7e9d6-ab37-412e-8afa-604a25de296e'</where>
        </update>
    </changeSet>
</databaseChangeLog>