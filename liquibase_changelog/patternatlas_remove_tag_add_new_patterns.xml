<?xml version="1.1" encoding="UTF-8" standalone="no"?>
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog" xmlns:ext="http://www.liquibase.org/xml/ns/dbchangelog-ext" xmlns:pro="http://www.liquibase.org/xml/ns/pro" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd http://www.liquibase.org/xml/ns/pro http://www.liquibase.org/xml/ns/pro/liquibase-pro-4.6.xsd http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.6.xsd">
    <changeSet author="PhilWun" id="1896454976140-1">
        <update tableName="pattern">
            <column name="tags" />
            <where>id = 'bc795a9b-7977-4e01-b513-f9f5aba38aa7'</where>
        </update>
        <insert tableName="pattern">
            <column name="id" value="7294c3f2-cb67-492a-8a16-c7384eb9bac2"/>
            <column name="name" value="KMeans"/>
            <column name="uri" value="https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/kmeans"/>
            <column name="content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;\&quot;Optimize the parameters of a quantum circuit on a classical computer\&quot; [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)\n\n&quot;, &quot;Result&quot;: &quot;However, choosing $f$, the observables for measuring the qubits and an ansatz is not trivial.\nThe convergence of the algorithm depends on multiple factors: the objective function and the optimization strategy for updating the parameters. \nRegarding the objective function, one major obstacle for the convergence of the solution are regions of the function which contain only a small norm of the gradient (these regions are also referred to as *barren plateaus*). \nThese regions can significantly influence how fast the solution converges [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265) or in the worst case, result in non-convergence of the algorithm. \nSince the optimization procedure is performed classically, the classical computation can impact the overall runtime. \n\n&quot;, &quot;Context&quot;: &quot;The best solution for a problem must be found or approximated across all possible solutions. \nAn individual solution can be evaluated by an objective function $C$ that is also given.  \nBy definition, this function is *faithful*, i.e, its minimum value indicates the best solution [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265). \nPreferably, $C$ is also *operationally meaningful* which means that solutions can be compared: smaller values of $C$ also indicate better solutions. \nSince the number of possible solutions increases exponentially with the size of the problems, it is too expensive in terms of computations to evaluate all possible solutions. \n\n&quot;, &quot;Solution&quot;: &quot;A hybrid setup is used to evaluate and optimize solutions. \nOn the quantum computer, an initial state is created that may also encode or be varied according to a set of input data $x$ (refer to the quantum circuit in the upper part of the solution sketch). \nOn this state, an ansatz $U(\\theta)$ is applied which is a circuit that depends on a set of parameters $\\theta$. \nThis results in the  $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$ state. \nA canonical example of an ansatz is to apply multiple one-qubit operations defining a rotation in the Bloch Sphere around a rotation angle that depends on $\\theta$.\nHowever, plenty of other parameterized circuits have been proposed as an ansatz. \nThen, based on the expectation values of the output state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$, the objective function $C$ for the parameter values $\\theta$ is calculated by the classical computer: \n\n\n$$\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\nC(\\theta)=\\sum_i f_i(\\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}})\n$$  \n\n\nwhere $O_i$ is the observable and $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}}$ the expectation value of the $i$-th measurement to which the function $f$ assigns an overall cost.\nIf $C(\\theta)$ is sufficiently low, i.e., the termination criteria are fulfilled, the algorithm ends. \nOtherwise, the parameter set $\\theta$ is optimized further for the next iteration. \n\n![](https://quantumcomputingpatterns.org/assets/sketches/variational_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;A plethora of algorithms make use of this pattern, e.g., in quantum machine learning this technique was used for developing quantum classifiers [(Mitarai et al. 2018)](https://arxiv.org/abs/1803.00745v3), \nas well as a quantum version of neural networks [(Farhi and Neven 2018)](https://arxiv.org/abs/1802.06002) or support vector machine [(Havlíček et al. 2019)](https://www.nature.com/articles/s41586-019-0980-2), [(Schuld and Killoran 2019)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.040504). \nA variational algorithm for factorization has been presented in [(Anschuetz et al. 2018)](https://arxiv.org/abs/1808.08927). \n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n[Variational Quantum Eigensolver (PlanQK)](https://platform.planqk.de/algorithms/28fbfa6b-329b-4d99-8c75-f9dbdd365a4f/)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern is a refinement of [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf). \nWithin the quantum computation, [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf) is used.  \n \n&quot;}"/>
            <column name="icon_url" value="https://quantumcomputingpatterns.org/assets/pattern-icons/kmeans_icon.png"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;\&quot;Optimize the parameters of a quantum circuit on a classical computer\&quot; [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)\n\n&quot;, &quot;Result&quot;: &quot;However, choosing $f$, the observables for measuring the qubits and an ansatz is not trivial.\nThe convergence of the algorithm depends on multiple factors: the objective function and the optimization strategy for updating the parameters. \nRegarding the objective function, one major obstacle for the convergence of the solution are regions of the function which contain only a small norm of the gradient (these regions are also referred to as *barren plateaus*). \nThese regions can significantly influence how fast the solution converges [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265) or in the worst case, result in non-convergence of the algorithm. \nSince the optimization procedure is performed classically, the classical computation can impact the overall runtime. \n\n&quot;, &quot;Context&quot;: &quot;The best solution for a problem must be found or approximated across all possible solutions. \nAn individual solution can be evaluated by an objective function $C$ that is also given.  \nBy definition, this function is *faithful*, i.e, its minimum value indicates the best solution [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265). \nPreferably, $C$ is also *operationally meaningful* which means that solutions can be compared: smaller values of $C$ also indicate better solutions. \nSince the number of possible solutions increases exponentially with the size of the problems, it is too expensive in terms of computations to evaluate all possible solutions. \n\n&quot;, &quot;Solution&quot;: &quot;A hybrid setup is used to evaluate and optimize solutions. \nOn the quantum computer, an initial state is created that may also encode or be varied according to a set of input data $x$ (refer to the quantum circuit in the upper part of the solution sketch). \nOn this state, an ansatz $U(\\theta)$ is applied which is a circuit that depends on a set of parameters $\\theta$. \nThis results in the  $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$ state. \nA canonical example of an ansatz is to apply multiple one-qubit operations defining a rotation in the Bloch Sphere around a rotation angle that depends on $\\theta$.\nHowever, plenty of other parameterized circuits have been proposed as an ansatz. \nThen, based on the expectation values of the output state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$, the objective function $C$ for the parameter values $\\theta$ is calculated by the classical computer: \n\n\n$$\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\nC(\\theta)=\\sum_i f_i(\\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}})\n$$  \n\n\nwhere $O_i$ is the observable and $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}}$ the expectation value of the $i$-th measurement to which the function $f$ assigns an overall cost.\nIf $C(\\theta)$ is sufficiently low, i.e., the termination criteria are fulfilled, the algorithm ends. \nOtherwise, the parameter set $\\theta$ is optimized further for the next iteration. \n\n![](https://quantumcomputingpatterns.org/assets/sketches/variational_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;A plethora of algorithms make use of this pattern, e.g., in quantum machine learning this technique was used for developing quantum classifiers [(Mitarai et al. 2018)](https://arxiv.org/abs/1803.00745v3), \nas well as a quantum version of neural networks [(Farhi and Neven 2018)](https://arxiv.org/abs/1802.06002) or support vector machine [(Havlíček et al. 2019)](https://www.nature.com/articles/s41586-019-0980-2), [(Schuld and Killoran 2019)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.040504). \nA variational algorithm for factorization has been presented in [(Anschuetz et al. 2018)](https://arxiv.org/abs/1808.08927). \n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n[Variational Quantum Eigensolver (PlanQK)](https://platform.planqk.de/algorithms/28fbfa6b-329b-4d99-8c75-f9dbdd365a4f/)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern is a refinement of [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf). \nWithin the quantum computation, [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf) is used.  \n \n&quot;}"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="paper_ref" value="Weigold, M.; Barzen, J.; Leymann, F.; and Vietz, D: Patterns For Hybrid Quantum Algorithms. In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021), https://doi.org/10.1007/978-3-030-87568-8_2"/>
            <column name="deployment_modeling_behavior_pattern"/>
            <column name="deployment_modeling_structure_pattern"/>
            <column name="tags" value="algorithm"/>
        </insert>
        <insert tableName="pattern">
            <column name="id" value="cc3731cf-ecbb-490f-b996-525c8f60d8a9"/>
            <column name="name" value="Quantum Support Vector Machine (QSVM)"/>
            <column name="uri" value="https://patternpedia.org/patternLanguages/reformulatedQuantumComputingPatterns/quantumSupportVectorMachine_qsvm"/>
            <column name="content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;\&quot;Optimize the parameters of a quantum circuit on a classical computer\&quot; [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)\n\n&quot;, &quot;Result&quot;: &quot;However, choosing $f$, the observables for measuring the qubits and an ansatz is not trivial.\nThe convergence of the algorithm depends on multiple factors: the objective function and the optimization strategy for updating the parameters. \nRegarding the objective function, one major obstacle for the convergence of the solution are regions of the function which contain only a small norm of the gradient (these regions are also referred to as *barren plateaus*). \nThese regions can significantly influence how fast the solution converges [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265) or in the worst case, result in non-convergence of the algorithm. \nSince the optimization procedure is performed classically, the classical computation can impact the overall runtime. \n\n&quot;, &quot;Context&quot;: &quot;The best solution for a problem must be found or approximated across all possible solutions. \nAn individual solution can be evaluated by an objective function $C$ that is also given.  \nBy definition, this function is *faithful*, i.e, its minimum value indicates the best solution [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265). \nPreferably, $C$ is also *operationally meaningful* which means that solutions can be compared: smaller values of $C$ also indicate better solutions. \nSince the number of possible solutions increases exponentially with the size of the problems, it is too expensive in terms of computations to evaluate all possible solutions. \n\n&quot;, &quot;Solution&quot;: &quot;A hybrid setup is used to evaluate and optimize solutions. \nOn the quantum computer, an initial state is created that may also encode or be varied according to a set of input data $x$ (refer to the quantum circuit in the upper part of the solution sketch). \nOn this state, an ansatz $U(\\theta)$ is applied which is a circuit that depends on a set of parameters $\\theta$. \nThis results in the  $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$ state. \nA canonical example of an ansatz is to apply multiple one-qubit operations defining a rotation in the Bloch Sphere around a rotation angle that depends on $\\theta$.\nHowever, plenty of other parameterized circuits have been proposed as an ansatz. \nThen, based on the expectation values of the output state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$, the objective function $C$ for the parameter values $\\theta$ is calculated by the classical computer: \n\n\n$$\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\nC(\\theta)=\\sum_i f_i(\\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}})\n$$  \n\n\nwhere $O_i$ is the observable and $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}}$ the expectation value of the $i$-th measurement to which the function $f$ assigns an overall cost.\nIf $C(\\theta)$ is sufficiently low, i.e., the termination criteria are fulfilled, the algorithm ends. \nOtherwise, the parameter set $\\theta$ is optimized further for the next iteration. \n\n![](https://quantumcomputingpatterns.org/assets/sketches/variational_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;A plethora of algorithms make use of this pattern, e.g., in quantum machine learning this technique was used for developing quantum classifiers [(Mitarai et al. 2018)](https://arxiv.org/abs/1803.00745v3), \nas well as a quantum version of neural networks [(Farhi and Neven 2018)](https://arxiv.org/abs/1802.06002) or support vector machine [(Havlíček et al. 2019)](https://www.nature.com/articles/s41586-019-0980-2), [(Schuld and Killoran 2019)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.040504). \nA variational algorithm for factorization has been presented in [(Anschuetz et al. 2018)](https://arxiv.org/abs/1808.08927). \n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n[Variational Quantum Eigensolver (PlanQK)](https://platform.planqk.de/algorithms/28fbfa6b-329b-4d99-8c75-f9dbdd365a4f/)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern is a refinement of [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf). \nWithin the quantum computation, [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf) is used.  \n \n&quot;}"/>
            <column name="icon_url" value="https://quantumcomputingpatterns.org/assets/pattern-icons/qsvm_icon.png"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;\&quot;Optimize the parameters of a quantum circuit on a classical computer\&quot; [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)\n\n&quot;, &quot;Result&quot;: &quot;However, choosing $f$, the observables for measuring the qubits and an ansatz is not trivial.\nThe convergence of the algorithm depends on multiple factors: the objective function and the optimization strategy for updating the parameters. \nRegarding the objective function, one major obstacle for the convergence of the solution are regions of the function which contain only a small norm of the gradient (these regions are also referred to as *barren plateaus*). \nThese regions can significantly influence how fast the solution converges [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265) or in the worst case, result in non-convergence of the algorithm. \nSince the optimization procedure is performed classically, the classical computation can impact the overall runtime. \n\n&quot;, &quot;Context&quot;: &quot;The best solution for a problem must be found or approximated across all possible solutions. \nAn individual solution can be evaluated by an objective function $C$ that is also given.  \nBy definition, this function is *faithful*, i.e, its minimum value indicates the best solution [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265). \nPreferably, $C$ is also *operationally meaningful* which means that solutions can be compared: smaller values of $C$ also indicate better solutions. \nSince the number of possible solutions increases exponentially with the size of the problems, it is too expensive in terms of computations to evaluate all possible solutions. \n\n&quot;, &quot;Solution&quot;: &quot;A hybrid setup is used to evaluate and optimize solutions. \nOn the quantum computer, an initial state is created that may also encode or be varied according to a set of input data $x$ (refer to the quantum circuit in the upper part of the solution sketch). \nOn this state, an ansatz $U(\\theta)$ is applied which is a circuit that depends on a set of parameters $\\theta$. \nThis results in the  $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$ state. \nA canonical example of an ansatz is to apply multiple one-qubit operations defining a rotation in the Bloch Sphere around a rotation angle that depends on $\\theta$.\nHowever, plenty of other parameterized circuits have been proposed as an ansatz. \nThen, based on the expectation values of the output state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$, the objective function $C$ for the parameter values $\\theta$ is calculated by the classical computer: \n\n\n$$\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\nC(\\theta)=\\sum_i f_i(\\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}})\n$$  \n\n\nwhere $O_i$ is the observable and $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}}$ the expectation value of the $i$-th measurement to which the function $f$ assigns an overall cost.\nIf $C(\\theta)$ is sufficiently low, i.e., the termination criteria are fulfilled, the algorithm ends. \nOtherwise, the parameter set $\\theta$ is optimized further for the next iteration. \n\n![](https://quantumcomputingpatterns.org/assets/sketches/variational_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;A plethora of algorithms make use of this pattern, e.g., in quantum machine learning this technique was used for developing quantum classifiers [(Mitarai et al. 2018)](https://arxiv.org/abs/1803.00745v3), \nas well as a quantum version of neural networks [(Farhi and Neven 2018)](https://arxiv.org/abs/1802.06002) or support vector machine [(Havlíček et al. 2019)](https://www.nature.com/articles/s41586-019-0980-2), [(Schuld and Killoran 2019)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.040504). \nA variational algorithm for factorization has been presented in [(Anschuetz et al. 2018)](https://arxiv.org/abs/1808.08927). \n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n[Variational Quantum Eigensolver (PlanQK)](https://platform.planqk.de/algorithms/28fbfa6b-329b-4d99-8c75-f9dbdd365a4f/)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern is a refinement of [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf). \nWithin the quantum computation, [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf) is used.  \n \n&quot;}"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="paper_ref" value="Weigold, M.; Barzen, J.; Leymann, F.; and Vietz, D: Patterns For Hybrid Quantum Algorithms. In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021), https://doi.org/10.1007/978-3-030-87568-8_2"/>
            <column name="deployment_modeling_behavior_pattern"/>
            <column name="deployment_modeling_structure_pattern"/>
            <column name="tags" value="algorithm"/>
        </insert>
    </changeSet>
</databaseChangeLog>
