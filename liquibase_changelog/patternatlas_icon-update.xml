<?xml version="1.1" encoding="UTF-8" standalone="no"?>
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog" xmlns:ext="http://www.liquibase.org/xml/ns/dbchangelog-ext" xmlns:pro="http://www.liquibase.org/xml/ns/pro" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd http://www.liquibase.org/xml/ns/pro http://www.liquibase.org/xml/ns/pro/liquibase-pro-latest.xsd http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-latest.xsd">
    <changeSet author="marvin (generated)" id="1698913867280-355"> 
        <update tableName="pattern">
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/equal_superposition_icon.png"/>
            <where>id='2229a430-fe92-4411-9d72-d10dd1d8da14'</where>
        </update>
        <update tableName="pattern">
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/matrix_encoding_icon.png"/>
            <where>id='45d09c54-3f4a-453b-885d-2772443c8d72'</where>
        </update>
        <update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;This pattern has also been referred to as Qubit Encoding [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420) since each qubit represents a single data point.\nThe resulting encoding of this pattern is not entangled, thus, another alias for this pattern is (Tensor) Product Encoding [(Leymann and Barzen 2020)](https://iopscience.iop.org/article/10.1088/2058-9565/abae7d). \n\n&quot;, &quot;Intent&quot;: &quot;\&quot;Represent each data point by a separate qubit\&quot; [(Weigold et al. 2021)](https://ieeexplore.ieee.org/document/9425837/)\n\n&quot;, &quot;Result&quot;: &quot;This creates the following separable state ([Weigold et al. 2021](https://ieeexplore.ieee.org/document/9425837/)): \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\n  \\state{\\psi} = \\bigColVec{\\cos{x_0} \\\\ \\sin{x_0}} \n  \\otimes \\bigColVec{\\cos{x_1} \\\\ \\sin{x_1}} \n  \\otimes \\ldots \n  \\otimes \\bigColVec{\\cos{x_n} \\\\ \\sin{x_n}}\n$$  \n\n\nIt can easily be seen that one qubit is needed per data point which is not optimal. To load the data, the rotations on the qubits can be performed in parallel, thus, the depth of the circuit is optimal. \n\n&quot;, &quot;Context&quot;: &quot;In the current NISQ era, an algorithm requires an encoding schema that is efficient in terms of operations. \nThis enables to perform more operations within the decoherence time after encoding the data. \n\n&quot;, &quot;Solution&quot;: &quot;As a first step, each data point of the input is normalized to the interval $[0,\\frac{\\pi}{2}]$.\nTo encode the data points, a rotation around the y-axis is used (see solution sketch) for which the angle depends on the value of the normalized data point. \n\n![sketch](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/angle_encoding_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [“Expanding Data Encoding Patterns For Quantum Algorithms.”](https://ieeexplore.ieee.org/document/9425837/) In: 2021 IEEE 18th International Conference on Software Architecture Companion (ICSA-C), IEEE, 2021.\n&quot;, &quot;Variants&quot;: &quot;A variant of this pattern is presented in [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420) where the relative phase, another property of qubits, is exploited to produce a more dense encoding which requires only half of the qubits to encode the same amount of data points. \n\n&quot;, &quot;Known Uses&quot;: &quot;A classification algorithm based on the encoding of this pattern can be found in [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420) and [(Grant et al. 2018)](https://www.nature.com/articles/s41534-018-0116-9). \nAdditionally, this encoding has been applied in quantum image processing: \nHere, angle encoding is used to represent a pixel's color information in the flexible representation of quantum image (FRQI) while the position is represented by an additional register [(Yan, Iliyasu and Venegas-Andraca 2015)](https://link.springer.com/content/pdf/10.1007/s11128-015-1195-6.pdf).\nFor quantum neural networks, a so-called quantum neuron (quron) makes use of this encoding [(Schuld, Sinayskiy and Petruccione 2014)](https://link.springer.com/article/10.1007/s11128-014-0809-8).\nA state preparation routine to create this encoding is provided by  [PennyLane](https://pennylane.readthedocs.io/en/stable/introduction/templates.html) where a rotation on the axis x, y, or z can be chosen. \nSince the state preparation is straightforward (see solution sketch), this encoding can easily be implemented using default qubit rotations [(Leymann and Barzen 2020)](https://iopscience.iop.org/article/10.1088/2058-9565/abae7d).\n\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n&quot;, &quot;Related Patterns&quot;: &quot;As this pattern provides a concrete encoding strategy, it specifies [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d).\n\n&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/angle_encoding_icon.png"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;This pattern has also been referred to as Qubit Encoding [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420) since each qubit represents a single data point.\nThe resulting encoding of this pattern is not entangled, thus, another alias for this pattern is (Tensor) Product Encoding [(Leymann and Barzen 2020)](https://iopscience.iop.org/article/10.1088/2058-9565/abae7d). \n\n&quot;, &quot;Intent&quot;: &quot;\&quot;Represent each data point by a separate qubit\&quot; [(Weigold et al. 2021)](https://ieeexplore.ieee.org/document/9425837/)\n\n&quot;, &quot;Result&quot;: &quot;This creates the following separable state ([Weigold et al. 2021](https://ieeexplore.ieee.org/document/9425837/)): \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\n  \\state{\\psi} = \\bigColVec{\\cos{x_0} \\\\ \\sin{x_0}} \n  \\otimes \\bigColVec{\\cos{x_1} \\\\ \\sin{x_1}} \n  \\otimes \\ldots \n  \\otimes \\bigColVec{\\cos{x_n} \\\\ \\sin{x_n}}\n$$  \n\n\nIt can easily be seen that one qubit is needed per data point which is not optimal. To load the data, the rotations on the qubits can be performed in parallel, thus, the depth of the circuit is optimal. \n\n&quot;, &quot;Context&quot;: &quot;In the current NISQ era, an algorithm requires an encoding schema that is efficient in terms of operations. \nThis enables to perform more operations within the decoherence time after encoding the data. \n\n&quot;, &quot;Solution&quot;: &quot;As a first step, each data point of the input is normalized to the interval $[0,\\frac{\\pi}{2}]$.\nTo encode the data points, a rotation around the y-axis is used (see solution sketch) for which the angle depends on the value of the normalized data point. \n\n![sketch](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/angle_encoding_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [“Expanding Data Encoding Patterns For Quantum Algorithms.”](https://ieeexplore.ieee.org/document/9425837/) In: 2021 IEEE 18th International Conference on Software Architecture Companion (ICSA-C), IEEE, 2021.\n&quot;, &quot;Variants&quot;: &quot;A variant of this pattern is presented in [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420) where the relative phase, another property of qubits, is exploited to produce a more dense encoding which requires only half of the qubits to encode the same amount of data points. \n\n&quot;, &quot;Known Uses&quot;: &quot;A classification algorithm based on the encoding of this pattern can be found in [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420) and [(Grant et al. 2018)](https://www.nature.com/articles/s41534-018-0116-9). \nAdditionally, this encoding has been applied in quantum image processing: \nHere, angle encoding is used to represent a pixel's color information in the flexible representation of quantum image (FRQI) while the position is represented by an additional register [(Yan, Iliyasu and Venegas-Andraca 2015)](https://link.springer.com/content/pdf/10.1007/s11128-015-1195-6.pdf).\nFor quantum neural networks, a so-called quantum neuron (quron) makes use of this encoding [(Schuld, Sinayskiy and Petruccione 2014)](https://link.springer.com/article/10.1007/s11128-014-0809-8).\nA state preparation routine to create this encoding is provided by  [PennyLane](https://pennylane.readthedocs.io/en/stable/introduction/templates.html) where a rotation on the axis x, y, or z can be chosen. \nSince the state preparation is straightforward (see solution sketch), this encoding can easily be implemented using default qubit rotations [(Leymann and Barzen 2020)](https://iopscience.iop.org/article/10.1088/2058-9565/abae7d).\n\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n&quot;, &quot;Related Patterns&quot;: &quot;As this pattern provides a concrete encoding strategy, it specifies [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d).\n\n&quot;}"/>
            <where>id='e595558d-bfea-4b82-9f47-a38a2097b245'</where>
        </update>
        <update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;Prepare an arbitrary state&quot;, &quot;Result&quot;: &quot;The state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{s}$ is created in the register. For this state, the Schmidt coefficients $\\alpha_i$ are known which can be used to quantify entanglement [[Nielsen and Chuang 2002](https://doi.org/10.1119/1.1463744)]. The state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{s}$ is separable if and only if exactly one of the Schmidt coefficients is non-zero. \nIn the worst case, the depth of the circuit is exponential (more precisely: $\\frac{23}{48} 2^n$ [[Plesch and Brukner 2011](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.83.032302)]).Note that arbitrary state preparation was shown to be of exponential complexity, i.e., a circuit of exponential depth will always be needed in the worst case. &quot;, &quot;Context&quot;: &quot;A state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{s}$ has to be prepared on an empty $n$-qubit register. If no state preparation method is known that exploits the structure of this state to prepare it efficiently, a method for creating an arbitrary state can be used instead.&quot;, &quot;Solution&quot;: &quot;To generate a circuit for the creation of $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{s}$, it first needs to be expressed in terms of two subspaces $V$ and $W$ that span $H^{\\otimes n}$. First, orthogonal basis $\\{f_1, \\ldots, f_k\\}\\in V$ and $\\{g_1, \\ldots, g_k\\}\\in W$ are chosen and $\\ket{s}$ is represented as a linear combination of these basis vectors:\n$$\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{s}=\\sum_{i, j} b_{ij} \\cdot f_i \\otimes g_j $$\nThen, the singular value decomposition (SVD) of the matrix ${M = \\{ b_{ij} \\}}$ is computed (see [[Olver et al. 2006](https://www.springer.com/gp/book/9783319910406)] for detailed instructions): \n $$M= \\left( \\begin{matrix}U_1 U_2 \\end{matrix} \\right)\n \\left( \\begin{matrix}A \\\\ 0 \\end{matrix} \\right) V^* $$\nwhere the matrix $U$ obtained by the SVD is rewritten by $U_1$ and $U_2$. The entries of the diagonal matrix $A$ build the set $\\{\\alpha_1, \\ldots \\alpha_m\\}$ which defines the _Schmidt decomposition_ of $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{s}$: \n$$\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{s}=\\sum_{i=1}^{m} \\alpha_{i} \\cdot u_i \\otimes v_i, \\alpha_{i} \\in \\mathbb{R} \\geq 0, \\text{where} \\sum_{i=1}^{m} \\alpha_{i} = 1 $$\nwhere $\\alpha_{1}, \\ldots ,\\alpha_{m}$ are the _Schmidt coefficients_ for the _Schmidt basis_ $\\{u_i\\}$, $\\{v_i\\}$. \nThe circuit in the pattern sketch can be used to prepare $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{s}$ on an empty register [[Abhijith et al. 2018](https://arxiv.org/abs/1804.03719v2)]: First, $B$ transforms the amplitude of the first register to the Schmidt coefficients. \nThen, a series of CNOT operations copies this state to the second register. Finally, $U_1$ and $V$ transform the computational basis states $\\{e_i\\}$ into the Schmidt basis states: \n$$(U_1 \\otimes V) \\sum_{i=1}^{m} \\alpha_i \\cdot e_i \\otimes$$\nFor the execution on a quantum computer, the unitary matrices must be further decomposed into one and two qubit gates.&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;This pattern can be used to create random states with a controlled amount of entanglement [[Daskin et al.](https://www.worldscientific.com/doi/abs/10.1142/S0219749914500300)]. An implementation in Mathematica was provided in [Iten et al. 2019](https://arxiv.org/abs/1904.01072).&quot;, &quot;Related Patterns&quot;: &quot;This pattern refines [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d), and can be used as a state preparation method for [Amplitude](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/502147ec-45fa-403f-8f52-e196b3359399) or [QRAM Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13).&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/schmidt_icon.png"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;Prepare an arbitrary state&quot;, &quot;Result&quot;: &quot;The state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{s}$ is created in the register. For this state, the Schmidt coefficients $\\alpha_i$ are known which can be used to quantify entanglement [[Nielsen and Chuang 2002](https://doi.org/10.1119/1.1463744)]. The state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{s}$ is separable if and only if exactly one of the Schmidt coefficients is non-zero. \nIn the worst case, the depth of the circuit is exponential (more precisely: $\\frac{23}{48} 2^n$ [[Plesch and Brukner 2011](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.83.032302)]).Note that arbitrary state preparation was shown to be of exponential complexity, i.e., a circuit of exponential depth will always be needed in the worst case. &quot;, &quot;Context&quot;: &quot;A state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{s}$ has to be prepared on an empty $n$-qubit register. If no state preparation method is known that exploits the structure of this state to prepare it efficiently, a method for creating an arbitrary state can be used instead.&quot;, &quot;Solution&quot;: &quot;To generate a circuit for the creation of $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{s}$, it first needs to be expressed in terms of two subspaces $V$ and $W$ that span $H^{\\otimes n}$. First, orthogonal basis $\\{f_1, \\ldots, f_k\\}\\in V$ and $\\{g_1, \\ldots, g_k\\}\\in W$ are chosen and $\\ket{s}$ is represented as a linear combination of these basis vectors:\n$$\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{s}=\\sum_{i, j} b_{ij} \\cdot f_i \\otimes g_j $$\nThen, the singular value decomposition (SVD) of the matrix ${M = \\{ b_{ij} \\}}$ is computed (see [[Olver et al. 2006](https://www.springer.com/gp/book/9783319910406)] for detailed instructions): \n $$M= \\left( \\begin{matrix}U_1 U_2 \\end{matrix} \\right)\n \\left( \\begin{matrix}A \\\\ 0 \\end{matrix} \\right) V^* $$\nwhere the matrix $U$ obtained by the SVD is rewritten by $U_1$ and $U_2$. The entries of the diagonal matrix $A$ build the set $\\{\\alpha_1, \\ldots \\alpha_m\\}$ which defines the _Schmidt decomposition_ of $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{s}$: \n$$\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{s}=\\sum_{i=1}^{m} \\alpha_{i} \\cdot u_i \\otimes v_i, \\alpha_{i} \\in \\mathbb{R} \\geq 0, \\text{where} \\sum_{i=1}^{m} \\alpha_{i} = 1 $$\nwhere $\\alpha_{1}, \\ldots ,\\alpha_{m}$ are the _Schmidt coefficients_ for the _Schmidt basis_ $\\{u_i\\}$, $\\{v_i\\}$. \nThe circuit in the pattern sketch can be used to prepare $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{s}$ on an empty register [[Abhijith et al. 2018](https://arxiv.org/abs/1804.03719v2)]: First, $B$ transforms the amplitude of the first register to the Schmidt coefficients. \nThen, a series of CNOT operations copies this state to the second register. Finally, $U_1$ and $V$ transform the computational basis states $\\{e_i\\}$ into the Schmidt basis states: \n$$(U_1 \\otimes V) \\sum_{i=1}^{m} \\alpha_i \\cdot e_i \\otimes$$\nFor the execution on a quantum computer, the unitary matrices must be further decomposed into one and two qubit gates.&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;This pattern can be used to create random states with a controlled amount of entanglement [[Daskin et al.](https://www.worldscientific.com/doi/abs/10.1142/S0219749914500300)]. An implementation in Mathematica was provided in [Iten et al. 2019](https://arxiv.org/abs/1904.01072).&quot;, &quot;Related Patterns&quot;: &quot;This pattern refines [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d), and can be used as a state preparation method for [Amplitude](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/502147ec-45fa-403f-8f52-e196b3359399) or [QRAM Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13).&quot;}"/>
            <where>id='4437fb83-34c0-47a8-8c6f-1272a76b76bb'</where>
        </update>
        <update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;Enter your input for this section here.&quot;, &quot;Intent&quot;: &quot;Represent data elements in a quantum computer in order to perform calculations&quot;, &quot;Result&quot;: &quot;This encoding can be categorized as digital encoding because it is suitable for arithmetic computations [Leymann and Barzen 2020](http://iopscience.iop.org/10.1088/2058-9565/abae7d). For input numbers which are approximated by $l$ digits, $l$ qubits are needed for its representation. To realize this encoding, the initial $|0\\rangle$ state of qubits that represent a ’1’ digit must be flipped into $|1\\rangle$. For one qubit, this can be done by a single operation, and thus, this encoding can be prepared in linear time.&quot;, &quot;Context&quot;: &quot;A quantum algorithm requires numerical input data $X$ for further calculations&quot;, &quot;Solution&quot;: &quot;The main idea for this encoding is to use the computational basis $|0...00\\rangle, |0...01\\rangle, \\ldots, |1...11\\rangle$ to encode the input data:  An input number $x$ is approximated by a binary format $x := b_{n-1}\\ldots b_1 b_0$ which is then turned into the corresponding basis vector $|x \\rangle:=|b_{n-1} \\ldots b_1 b_0\\rangle$.  For example, the number \\\&quot;2\\\&quot; is represented as $10$ which is then encoded by $|10\\rangle$ (see sketch). In general, this leads to the following encoding: $X \\approx \\sum_{i=-k}^m b_{i} 2^i \\mapsto | b_m \\ldots b_{-k} \\rangle$ where $X$ is first approximated  with a precision of $k$ significant digits and then represented by a basis vector. \n\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/basis_encoding_solution.png)  \n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [Data Encoding Patterns for Quantum Algorithms.](https://hillside.net/plop/2020/papers/weigold.pdf) In: The Hillside Group (Hrsg): Proceedings of the 27th Conference on Pattern Languages of Programs (PLoP '20).&quot;, &quot;Variants&quot;: &quot;Enter your input for this section here.&quot;, &quot;Known Uses&quot;: &quot;[(Vedral et al. 1996)](http://dx.doi.org/10.1103/PhysRevA.54.147) give multiple examples for algorithms that perform arithmetic operations on numbers in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750). A formal description of the solution above is also given in [(Leymann and Barzen 2020)](http://iopscience.iop.org/10.1088/2058-9565/abae7d) and [(Cortese and Braje 2018)](https://arxiv.org/abs/1803.01958). As only one quantum gate is needed to obtain this encoding, this state preparation routine can be implemented straightforwardly.&quot;, &quot;Related Patterns&quot;: &quot;This pattern is a refinement of [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d). If an algorithm requires several numbers as input, each can be encoded in BASIC ENCODING which can be processed by the [Quantum Associative Memory (QuAM)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/482714a7-8409-4165-93fe-72b02c2ae99c) pattern.&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/basis_encoding_icon.png"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;Enter your input for this section here.&quot;, &quot;Intent&quot;: &quot;Represent data elements in a quantum computer in order to perform calculations&quot;, &quot;Result&quot;: &quot;This encoding can be categorized as digital encoding because it is suitable for arithmetic computations [Leymann and Barzen 2020](http://iopscience.iop.org/10.1088/2058-9565/abae7d). For input numbers which are approximated by $l$ digits, $l$ qubits are needed for its representation. To realize this encoding, the initial $|0\\rangle$ state of qubits that represent a ’1’ digit must be flipped into $|1\\rangle$. For one qubit, this can be done by a single operation, and thus, this encoding can be prepared in linear time.&quot;, &quot;Context&quot;: &quot;A quantum algorithm requires numerical input data $X$ for further calculations&quot;, &quot;Solution&quot;: &quot;The main idea for this encoding is to use the computational basis $|0...00\\rangle, |0...01\\rangle, \\ldots, |1...11\\rangle$ to encode the input data:  An input number $x$ is approximated by a binary format $x := b_{n-1}\\ldots b_1 b_0$ which is then turned into the corresponding basis vector $|x \\rangle:=|b_{n-1} \\ldots b_1 b_0\\rangle$.  For example, the number \\\&quot;2\\\&quot; is represented as $10$ which is then encoded by $|10\\rangle$ (see sketch). In general, this leads to the following encoding: $X \\approx \\sum_{i=-k}^m b_{i} 2^i \\mapsto | b_m \\ldots b_{-k} \\rangle$ where $X$ is first approximated  with a precision of $k$ significant digits and then represented by a basis vector. \n\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/basis_encoding_solution.png)  \n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [Data Encoding Patterns for Quantum Algorithms.](https://hillside.net/plop/2020/papers/weigold.pdf) In: The Hillside Group (Hrsg): Proceedings of the 27th Conference on Pattern Languages of Programs (PLoP '20).&quot;, &quot;Variants&quot;: &quot;Enter your input for this section here.&quot;, &quot;Known Uses&quot;: &quot;[(Vedral et al. 1996)](http://dx.doi.org/10.1103/PhysRevA.54.147) give multiple examples for algorithms that perform arithmetic operations on numbers in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750). A formal description of the solution above is also given in [(Leymann and Barzen 2020)](http://iopscience.iop.org/10.1088/2058-9565/abae7d) and [(Cortese and Braje 2018)](https://arxiv.org/abs/1803.01958). As only one quantum gate is needed to obtain this encoding, this state preparation routine can be implemented straightforwardly.&quot;, &quot;Related Patterns&quot;: &quot;This pattern is a refinement of [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d). If an algorithm requires several numbers as input, each can be encoded in BASIC ENCODING which can be processed by the [Quantum Associative Memory (QuAM)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/482714a7-8409-4165-93fe-72b02c2ae99c) pattern.&quot;}"/>
            <where>id='bcd4c7a1-3c92-4f8c-a530-72b8b95d3750'</where>
        </update>
        <update tableName="pattern">
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/entanglement_icon.png"/>
            <where>id='3d1f3991-df47-4d42-8f9a-e6dcf4e3ccec'</where>
        </update>
        <update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;Enter your input for this section here.&quot;, &quot;Forces&quot;: &quot;Quantum devices unavoidably cause a certain amount of errors due to the fragility of coherent quantum states [[Devitt et al. 2013](https://iopscience.iop.org/article/10.1088/0034-4885/76/7/076001/meta)]. Furthermore, contrary to classical bits, qubits can not be copied. Hence, classical error correction can\nnot be used for quantum computers and new quantum-specific methods need to be developed. However, these methods can be costly in terms of quantum resources, as they require a large number of additional qubits and quantum gates.\nTo enable scalable quantum computing for real-world problems, all kinds of errors occurring in quantum devices need to be detected and corrected. In general, the correction of errors is preferred over their mitigation, since even minor remaining post-mitigation errors slowly stack up during the computation and ultimately lead to an imprecise result.&quot;, &quot;Intent&quot;: &quot;How to detect and correct errors occurring during the execution of a quantum circuit?&quot;, &quot;Result&quot;: &quot;When applying quantum error correction, computational errors can be prevented, enabling error-free systems of logical qubits. Thus, error correction is making fault-tolerant quantum computation feasible. The good scalability of error correction, enables the accurate execution of large algorithms&quot;, &quot;Context&quot;: &quot;A quantum algorithm needs to be run on a quantum device. The quantum device’s performance is limited by various error sources, such as gate errors and crosstalk. The prevention of these errors enables the execution of large-scale quantum algorithms for real-world problems.&quot;, &quot;Examples&quot;: &quot;The figure below illustrates the application of a 3-qubit variant of the aforementioned error code for multiple qubits. Each of the physical qubits P1 to P4 is transformed into a logical qubit consisting of five physical qubits. Three of these five physical qubits are being used as data qubits and two of them are being used for the detection and recovery process. Further, the 1- and 2-qubit gates G1 to G4 need to be realized by the subroutines S1 to S4, which prepare the data qubits. The resulting errors can then be corrected by individually applying error correction routines for each of the logical qubits.\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/error-correction-example-1.svg)&quot;, &quot;Solution&quot;: &quot;Detect and correct quantum errors using quantum error correction codes [[Devitt et al. 2013](https://iopscience.iop.org/article/10.1088/0034-4885/76/7/076001/meta)]., which are added to the executed circuit. With these correction codes, many physical qubits are combined into one logical qubit. As a result of\nthis bundling, errors in the original qubit can be first detected and then corrected. The figure below depicts a solution sketch showcasing the general building blocks of a quantum error correction procedure. The shown instance applies an error correction code that can detect and fix bit-flip errors in the computational basis. For the correction of errors from other sources, similar processes can be applied. First, the ancilla coupling is created, by encoding the state $\\ket{\\psi}$ of a single physical qubit into multiple ancilla qubits. These qubits now hold the logical qubit’s data and are called data qubits in the following. Next, some unitary transformation is applied to the logical qubit, possibly resulting in an error. In order to detect an error, additional ancilla qubits are employed to check the parity of the data qubits. Based on the discovered syndrome, the error-free state can be recovered in the recovery phase. Note that the process is assumed to only have errors at the unitary transformation step, which is denoted by the error indicator. Further, the number and type of detectable errors depends on the applied error correction code.\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/error-correction-solution-sketch.svg)&quot;, &quot;Known Uses&quot;: &quot;Known Uses: [Laflamme et al.](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.77.198) show a 5-qubit error correction code that can protect a qubit against general 1-qubit errors. Shor’s 9-qubit code can protect a qubit against single bit-flip and phase-flip errors [[Shor 1995]](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.52.R2493). Further, a variety of different quantum error correction codes have been presented in the literature [[Devitt et al. 2013](https://iopscience.iop.org/article/10.1088/0034-4885/76/7/076001/meta)], [[Cai et al. 2021]](https://www.sciencedirect.com/science/article/pii/S2667325820300145), [[Gottesman et al. 1997]](https://arxiv.org/pdf/quant-ph/9705052.pdf), [[Roffe 2019]](https://www.tandfonline.com/doi/full/10.1080/00107514.2019.1667078)&quot;, &quot;Related Pattern&quot;: &quot;Enter your input for this section here.&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/error_correction_icon.png"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;Enter your input for this section here.&quot;, &quot;Forces&quot;: &quot;Quantum devices unavoidably cause a certain amount of errors due to the fragility of coherent quantum states [[Devitt et al. 2013](https://iopscience.iop.org/article/10.1088/0034-4885/76/7/076001/meta)]. Furthermore, contrary to classical bits, qubits can not be copied. Hence, classical error correction can\nnot be used for quantum computers and new quantum-specific methods need to be developed. However, these methods can be costly in terms of quantum resources, as they require a large number of additional qubits and quantum gates.\nTo enable scalable quantum computing for real-world problems, all kinds of errors occurring in quantum devices need to be detected and corrected. In general, the correction of errors is preferred over their mitigation, since even minor remaining post-mitigation errors slowly stack up during the computation and ultimately lead to an imprecise result.&quot;, &quot;Intent&quot;: &quot;How to detect and correct errors occurring during the execution of a quantum circuit?&quot;, &quot;Result&quot;: &quot;When applying quantum error correction, computational errors can be prevented, enabling error-free systems of logical qubits. Thus, error correction is making fault-tolerant quantum computation feasible. The good scalability of error correction, enables the accurate execution of large algorithms&quot;, &quot;Context&quot;: &quot;A quantum algorithm needs to be run on a quantum device. The quantum device’s performance is limited by various error sources, such as gate errors and crosstalk. The prevention of these errors enables the execution of large-scale quantum algorithms for real-world problems.&quot;, &quot;Examples&quot;: &quot;The figure below illustrates the application of a 3-qubit variant of the aforementioned error code for multiple qubits. Each of the physical qubits P1 to P4 is transformed into a logical qubit consisting of five physical qubits. Three of these five physical qubits are being used as data qubits and two of them are being used for the detection and recovery process. Further, the 1- and 2-qubit gates G1 to G4 need to be realized by the subroutines S1 to S4, which prepare the data qubits. The resulting errors can then be corrected by individually applying error correction routines for each of the logical qubits.\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/error-correction-example-1.svg)&quot;, &quot;Solution&quot;: &quot;Detect and correct quantum errors using quantum error correction codes [[Devitt et al. 2013](https://iopscience.iop.org/article/10.1088/0034-4885/76/7/076001/meta)]., which are added to the executed circuit. With these correction codes, many physical qubits are combined into one logical qubit. As a result of\nthis bundling, errors in the original qubit can be first detected and then corrected. The figure below depicts a solution sketch showcasing the general building blocks of a quantum error correction procedure. The shown instance applies an error correction code that can detect and fix bit-flip errors in the computational basis. For the correction of errors from other sources, similar processes can be applied. First, the ancilla coupling is created, by encoding the state $\\ket{\\psi}$ of a single physical qubit into multiple ancilla qubits. These qubits now hold the logical qubit’s data and are called data qubits in the following. Next, some unitary transformation is applied to the logical qubit, possibly resulting in an error. In order to detect an error, additional ancilla qubits are employed to check the parity of the data qubits. Based on the discovered syndrome, the error-free state can be recovered in the recovery phase. Note that the process is assumed to only have errors at the unitary transformation step, which is denoted by the error indicator. Further, the number and type of detectable errors depends on the applied error correction code.\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/error-correction-solution-sketch.svg)&quot;, &quot;Known Uses&quot;: &quot;Known Uses: [Laflamme et al.](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.77.198) show a 5-qubit error correction code that can protect a qubit against general 1-qubit errors. Shor’s 9-qubit code can protect a qubit against single bit-flip and phase-flip errors [[Shor 1995]](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.52.R2493). Further, a variety of different quantum error correction codes have been presented in the literature [[Devitt et al. 2013](https://iopscience.iop.org/article/10.1088/0034-4885/76/7/076001/meta)], [[Cai et al. 2021]](https://www.sciencedirect.com/science/article/pii/S2667325820300145), [[Gottesman et al. 1997]](https://arxiv.org/pdf/quant-ph/9705052.pdf), [[Roffe 2019]](https://www.tandfonline.com/doi/full/10.1080/00107514.2019.1667078)&quot;, &quot;Related Pattern&quot;: &quot;Enter your input for this section here.&quot;}"/>
            <where>id='1a5e3708-da39-4356-ab3f-115264da6390'</where>
        </update>
        <update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;Enter your input for this section here.&quot;, &quot;Forces&quot;: &quot;The execution of gates on current NISQ devices is not perfectly accurate. Hence, every execution of a gate causes a minor error. These errors keep accumulating, eventually making large computations impossible. The pulses used for the implementation of gate operations can be controlled on many quantum devices. Therefore, custom pulse schedules can be used to individually calibrate gates. Furthermore, the capabilities of current quantum devices are limited, e.g., the number of qubits and the decoherence times are bound. Thus, minimal additional quantum resources, such as gates and qubits, shall be used for error mitigation.&quot;, &quot;Intent&quot;: &quot;How to reduce the negative impact of noisy gate executions such that the pre-measurement state is closer to the expected error-free state?&quot;, &quot;Result&quot;: &quot;GEM can significantly reduce the impact of errors caused by erroneous gate executions. As a consequence, the state computed by the quantum algorithm is closer to the expected error-free quantum state and a more precise algorithm result can be obtained. However, the mitigation process may induce additional quantum gates into the circuit or require classical pre-processing to calculate optimal device calibrations, e.g., gate pulse calibrations. Generally, GEM methods can be used in combination with other error mitigation methods, such as REM to reduce the overall error further.&quot;, &quot;Context&quot;: &quot;A NISQ-compatible quantum algorithm, e.g., VQE, needs to be run on a quantum device. The device’s gate implementations are error-prone, causing errors in the quantum computation. To obtain precise results for the executed algorithm, the measured state needs to be computed accurately. Thus, it is crucial to mitigate the effects of gate errors.&quot;, &quot;Examples&quot;: &quot;The figure below shows the process of a typical gate addition-based method. These methods mitigate gate errors by adding additional gates to the quantum circuit that balance out gate errors. The initial quantum circuit is modified by adding specific gates for each error-prone operation. Hence, the depth of the circuit increases significantly. Therefore, the device’s decoherence times need to be kept in mind, as otherwise, the mitigation might decrease the result quality. \n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/gate-error-mitigation-solution-example1.svg)\nThe figure below depicts the typical process of a pulse calibration method. First, the pulse calibrations for the device are generated, e.g., it is determined which frequency is perfect to perform a bit-flip operation on a specific qubit. Once all required frequencies are determined, the information can be incorporated into the quantum circuit. When executing the modified circuit, the custom pulse calibrations will now be used instead of the default values. More precise pulse calibrations make gate executions more accurate, thus, decreasing gate error rates and increasing the solution’s precision\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/gate-error-mitigation-solution-example1.svg)&quot;, &quot;Solution&quot;: &quot;Mitigate the impact of gate errors by applying a Gate Error Mitigation (GEM) method. The mitigation of gate errors has to be performed before the execution of the quantum circuit, as occurring errors otherwise accumulate during the computation, making it difficult to retrace them. The resulting pre-measurement quantum state is closer to the expected error-free state, therefore, providing more accurate measurement results. The figure below depicts a solution sketch for GEM. First, the circuit is implemented. Afterwards, a GEM method is applied, modifying the circuit, to generate a more precise implementation for the selected device. The circuit modifications can range from simple gate additions over custom gate pulse adjustments to full circuit rewrites based on Machine Learning (ML). Next, the improved circuit is executed on the quantum device. Finally, the improved measurement result can be evaluated to obtain a more precise solution.\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/gate-error-mitigation-solution-sketch.svg)&quot;, &quot;Known Uses&quot;: &quot;Several circuit adjustment methods, e.g., FIIM or Random Identity Insertion (RIIM), are presented in the literature [[Nachman et al.]](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.012426),[[Temme et al.]](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.119.180509),[[Harper et al.]](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.080504). Further, machine learning-based circuit adjustment methods have been introduced, e.g., Noise-Aware Circuit Learning (NACL) [[Cincio et al.]](https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.2.010324). Moreover, pulse modification-based GEM methods have been presented [[Carvalho et al.]](https://journals.aps.org/prapplied/abstract/10.1103/PhysRevApplied.15.064054),[[Giurgica-Tiron et al.]](https://ieeexplore.ieee.org/abstract/document/9259940).&quot;, &quot;Related Pattern&quot;: &quot;Enter your input for this section here.&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/gate_error_mitigation_icon.png"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;Enter your input for this section here.&quot;, &quot;Forces&quot;: &quot;The execution of gates on current NISQ devices is not perfectly accurate. Hence, every execution of a gate causes a minor error. These errors keep accumulating, eventually making large computations impossible. The pulses used for the implementation of gate operations can be controlled on many quantum devices. Therefore, custom pulse schedules can be used to individually calibrate gates. Furthermore, the capabilities of current quantum devices are limited, e.g., the number of qubits and the decoherence times are bound. Thus, minimal additional quantum resources, such as gates and qubits, shall be used for error mitigation.&quot;, &quot;Intent&quot;: &quot;How to reduce the negative impact of noisy gate executions such that the pre-measurement state is closer to the expected error-free state?&quot;, &quot;Result&quot;: &quot;GEM can significantly reduce the impact of errors caused by erroneous gate executions. As a consequence, the state computed by the quantum algorithm is closer to the expected error-free quantum state and a more precise algorithm result can be obtained. However, the mitigation process may induce additional quantum gates into the circuit or require classical pre-processing to calculate optimal device calibrations, e.g., gate pulse calibrations. Generally, GEM methods can be used in combination with other error mitigation methods, such as REM to reduce the overall error further.&quot;, &quot;Context&quot;: &quot;A NISQ-compatible quantum algorithm, e.g., VQE, needs to be run on a quantum device. The device’s gate implementations are error-prone, causing errors in the quantum computation. To obtain precise results for the executed algorithm, the measured state needs to be computed accurately. Thus, it is crucial to mitigate the effects of gate errors.&quot;, &quot;Examples&quot;: &quot;The figure below shows the process of a typical gate addition-based method. These methods mitigate gate errors by adding additional gates to the quantum circuit that balance out gate errors. The initial quantum circuit is modified by adding specific gates for each error-prone operation. Hence, the depth of the circuit increases significantly. Therefore, the device’s decoherence times need to be kept in mind, as otherwise, the mitigation might decrease the result quality. \n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/gate-error-mitigation-solution-example1.svg)\nThe figure below depicts the typical process of a pulse calibration method. First, the pulse calibrations for the device are generated, e.g., it is determined which frequency is perfect to perform a bit-flip operation on a specific qubit. Once all required frequencies are determined, the information can be incorporated into the quantum circuit. When executing the modified circuit, the custom pulse calibrations will now be used instead of the default values. More precise pulse calibrations make gate executions more accurate, thus, decreasing gate error rates and increasing the solution’s precision\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/gate-error-mitigation-solution-example1.svg)&quot;, &quot;Solution&quot;: &quot;Mitigate the impact of gate errors by applying a Gate Error Mitigation (GEM) method. The mitigation of gate errors has to be performed before the execution of the quantum circuit, as occurring errors otherwise accumulate during the computation, making it difficult to retrace them. The resulting pre-measurement quantum state is closer to the expected error-free state, therefore, providing more accurate measurement results. The figure below depicts a solution sketch for GEM. First, the circuit is implemented. Afterwards, a GEM method is applied, modifying the circuit, to generate a more precise implementation for the selected device. The circuit modifications can range from simple gate additions over custom gate pulse adjustments to full circuit rewrites based on Machine Learning (ML). Next, the improved circuit is executed on the quantum device. Finally, the improved measurement result can be evaluated to obtain a more precise solution.\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/gate-error-mitigation-solution-sketch.svg)&quot;, &quot;Known Uses&quot;: &quot;Several circuit adjustment methods, e.g., FIIM or Random Identity Insertion (RIIM), are presented in the literature [[Nachman et al.]](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.012426),[[Temme et al.]](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.119.180509),[[Harper et al.]](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.080504). Further, machine learning-based circuit adjustment methods have been introduced, e.g., Noise-Aware Circuit Learning (NACL) [[Cincio et al.]](https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.2.010324). Moreover, pulse modification-based GEM methods have been presented [[Carvalho et al.]](https://journals.aps.org/prapplied/abstract/10.1103/PhysRevApplied.15.064054),[[Giurgica-Tiron et al.]](https://ieeexplore.ieee.org/abstract/document/9259940).&quot;, &quot;Related Pattern&quot;: &quot;Enter your input for this section here.&quot;}"/>
            <where>id='b6788c99-24f5-496b-a30c-fc0dd7bb3e96'</where>
        </update>
        <update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot; Use a quantum routine to estimate a kernel for a classical SVM.\n\n&quot;, &quot;Result&quot;: &quot;Both the training as well as the classification is efficient, given that the evaluation of the inner products can be done in an efficient manner. \nThe main advantage of this setup is that the quantum computer has the potential to compute inner products in a feature space that cannot be evaluated efficiently on a classical computer.\nStill, a key open question regarding this setup remains how to choose a feature map for a given data set. \n\n&quot;, &quot;Context&quot;: &quot;A support vector machine (SVM) must be found to classify a set of data points $\\{x_i\\}\\subseteq \\mathcal{R}^d$ according to their labels. \nTherefore, a hyperplane must be found that (i) separates the data points of the different classes and (ii) maintains a maximal distance to the data points. \nA large margin between the hyperplane and the data points ensures that unseen data points are classified correctly with a high probability.\nThe given data set is not guaranteed to be linearly separable, and thus, it may not be possible to find such a separating hyperplane in the original space.\nIf this is the case, a hyperplane in a higher dimensional feature space to which the data points are mapped (implicitly) can be used instead. \n\n&quot;, &quot;Solution&quot;: &quot;To find a separating hyperplane, a quantum computer is used to estimate the kernel function $K(x,x')=|\\left&lt;\\phi(x)|\\phi(x')\\right&gt;|^2$: \nA pair of data points $(x,x')$ is encoded into the Hilbert Space according to a quantum feature map $\\phi$ (see solution sketch). \nThis allows to use, e.g., a SWAP test routine to estimate the inner product $\\left&lt;\\phi(x)|\\phi(x')\\right&gt;$ of the two points [(Schuld and Killoran)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.040504)\nThe result can then be used to compute the kernel function for this pair of data points, based on which the SVM is optimized on a classical computer. \n\n\n![Sketch](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/qke_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;The solution above was first proposed in [(Havlíček et al. 2019)](https://www.nature.com/articles/s41586-019-0980-2) where it was also demonstrated in an experiment involving two qubits. \nIndependently, the same solution was developed in [(Schuld and Killoran 2019)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.040504) which additionally presents a feature map targeted for quantum devices based on continuous-variable qubits. \nAnother proof-of-principle demonstration was conducted by [(Bartkiewicz et al. 2020)](https://www.nature.com/articles/s41598-020-68911-5) using photonic qubits. \nThis approach was also further investigated in [(Ghobadi, Oberoi and Zahedinejad 2019)](https://www.researchgate.net/publication/332897448_The_Power_of_One_Qubit_in_Machine_Learning).\nIn our [QHAna](https://github.com/UST-QuAntiL/qhana) project [(Barzen 2021)](https://arxiv.org/abs/2103.11825), we also provide an implementation of this pattern along with a user interface to select one of various quantum feature maps.&quot;, &quot;Related Patterns&quot;: &quot;This pattern is a refinement of the [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531). \nHere, the quantum computer is only used to estimate a single function, while the rest of the computations are left to the classical computer.\n\n&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/qke_icon.png"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot; Use a quantum routine to estimate a kernel for a classical SVM.\n\n&quot;, &quot;Result&quot;: &quot;Both the training as well as the classification is efficient, given that the evaluation of the inner products can be done in an efficient manner. \nThe main advantage of this setup is that the quantum computer has the potential to compute inner products in a feature space that cannot be evaluated efficiently on a classical computer.\nStill, a key open question regarding this setup remains how to choose a feature map for a given data set. \n\n&quot;, &quot;Context&quot;: &quot;A support vector machine (SVM) must be found to classify a set of data points $\\{x_i\\}\\subseteq \\mathcal{R}^d$ according to their labels. \nTherefore, a hyperplane must be found that (i) separates the data points of the different classes and (ii) maintains a maximal distance to the data points. \nA large margin between the hyperplane and the data points ensures that unseen data points are classified correctly with a high probability.\nThe given data set is not guaranteed to be linearly separable, and thus, it may not be possible to find such a separating hyperplane in the original space.\nIf this is the case, a hyperplane in a higher dimensional feature space to which the data points are mapped (implicitly) can be used instead. \n\n&quot;, &quot;Solution&quot;: &quot;To find a separating hyperplane, a quantum computer is used to estimate the kernel function $K(x,x')=|\\left&lt;\\phi(x)|\\phi(x')\\right&gt;|^2$: \nA pair of data points $(x,x')$ is encoded into the Hilbert Space according to a quantum feature map $\\phi$ (see solution sketch). \nThis allows to use, e.g., a SWAP test routine to estimate the inner product $\\left&lt;\\phi(x)|\\phi(x')\\right&gt;$ of the two points [(Schuld and Killoran)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.040504)\nThe result can then be used to compute the kernel function for this pair of data points, based on which the SVM is optimized on a classical computer. \n\n\n![Sketch](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/qke_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;The solution above was first proposed in [(Havlíček et al. 2019)](https://www.nature.com/articles/s41586-019-0980-2) where it was also demonstrated in an experiment involving two qubits. \nIndependently, the same solution was developed in [(Schuld and Killoran 2019)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.040504) which additionally presents a feature map targeted for quantum devices based on continuous-variable qubits. \nAnother proof-of-principle demonstration was conducted by [(Bartkiewicz et al. 2020)](https://www.nature.com/articles/s41598-020-68911-5) using photonic qubits. \nThis approach was also further investigated in [(Ghobadi, Oberoi and Zahedinejad 2019)](https://www.researchgate.net/publication/332897448_The_Power_of_One_Qubit_in_Machine_Learning).\nIn our [QHAna](https://github.com/UST-QuAntiL/qhana) project [(Barzen 2021)](https://arxiv.org/abs/2103.11825), we also provide an implementation of this pattern along with a user interface to select one of various quantum feature maps.&quot;, &quot;Related Patterns&quot;: &quot;This pattern is a refinement of the [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531). \nHere, the quantum computer is only used to estimate a single function, while the rest of the computations are left to the classical computer.\n\n&quot;}"/>
            <where>id='5479acf4-0588-49af-a6a9-4956b7ee32af'</where>
        </update>
        <update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;Enter your input for this section here.&quot;, &quot;Forces&quot;: &quot;The measurement times of quantum computers in the NISQ era are significant in comparison to their decoherence times. Therefore, the measurements are highly error-prone and often are among the main error sources. Due to the limited capabilities of current NISQ devices, a minimal number of additional qubits and quantum gates shall be used for the mitigation of readout errors. Further, a quantum device’s measurement error rates change over time, thus the Readout Error Mitigation (REM) needs to be adaptive.&quot;, &quot;Intent&quot;: &quot;How to reduce the impact of erroneous measurements such that the measured result is closer to the intended quantum state?&quot;, &quot;Result&quot;: &quot;REM can reduce the impact of errors caused by measurement operations. The resulting, more precise probability distributions make NISQ devices more suitable for real-world use cases. However, additional classical processing is necessary, which can significantly increase the runtime and classical resource requirements, as not all mitigation methods scale well with the number of qubits. Generally, data provenance can be employed to increase the efficiency of frequently occurring REM tasks, e.g., when executing a VQA.&quot;, &quot;Context&quot;: &quot;A NISQ-compatible quantum algorithm, e.g., QAOA or VQE, needs to be run on a quantum device. The device’s decoherence times are short and the measurement operations are error-prone. Hence, the measured probability distribution is inaccurate, even when the measured quantum state is accurate. Thus, the negative impact of readout errors needs to be mitigated to obtain a precise measurement result.&quot;, &quot;Examples&quot;: &quot;The figure below illustrates the steps of the Static Invert-and-Measure (SIM) technique[[Tannu et al.]](https://dl.acm.org/doi/abs/10.1145/3352460.3358265). First, multiple slightly adapted instances of the circuit are created. Thereby, bit-flips are added right before the circuit’s measurement operations. This helps to detect erroneous measurements because readout error rates are typically higher when measuring a qubit in the $\\ket{1}$ state than when measuring it in the $\\ket{0}$ state. Once all circuits are executed, the measurement results are processed, returning the mitigated probability distribution.\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/readout-error-mitigation-example1.svg) \n\n\nThe figure below shows the typical process of a calibration matrix-based mitigation method. Multiple shallow calibration circuits are generated and executed. The resulting probability distributions give information about the device’s readout error rates. These error rates are then incorporated into a so-called calibration matrix, which can be used to mitigate readout errors. For example, this can be done by multiplying the inverse of the calibration matrix with the circuit’s measurement result.\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/readout-error-mitigation-example2.svg) &quot;, &quot;Solution&quot;: &quot;Mitigate the impact of readout errors by applying a REM method. The mitigation method is performed after the circuit execution and adjusts the measured probability distribution. The resulting mitigated probability distribution is a more accurate representation of the intended quantum state. A solution sketch for the application of REM is shown in figure below. First, the quantum circuit is implemented and executed. Then the resulting probability distribution is improved based on measurement characteristics collected for the quantum device. These characteristics are typically obtained by separately running so-called calibration circuits. Alternatively, adapted instances of the implemented circuit can be run to obtain additional information about the measurement properties.\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/readout-error-mitigation-solution-sketch.svg)&quot;, &quot;Known Uses&quot;: &quot;Various REM methods, e.g., calibration matrix-based [[Bravyi et al.]](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.103.042605)[[Nachman et al.]](https://www.nature.com/articles/s41534-020-00309-7)[[Maciejewski et al.]](https://quantum-journal.org/papers/q-2020-04-24-257/)[[Nation et al.]](https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.2.040326) or bit-flip-based [[Tannu et al.]](https://dl.acm.org/doi/abs/10.1145/3352460.3358265)[[Smith et al.]](https://www.science.org/doi/full/10.1126/sciadv.abi8009),have been introduced in the literature. Moreover, recent work introduces a deep learning-based REM method [[Kim et al.]](https://iopscience.iop.org/article/10.1088/1367-2630/ac7b3d/pdf).&quot;, &quot;Related Pattern&quot;: &quot;Enter your input for this section here.&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/readout_error_mitigation_icon.png"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;Enter your input for this section here.&quot;, &quot;Forces&quot;: &quot;The measurement times of quantum computers in the NISQ era are significant in comparison to their decoherence times. Therefore, the measurements are highly error-prone and often are among the main error sources. Due to the limited capabilities of current NISQ devices, a minimal number of additional qubits and quantum gates shall be used for the mitigation of readout errors. Further, a quantum device’s measurement error rates change over time, thus the Readout Error Mitigation (REM) needs to be adaptive.&quot;, &quot;Intent&quot;: &quot;How to reduce the impact of erroneous measurements such that the measured result is closer to the intended quantum state?&quot;, &quot;Result&quot;: &quot;REM can reduce the impact of errors caused by measurement operations. The resulting, more precise probability distributions make NISQ devices more suitable for real-world use cases. However, additional classical processing is necessary, which can significantly increase the runtime and classical resource requirements, as not all mitigation methods scale well with the number of qubits. Generally, data provenance can be employed to increase the efficiency of frequently occurring REM tasks, e.g., when executing a VQA.&quot;, &quot;Context&quot;: &quot;A NISQ-compatible quantum algorithm, e.g., QAOA or VQE, needs to be run on a quantum device. The device’s decoherence times are short and the measurement operations are error-prone. Hence, the measured probability distribution is inaccurate, even when the measured quantum state is accurate. Thus, the negative impact of readout errors needs to be mitigated to obtain a precise measurement result.&quot;, &quot;Examples&quot;: &quot;The figure below illustrates the steps of the Static Invert-and-Measure (SIM) technique[[Tannu et al.]](https://dl.acm.org/doi/abs/10.1145/3352460.3358265). First, multiple slightly adapted instances of the circuit are created. Thereby, bit-flips are added right before the circuit’s measurement operations. This helps to detect erroneous measurements because readout error rates are typically higher when measuring a qubit in the $\\ket{1}$ state than when measuring it in the $\\ket{0}$ state. Once all circuits are executed, the measurement results are processed, returning the mitigated probability distribution.\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/readout-error-mitigation-example1.svg) \n\n\nThe figure below shows the typical process of a calibration matrix-based mitigation method. Multiple shallow calibration circuits are generated and executed. The resulting probability distributions give information about the device’s readout error rates. These error rates are then incorporated into a so-called calibration matrix, which can be used to mitigate readout errors. For example, this can be done by multiplying the inverse of the calibration matrix with the circuit’s measurement result.\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/readout-error-mitigation-example2.svg) &quot;, &quot;Solution&quot;: &quot;Mitigate the impact of readout errors by applying a REM method. The mitigation method is performed after the circuit execution and adjusts the measured probability distribution. The resulting mitigated probability distribution is a more accurate representation of the intended quantum state. A solution sketch for the application of REM is shown in figure below. First, the quantum circuit is implemented and executed. Then the resulting probability distribution is improved based on measurement characteristics collected for the quantum device. These characteristics are typically obtained by separately running so-called calibration circuits. Alternatively, adapted instances of the implemented circuit can be run to obtain additional information about the measurement properties.\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/readout-error-mitigation-solution-sketch.svg)&quot;, &quot;Known Uses&quot;: &quot;Various REM methods, e.g., calibration matrix-based [[Bravyi et al.]](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.103.042605)[[Nachman et al.]](https://www.nature.com/articles/s41534-020-00309-7)[[Maciejewski et al.]](https://quantum-journal.org/papers/q-2020-04-24-257/)[[Nation et al.]](https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.2.040326) or bit-flip-based [[Tannu et al.]](https://dl.acm.org/doi/abs/10.1145/3352460.3358265)[[Smith et al.]](https://www.science.org/doi/full/10.1126/sciadv.abi8009),have been introduced in the literature. Moreover, recent work introduces a deep learning-based REM method [[Kim et al.]](https://iopscience.iop.org/article/10.1088/1367-2630/ac7b3d/pdf).&quot;, &quot;Related Pattern&quot;: &quot;Enter your input for this section here.&quot;}"/>
            <where>id='ed3af509-904e-4732-8113-215d65a7d53d'</where>
        </update>
        <update tableName="pattern">
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/function_table_icon.png"/>
            <where>id='3f3fabf0-7fa7-4b43-a74a-46a7ac2c55ee'</where>
        </update>
        <update tableName="pattern">
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/aoa_icon.png"/>
            <where>id='b657ea73-63c0-4800-a69d-a91925e19ac6'</where>
        </update>
        <update tableName="pattern">
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/amplitude_amplification_icon.png"/>
            <where>id='96b4d28a-a5ce-4c96-85df-d42587b13c57'</where>
        </update>
        <update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;This encoding has also been referred to as Wavefunction Encoding by [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420). Every quantum system is described by its wavefunction $\\psi$ which also defines the measurement probabilities. By expressing that the wavefunction is used to encode data, it is therefore implied that amplitudes of the quantum system are used to represent data values.&quot;, &quot;Intent&quot;: &quot;Encode data in a compact manner that do not require calculations&quot;, &quot;Result&quot;: &quot;A data input vector of length $l$ can be represented by $\\lceil log_2(l)\\rceil$ qubits - this is indeed a very compact representation. For an arbitrary state represented by $n$ qubits (which represents $2^n$ data values), it is known that at least $2^n$ parallel operations are needed [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232). Current state preparation routines perform slightly better than $2^n$ operations [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232). However, depending on the data it maystill be possible to realize an encoding in a logarithmic runtime. For example, a [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) can be created by applying a Hadamard gate to each of the $n$ qubits - which can be done in parallel and thus in a single step. This represents a $2^n$-dimensional vector in which all data entries are $\\frac{1}{\\sqrt{n}}$. Similarly, sparse data vectors can also be prepared more efficiently [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232).It must be noted that if the output is also encoded in the amplitude, multiple measurements must be taken toobtain a good estimate of the output result. The number of measurements scales with the number of amplitudes -as $n$ qubits contain $2^n$ amplitudes, this is costly [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232).&quot;, &quot;Context&quot;: &quot;A numerical input data vector $(x_0, \\ldots, x_{n-1})^T$ must be encoded for an algorithm.&quot;, &quot;Solution&quot;: &quot;Use amplitudes to encode the data. As the squared moduli of the amplitudes of a quantum state must sum up to 1, the input vector needs to be normalized to length 1. This is illustrated in Fig. 5 for a 2-dimensional input vector that contains 2 data points. To associate each amplitude with a component of the input vector, the dimension of the vector must be equal to a power of two because the vector space of an $n$ qubit register has dimension $2^n$. If this is not the case, the input vector can be padded with additional zeros to increase the dimension of it. Using a suitable state preparation routine (see Known Uses), the input vector is encoded in the amplitudes of the quantum state as follows: \n$| \\psi \\rangle  = \\sum_{i=0}^{n-1} x_i | i \\rangle$.\nAs the amplitudes depend on the data, the process of encoding the data (but not the encoding itself) is often referred to as arbitrary state preparation.\n\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/amplitude_encoding_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [Data Encoding Patterns for Quantum Algorithms.](https://hillside.net/plop/2020/papers/weigold.pdf) In: The Hillside Group (Hrsg): Proceedings of the 27th Conference on Pattern Languages of Programs (PLoP '20).\n&quot;, &quot;Variants&quot;: &quot;Enter your input for this section here.&quot;, &quot;Known Uses&quot;: &quot;[Amplitude Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/502147ec-45fa-403f-8f52-e196b3359399) is required by many quantum machine learning algorithms [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420). Another example is the algorithm of Harrow, Hassidim and Lloyd [(Harrow, Hassidim and Lloyd 2009)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502) (often referred to as HHL algorithm) for solving linear equations. The pre-condition that the data values can be normalized is a common assumption in machine learning [(Schuld et al. 2017)](http://dx.doi.org/10.1209/0295-5075/119/60002), e.g. in support vector machine.There are various ways to construct a state preparation routine for this encoding. For example, [(Plesch and Brukner 2011)](http://dx.doi.org/10.1103/PhysRevA.83.032302) and [(Iten et al. 2016)](http://dx.doi.org/10.1103/PhysRevA.93.032318) use the Schmidt Decomposition. For the latter, an implementation in Mathematica was presented [(Iten et al. 2019)](https://arxiv.org/abs/1904.01072). [(Shende et al. 2006)](https://ieeexplore.ieee.org/document/1629135) presented an alternative way to construct an arbitrary quantum state which was implemented by Qiskit [(Qis 2020)](https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations). PennyLane offers a loading routine for [Amplitude Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/502147ec-45fa-403f-8f52-e196b3359399) [Pen 2020](https://pennylane.readthedocs.io/en/stable/introduction/templates.html). The library also includes an arbitrary state preparation routine that uses the algorithm proposed by [(Möttönen and Vartiainen 2005)](https://arxiv.org/abs/quant-ph/0504100). The state preparation routine by [(Möttönen and Vartiainen 2005)](https://arxiv.org/abs/quant-ph/0504100) requires an exponential number of operations to encode $2^n$ data values. Q# provides functionality to compute a state preparation routine that approximates the desired amplitude encoding [(QSh 2020)](https://docs.microsoft.com/en-us/qsharp/api/).\n\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern refines [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d). The encoding is more compact (in terms of qubits) than [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750), [Angle Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/e595558d-bfea-4b82-9f47-a38a2097b245) or  [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13).&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/amplitude_encoding_icon.png"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;This encoding has also been referred to as Wavefunction Encoding by [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420). Every quantum system is described by its wavefunction $\\psi$ which also defines the measurement probabilities. By expressing that the wavefunction is used to encode data, it is therefore implied that amplitudes of the quantum system are used to represent data values.&quot;, &quot;Intent&quot;: &quot;Encode data in a compact manner that do not require calculations&quot;, &quot;Result&quot;: &quot;A data input vector of length $l$ can be represented by $\\lceil log_2(l)\\rceil$ qubits - this is indeed a very compact representation. For an arbitrary state represented by $n$ qubits (which represents $2^n$ data values), it is known that at least $2^n$ parallel operations are needed [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232). Current state preparation routines perform slightly better than $2^n$ operations [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232). However, depending on the data it maystill be possible to realize an encoding in a logarithmic runtime. For example, a [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) can be created by applying a Hadamard gate to each of the $n$ qubits - which can be done in parallel and thus in a single step. This represents a $2^n$-dimensional vector in which all data entries are $\\frac{1}{\\sqrt{n}}$. Similarly, sparse data vectors can also be prepared more efficiently [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232).It must be noted that if the output is also encoded in the amplitude, multiple measurements must be taken toobtain a good estimate of the output result. The number of measurements scales with the number of amplitudes -as $n$ qubits contain $2^n$ amplitudes, this is costly [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232).&quot;, &quot;Context&quot;: &quot;A numerical input data vector $(x_0, \\ldots, x_{n-1})^T$ must be encoded for an algorithm.&quot;, &quot;Solution&quot;: &quot;Use amplitudes to encode the data. As the squared moduli of the amplitudes of a quantum state must sum up to 1, the input vector needs to be normalized to length 1. This is illustrated in Fig. 5 for a 2-dimensional input vector that contains 2 data points. To associate each amplitude with a component of the input vector, the dimension of the vector must be equal to a power of two because the vector space of an $n$ qubit register has dimension $2^n$. If this is not the case, the input vector can be padded with additional zeros to increase the dimension of it. Using a suitable state preparation routine (see Known Uses), the input vector is encoded in the amplitudes of the quantum state as follows: \n$| \\psi \\rangle  = \\sum_{i=0}^{n-1} x_i | i \\rangle$.\nAs the amplitudes depend on the data, the process of encoding the data (but not the encoding itself) is often referred to as arbitrary state preparation.\n\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/amplitude_encoding_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [Data Encoding Patterns for Quantum Algorithms.](https://hillside.net/plop/2020/papers/weigold.pdf) In: The Hillside Group (Hrsg): Proceedings of the 27th Conference on Pattern Languages of Programs (PLoP '20).\n&quot;, &quot;Variants&quot;: &quot;Enter your input for this section here.&quot;, &quot;Known Uses&quot;: &quot;[Amplitude Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/502147ec-45fa-403f-8f52-e196b3359399) is required by many quantum machine learning algorithms [(LaRose and Coyle 2020)](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032420). Another example is the algorithm of Harrow, Hassidim and Lloyd [(Harrow, Hassidim and Lloyd 2009)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502) (often referred to as HHL algorithm) for solving linear equations. The pre-condition that the data values can be normalized is a common assumption in machine learning [(Schuld et al. 2017)](http://dx.doi.org/10.1209/0295-5075/119/60002), e.g. in support vector machine.There are various ways to construct a state preparation routine for this encoding. For example, [(Plesch and Brukner 2011)](http://dx.doi.org/10.1103/PhysRevA.83.032302) and [(Iten et al. 2016)](http://dx.doi.org/10.1103/PhysRevA.93.032318) use the Schmidt Decomposition. For the latter, an implementation in Mathematica was presented [(Iten et al. 2019)](https://arxiv.org/abs/1904.01072). [(Shende et al. 2006)](https://ieeexplore.ieee.org/document/1629135) presented an alternative way to construct an arbitrary quantum state which was implemented by Qiskit [(Qis 2020)](https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations). PennyLane offers a loading routine for [Amplitude Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/502147ec-45fa-403f-8f52-e196b3359399) [Pen 2020](https://pennylane.readthedocs.io/en/stable/introduction/templates.html). The library also includes an arbitrary state preparation routine that uses the algorithm proposed by [(Möttönen and Vartiainen 2005)](https://arxiv.org/abs/quant-ph/0504100). The state preparation routine by [(Möttönen and Vartiainen 2005)](https://arxiv.org/abs/quant-ph/0504100) requires an exponential number of operations to encode $2^n$ data values. Q# provides functionality to compute a state preparation routine that approximates the desired amplitude encoding [(QSh 2020)](https://docs.microsoft.com/en-us/qsharp/api/).\n\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern refines [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d). The encoding is more compact (in terms of qubits) than [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750), [Angle Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/e595558d-bfea-4b82-9f47-a38a2097b245) or  [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13).&quot;}"/>
            <where>id='502147ec-45fa-403f-8f52-e196b3359399'</where>
        </update>
        <update tableName="pattern">
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/oracle_icon.png"/>
            <where>id='1cc7e9d6-ab37-412e-8afa-604a25de296e'</where>
        </update>
        <update tableName="pattern">
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/phase_shift_icon.png"/>
            <where>id='c6560c51-d2e3-4595-b9c3-b609c75c0b82'</where>
        </update>
        <update tableName="pattern">
            <column name="icon_url" value="http://quantumcomputingpatterns.org/assets/pattern-icons/post_selective_measurement_icon.png"/>
            <where>id='1c95912a-128b-44e7-b2d4-930f7ba11060'</where>
        </update>
        <update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;Approximate the solution of an optimization problem [Weigold et al. 2021](https://www.springer.com/de/book/9783030648459)\n\n&quot;, &quot;Result&quot;: &quot;The depth of the overall circuit is at most $mp + p$ [(Farhi and Goldstone 2014)](http://arxiv.org/pdf/1411.4028v1) which is rather shallow. \nThis is one reason why this algorithm is considered a promising candidate for NISQ devices. \nFrom a theoretical point of view, it can be noticed that the algorithm approximates the best solution if suitable small values for the parameters $\\gamma, \\beta$ are chosen with  $p\\rightarrow \\infty$. \nNevertheless, note that the performance of the algorithm also depends on the objective function and the optimization strategy. \n\n&quot;, &quot;Context&quot;: &quot;To solve a combinatorial optimization problem, a bit string $z=z_1\\ldots z_n$ must be found which assigns each binary variable $z_i$ to either 0 or 1 and fulfills a maximum number of $m$ clauses. \nHereby, each clause involves a subset of the variables.\nIn contrast to the potentially constrained domain of solutions in [Alternating Operator Ansatz (AOA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/b657ea73-63c0-4800-a69d-a91925e19ac6), every bit string $z=z_1\\ldots z_n$ of length $n$ is a solution to the problem. \n\n&quot;, &quot;Solution&quot;: &quot;The overall structure of the *Quantum Approximate Optimization Algorithm (QAOA)* [(Farhi and Goldstone 2014)](http://arxiv.org/pdf/1411.4028v1) approach is depicted in the solution sketch.\n\nFirst, a [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) realizing all possible solutions in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/de5b0951-2b66-4312-bf06-7082d3232e6e) is prepared.\nE.g., the solution with all binary values assigned to 0 is represented by $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{0 \\ldots 0 0}$ and is contained in the superposition. \n\n\nThen, an ansatz circuit is applied that is constructed based on the two operators $U(C,\\gamma)$ and $U(B,\\beta)$:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\n    U(C,\\gamma) = e^{i\\gamma C} = \\prod_{\\alpha=1}^{m} e^{-i\\gamma C_\\alpha}; \n    \\ U(B,\\beta) = e^{-i\\beta B} = \\prod_{j=1}^{n}e^{-i\\beta \\sigma_x^{j}}\n$$  \n\n\nThe first operator is a phase shift $e^{-i\\gamma}$ on every computational basis state for every clause that is fulfilled. \nHowever, this marks but does not change the amplitude of computational basis states (which each represent a solution), thus, the second operator $U(B,\\gamma)$ is required. \n$U(B,\\gamma)$ defines a rotation around the $X$-axis for every qubit whereby the angle for the rotation depends on $\\gamma$. \nBased on the structure defined in [Alternating Operator Ansatz (AOA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/b657ea73-63c0-4800-a69d-a91925e19ac6), a trial state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\gamma,\\beta}$ is prepared. \nMeasuring this state results in a single bitstring, i.e., a solution that can be evaluated by the objective function. \nThe parameters $\\beta$ and $\\gamma$ which are initialized randomly for the first iteration can then be adjusted. \nThis iterative process continues until the termination condition is satisfied. \n\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/variational_solution_qaoa.png)\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2 ) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;This algorithm was first proposed by Farhi, Goldstone, and Gutmann [(Farhi and Goldstone 2014)](http://arxiv.org/pdf/1411.4028v1) and applied to the problem of finding a maximum cut of a graph (MaxCut). \nIn a follow-up paper, an advantage over classical algorithms for the *bounded occurrence problem* [(Farhi, Goldstone and Gutmann 2015)](https://arxiv.org/abs/1412.6062) was shown. \nShortly afterward, a classical algorithm [(Barak et al. 2015)](http://arxiv.org/abs/1505.03424) was published from which even better results can be expected for this particular problem instance. \n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)&quot;, &quot;Related Patterns&quot;: &quot;In this pattern [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) is used to represent the bitstrings of solutions in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750).\nThe higher-level structure of this pattern is described by [Alternating Operator Ansatz (AOA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/b657ea73-63c0-4800-a69d-a91925e19ac6) which also uses [Phase Shift](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/c6560c51-d2e3-4595-b9c3-b609c75c0b82) . \n\n&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/qaoa_icon.png"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;Approximate the solution of an optimization problem [Weigold et al. 2021](https://www.springer.com/de/book/9783030648459)\n\n&quot;, &quot;Result&quot;: &quot;The depth of the overall circuit is at most $mp + p$ [(Farhi and Goldstone 2014)](http://arxiv.org/pdf/1411.4028v1) which is rather shallow. \nThis is one reason why this algorithm is considered a promising candidate for NISQ devices. \nFrom a theoretical point of view, it can be noticed that the algorithm approximates the best solution if suitable small values for the parameters $\\gamma, \\beta$ are chosen with  $p\\rightarrow \\infty$. \nNevertheless, note that the performance of the algorithm also depends on the objective function and the optimization strategy. \n\n&quot;, &quot;Context&quot;: &quot;To solve a combinatorial optimization problem, a bit string $z=z_1\\ldots z_n$ must be found which assigns each binary variable $z_i$ to either 0 or 1 and fulfills a maximum number of $m$ clauses. \nHereby, each clause involves a subset of the variables.\nIn contrast to the potentially constrained domain of solutions in [Alternating Operator Ansatz (AOA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/b657ea73-63c0-4800-a69d-a91925e19ac6), every bit string $z=z_1\\ldots z_n$ of length $n$ is a solution to the problem. \n\n&quot;, &quot;Solution&quot;: &quot;The overall structure of the *Quantum Approximate Optimization Algorithm (QAOA)* [(Farhi and Goldstone 2014)](http://arxiv.org/pdf/1411.4028v1) approach is depicted in the solution sketch.\n\nFirst, a [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) realizing all possible solutions in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/de5b0951-2b66-4312-bf06-7082d3232e6e) is prepared.\nE.g., the solution with all binary values assigned to 0 is represented by $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{0 \\ldots 0 0}$ and is contained in the superposition. \n\n\nThen, an ansatz circuit is applied that is constructed based on the two operators $U(C,\\gamma)$ and $U(B,\\beta)$:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\n    U(C,\\gamma) = e^{i\\gamma C} = \\prod_{\\alpha=1}^{m} e^{-i\\gamma C_\\alpha}; \n    \\ U(B,\\beta) = e^{-i\\beta B} = \\prod_{j=1}^{n}e^{-i\\beta \\sigma_x^{j}}\n$$  \n\n\nThe first operator is a phase shift $e^{-i\\gamma}$ on every computational basis state for every clause that is fulfilled. \nHowever, this marks but does not change the amplitude of computational basis states (which each represent a solution), thus, the second operator $U(B,\\gamma)$ is required. \n$U(B,\\gamma)$ defines a rotation around the $X$-axis for every qubit whereby the angle for the rotation depends on $\\gamma$. \nBased on the structure defined in [Alternating Operator Ansatz (AOA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/b657ea73-63c0-4800-a69d-a91925e19ac6), a trial state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\gamma,\\beta}$ is prepared. \nMeasuring this state results in a single bitstring, i.e., a solution that can be evaluated by the objective function. \nThe parameters $\\beta$ and $\\gamma$ which are initialized randomly for the first iteration can then be adjusted. \nThis iterative process continues until the termination condition is satisfied. \n\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/variational_solution_qaoa.png)\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2 ) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;This algorithm was first proposed by Farhi, Goldstone, and Gutmann [(Farhi and Goldstone 2014)](http://arxiv.org/pdf/1411.4028v1) and applied to the problem of finding a maximum cut of a graph (MaxCut). \nIn a follow-up paper, an advantage over classical algorithms for the *bounded occurrence problem* [(Farhi, Goldstone and Gutmann 2015)](https://arxiv.org/abs/1412.6062) was shown. \nShortly afterward, a classical algorithm [(Barak et al. 2015)](http://arxiv.org/abs/1505.03424) was published from which even better results can be expected for this particular problem instance. \n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)&quot;, &quot;Related Patterns&quot;: &quot;In this pattern [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) is used to represent the bitstrings of solutions in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750).\nThe higher-level structure of this pattern is described by [Alternating Operator Ansatz (AOA)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/b657ea73-63c0-4800-a69d-a91925e19ac6) which also uses [Phase Shift](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/c6560c51-d2e3-4595-b9c3-b609c75c0b82) . \n\n&quot;}"/>
            <where>id='da93f915-7f4c-49df-99d0-80d91f26a337'</where>
        </update>
        <update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;Enter your input for this section here.&quot;, &quot;Intent&quot;: &quot;Encode data in a compact manner that do not require calculations&quot;, &quot;Result&quot;: &quot;The resulting encoding is a digital encoding and therefore suitable for arithmetic computations [(Leymann and Barzen 2020)](http://iopscience.iop.org/10.1088/2058-9565/abae7d). For input $n$ numbers that are approximated by $l$ digits, $l$ qubits are needed for this representation. Each of then encoded input values is represented by a basis vector with an amplitude of1√n.All other $2^{l−n}$ amplitudes of the register are zero - in our example, $|000\\rangle$, $|001\\rangle$,$|100\\rangle$,$|101\\rangle$, and $|111\\rangle$. The amplitude vector is therefore often sparse for this encoding [(Schuld and Petruccione 2018)](http://dx.doi.org/10.1007/978-3-319-96424-9). &quot;, &quot;Context&quot;: &quot;A quantum algorithm requires multiple numerical values $X$ as input for further calculations.&quot;, &quot;Solution&quot;: &quot;Use a quantum associative memory (QuAM) to prepare a superposition of basis encoded values inthe same qubit register [(Leymann and Barzen 2020a)](http://iopscience.iop.org/10.1088/2058-9565/abae7d).  Note that the quantum register is an equally weighted superposition of the basis encoded values.\nBoth branches have a load and a storage part (see sketch). An additional element is first prepared into the loadpart of both branches. Next, the processing branch is split in such a manner, that the new element gets a properamplitude such that it can be brought into superposition with the already added elements. Finally, an [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc) cleans the processing branch to be ready for the next iteration (see [(Ventura and Martinez 2000)](https://www.sciencedirect.com/science/article/pii/S0020025599001012) for details. )\n\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/quam_solution.png)\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [Data Encoding Patterns for Quantum Algorithms.](https://hillside.net/plop/2020/papers/weigold.pdf) In: The Hillside Group (Hrsg): Proceedings of the 27th Conference on Pattern Languages of Programs (PLoP '20).&quot;, &quot;Variants&quot;: &quot;Enter your input for this section here.&quot;, &quot;Known Uses&quot;: &quot;The presented state preparation routine based on [(Ventura and Martinez 2000)](https://www.sciencedirect.com/science/article/pii/S0020025599001012) can be used whenever multiple data values need to be represented in  [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750). Shor’s algorithm [(Shor 1999)](https://epubs.siam.org/doi/abs/10.1137/S0036144598347011) for the factorization of prime numbers, a quantum version of the Fourier transform [(Coppersmith 2002)](http://arxiv.org/abs/quant-ph/0201067), and Grover’s algorithm [(Grover 1996)](http://dx.doi.org/10.1145/237814.237866) for unstructured search rely on this encoding. Various algorithms extend or use Grover’s algorithm and therefore also make use of this encoding.\n\n[Shor's Algorithm (PlanQK)](https://platform.planqk.de/algorithms/e7413acf-c25e-4de8-ab78-75bfc836a839/)\n[Grover's Algorithm (PlanQK)](https://platform.planqk.de/algorithms/86dfd279-db46-4adb-84a7-39bcf1d19d3a/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern refines [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) and makes use of [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc).  [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) creates a superposition of all computational basis states. Each of the computational basis states also represents a value in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750).&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/quam_icon.png"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;Enter your input for this section here.&quot;, &quot;Intent&quot;: &quot;Encode data in a compact manner that do not require calculations&quot;, &quot;Result&quot;: &quot;The resulting encoding is a digital encoding and therefore suitable for arithmetic computations [(Leymann and Barzen 2020)](http://iopscience.iop.org/10.1088/2058-9565/abae7d). For input $n$ numbers that are approximated by $l$ digits, $l$ qubits are needed for this representation. Each of then encoded input values is represented by a basis vector with an amplitude of1√n.All other $2^{l−n}$ amplitudes of the register are zero - in our example, $|000\\rangle$, $|001\\rangle$,$|100\\rangle$,$|101\\rangle$, and $|111\\rangle$. The amplitude vector is therefore often sparse for this encoding [(Schuld and Petruccione 2018)](http://dx.doi.org/10.1007/978-3-319-96424-9). &quot;, &quot;Context&quot;: &quot;A quantum algorithm requires multiple numerical values $X$ as input for further calculations.&quot;, &quot;Solution&quot;: &quot;Use a quantum associative memory (QuAM) to prepare a superposition of basis encoded values inthe same qubit register [(Leymann and Barzen 2020a)](http://iopscience.iop.org/10.1088/2058-9565/abae7d).  Note that the quantum register is an equally weighted superposition of the basis encoded values.\nBoth branches have a load and a storage part (see sketch). An additional element is first prepared into the loadpart of both branches. Next, the processing branch is split in such a manner, that the new element gets a properamplitude such that it can be brought into superposition with the already added elements. Finally, an [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc) cleans the processing branch to be ready for the next iteration (see [(Ventura and Martinez 2000)](https://www.sciencedirect.com/science/article/pii/S0020025599001012) for details. )\n\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/quam_solution.png)\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [Data Encoding Patterns for Quantum Algorithms.](https://hillside.net/plop/2020/papers/weigold.pdf) In: The Hillside Group (Hrsg): Proceedings of the 27th Conference on Pattern Languages of Programs (PLoP '20).&quot;, &quot;Variants&quot;: &quot;Enter your input for this section here.&quot;, &quot;Known Uses&quot;: &quot;The presented state preparation routine based on [(Ventura and Martinez 2000)](https://www.sciencedirect.com/science/article/pii/S0020025599001012) can be used whenever multiple data values need to be represented in  [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750). Shor’s algorithm [(Shor 1999)](https://epubs.siam.org/doi/abs/10.1137/S0036144598347011) for the factorization of prime numbers, a quantum version of the Fourier transform [(Coppersmith 2002)](http://arxiv.org/abs/quant-ph/0201067), and Grover’s algorithm [(Grover 1996)](http://dx.doi.org/10.1145/237814.237866) for unstructured search rely on this encoding. Various algorithms extend or use Grover’s algorithm and therefore also make use of this encoding.\n\n[Shor's Algorithm (PlanQK)](https://platform.planqk.de/algorithms/e7413acf-c25e-4de8-ab78-75bfc836a839/)\n[Grover's Algorithm (PlanQK)](https://platform.planqk.de/algorithms/86dfd279-db46-4adb-84a7-39bcf1d19d3a/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern refines [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) and makes use of [Uncompute](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d4f7c247-e2bb-4301-ad06-f758fa58f2dc).  [Uniform Superposition](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/2229a430-fe92-4411-9d72-d10dd1d8da14) creates a superposition of all computational basis states. Each of the computational basis states also represents a value in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750).&quot;}"/>
            <where>id='482714a7-8409-4165-93fe-72b02c2ae99c'</where>
        </update>
        <update tableName="pattern">
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/quantum_classic_split_icon.png"/>
            <where>id='dd15032b-ce2b-40b6-80ac-97623255b531'</where>
        </update>
        <update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;Enter your input for this section here.&quot;, &quot;Intent&quot;: &quot; \&quot;Use a quantum random access memory to access a superposition of data values at once\&quot; [(Weigold et al. 2021)](https://ieeexplore.ieee.org/document/9425837/)\n\n&quot;, &quot;Result&quot;: &quot;To apply this encoding, $l$ qubits are needed to represent the data values in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750). \nFor the address register, additionally $\\lceil log(n) \\rceil$ qubits are needed containing up to $n$ addresses. \nSince \\textsc{Basis Encoding} is used to represent the data values, the computational properties are similar to other digital encodings (e.g., [Quantum Associative Memory (QuAM)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/482714a7-8409-4165-93fe-72b02c2ae99c) and [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750)): \nSince a set of data values is represented in superposition, the data values can be manipulated at once (using quantum parallelism). \nFurthermore, multiple arithmetic operations (e.g., addition or multiplication) for [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750) are known that can also be applied to values in superposition.\n \n\nNote that algorithms that specify the usage of a QRAM share the following assumption: \nState preparation via the QRAM is efficient and, therefore, of logarithmic runtime [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232). \nHowever, to our best knowledge, there are currently no commercial hardware implementations for QRAM.\nThus, a different state preparation routine has to load the data in the specified encoding. \nA major disadvantage today is that currently no state preparation routine for an arbitrary state is known to be as efficient as the logarithmic runtime of a QRAM. \nAs a result, a theoretically exponential speed-up of an algorithm using QRAM is only possible if the state preparation can be realized by an efficient state preparation method. \n\n&quot;, &quot;Context&quot;: &quot;For accessing the values of input data, a random access memory is needed.\n\n&quot;, &quot;Solution&quot;: &quot;When a classical random access memory (RAM) gets an address to a memory index, it transfers the data value stored at this address into a specified output register. \nThe functionality of quantum random access memory (QRAM) is similar, however, the registers are not classical but quantum registers [(Johnston, Harrigan and Gimeno-Segovia 2019)](https://www.oreilly.com/library/view/programming-quantum-computers/9781492039679/). \nConsequently, the address and output registers can be in  superposition instead of only single values.\nThe solution sketch demonstrates the loading process of a QRAM [(Giovannetti, Lloyd and Maccone 2008)](https://arxiv.org/abs/0708.1879) holding a superposition of the first two addresses ($\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\frac{1}{\\sqrt{2}}\\state{00} + \\frac{1}{\\sqrt{2}}\\state{01})$ as input register. \nLoading the data values of the corresponding addresses results in the following state:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{\\psi} = \\frac{1}{\\sqrt{2}} \\state{00}\\state{010} + \\frac{1}{\\sqrt{2}}\\state{01}\\state{110}\n$$  \n\n\nLoading $m$ of $n$ data values using a QRAM can be generalized as follows [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232): \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\n  \\frac{1}{\\sqrt{m}}\\sum_{i=0}^{m-1}\n    \\state{a}_i\\state{0} \\ \\underrightarrow{QRAM}  \\frac{1}{\\sqrt{m}}\\sum_{i=0}^{m-1}\n \\state{a}_i\\state{x_a}\n $$  \n\n\nThereby,  the  first register specifies the  address  register  containing a  superposition  of $m$ addresses, and the second register is specified as output register.\nFurthermore, $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{a}_i$ denotes the $i$-th data value address which has to be loaded \nand $x_a$ is the data value stored at this address.\nThe task of the QRAM is to load each data value $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{x_a}$ of the addresses in the first register to the output register. \nConsequently, $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{a}_i\\state{x_a}$ is part of the combined output state of both registers.\nIn dependence of the address values and their corresponding data values, this could create entanglement.\n\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/qram_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [“Expanding Data Encoding Patterns For Quantum Algorithms.”](https://ieeexplore.ieee.org/document/9425837/) In: 2021 IEEE 18th International Conference on Software Architecture Companion (ICSA-C), IEEE, 2021.&quot;, &quot;Variants&quot;: &quot;Enter your input for this section here.&quot;, &quot;Known Uses&quot;: &quot;An alternative state preparation to realize [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13) can be found in [(Cortese and Braje 2018)](https://arxiv.org/abs/1803.01958) (circuit family \\#3) or [(Prakash 2014)](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2014/EECS-2014-211.pdf).\nAlgorithms for solving semi-definite programs [(Mitarai, Kitagawa and Fujii 2019)](http://arxiv.org/pdf/1805.11250v2)  use [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13). \nA QRAM is required or assumed in various other algorithms [(Giovannetti, Lloyd and Maccone 2008)](https://arxiv.org/abs/0708.1879), [(Rebentrost, Mohseni and Lloyd 2014)](http://www.ncbi.nlm.nih.gov/pubmed/25302877) , [(Wiebe, Kapoor and Svore 2014)](https://arxiv.org/abs/1412.3489), [(Lloyd, Mohseni and Rebentrost 2013)](https://arxiv.org/abs/1307.0401). \nA prominent example of an algorithm that uses this encoding is the HHL algorithm for solving linear equations [(Harrow, Hassidim and Lloyd 2009)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502) which uses [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13) as an intermediate representation for eigenvalues [(Mitarai, Kitagawa and Fujii 2019)](http://arxiv.org/pdf/1805.11250v2).  \n\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)\n&quot;, &quot;Related Patterns&quot;: &quot;This pattern is a refinement of [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) which makes use of [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750). Since the address and output register of QRAM Encoding may be entangled, [Creating Entanglement](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3d1f3991-df47-4d42-8f9a-e6dcf4e3ccec) can be realized with this pattern.&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/qram_icon.png"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;Enter your input for this section here.&quot;, &quot;Intent&quot;: &quot; \&quot;Use a quantum random access memory to access a superposition of data values at once\&quot; [(Weigold et al. 2021)](https://ieeexplore.ieee.org/document/9425837/)\n\n&quot;, &quot;Result&quot;: &quot;To apply this encoding, $l$ qubits are needed to represent the data values in [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750). \nFor the address register, additionally $\\lceil log(n) \\rceil$ qubits are needed containing up to $n$ addresses. \nSince \\textsc{Basis Encoding} is used to represent the data values, the computational properties are similar to other digital encodings (e.g., [Quantum Associative Memory (QuAM)](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/482714a7-8409-4165-93fe-72b02c2ae99c) and [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750)): \nSince a set of data values is represented in superposition, the data values can be manipulated at once (using quantum parallelism). \nFurthermore, multiple arithmetic operations (e.g., addition or multiplication) for [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750) are known that can also be applied to values in superposition.\n \n\nNote that algorithms that specify the usage of a QRAM share the following assumption: \nState preparation via the QRAM is efficient and, therefore, of logarithmic runtime [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232). \nHowever, to our best knowledge, there are currently no commercial hardware implementations for QRAM.\nThus, a different state preparation routine has to load the data in the specified encoding. \nA major disadvantage today is that currently no state preparation routine for an arbitrary state is known to be as efficient as the logarithmic runtime of a QRAM. \nAs a result, a theoretically exponential speed-up of an algorithm using QRAM is only possible if the state preparation can be realized by an efficient state preparation method. \n\n&quot;, &quot;Context&quot;: &quot;For accessing the values of input data, a random access memory is needed.\n\n&quot;, &quot;Solution&quot;: &quot;When a classical random access memory (RAM) gets an address to a memory index, it transfers the data value stored at this address into a specified output register. \nThe functionality of quantum random access memory (QRAM) is similar, however, the registers are not classical but quantum registers [(Johnston, Harrigan and Gimeno-Segovia 2019)](https://www.oreilly.com/library/view/programming-quantum-computers/9781492039679/). \nConsequently, the address and output registers can be in  superposition instead of only single values.\nThe solution sketch demonstrates the loading process of a QRAM [(Giovannetti, Lloyd and Maccone 2008)](https://arxiv.org/abs/0708.1879) holding a superposition of the first two addresses ($\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\frac{1}{\\sqrt{2}}\\state{00} + \\frac{1}{\\sqrt{2}}\\state{01})$ as input register. \nLoading the data values of the corresponding addresses results in the following state:\n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{\\psi} = \\frac{1}{\\sqrt{2}} \\state{00}\\state{010} + \\frac{1}{\\sqrt{2}}\\state{01}\\state{110}\n$$  \n\n\nLoading $m$ of $n$ data values using a QRAM can be generalized as follows [(Schuld and Petruccione 2018)](https://www.springer.com/gp/book/9783319964232): \n\n\n$$\n\\newcommand{\\colVec}[1]{% inline column vector\n\\bigl( \\begin{smallmatrix}#1\\end{smallmatrix}\\bigr)\n}\n\\newcommand{\\bigColVec}[1]{% inline column vector\n\\left( \\begin{matrix}#1\\end{matrix}\\right)\n}\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\n  \\frac{1}{\\sqrt{m}}\\sum_{i=0}^{m-1}\n    \\state{a}_i\\state{0} \\ \\underrightarrow{QRAM}  \\frac{1}{\\sqrt{m}}\\sum_{i=0}^{m-1}\n \\state{a}_i\\state{x_a}\n $$  \n\n\nThereby,  the  first register specifies the  address  register  containing a  superposition  of $m$ addresses, and the second register is specified as output register.\nFurthermore, $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{a}_i$ denotes the $i$-th data value address which has to be loaded \nand $x_a$ is the data value stored at this address.\nThe task of the QRAM is to load each data value $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{x_a}$ of the addresses in the first register to the output register. \nConsequently, $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{a}_i\\state{x_a}$ is part of the combined output state of both registers.\nIn dependence of the address values and their corresponding data values, this could create entanglement.\n\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/qram_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; Salm, Marie: [“Expanding Data Encoding Patterns For Quantum Algorithms.”](https://ieeexplore.ieee.org/document/9425837/) In: 2021 IEEE 18th International Conference on Software Architecture Companion (ICSA-C), IEEE, 2021.&quot;, &quot;Variants&quot;: &quot;Enter your input for this section here.&quot;, &quot;Known Uses&quot;: &quot;An alternative state preparation to realize [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13) can be found in [(Cortese and Braje 2018)](https://arxiv.org/abs/1803.01958) (circuit family \\#3) or [(Prakash 2014)](https://www2.eecs.berkeley.edu/Pubs/TechRpts/2014/EECS-2014-211.pdf).\nAlgorithms for solving semi-definite programs [(Mitarai, Kitagawa and Fujii 2019)](http://arxiv.org/pdf/1805.11250v2)  use [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13). \nA QRAM is required or assumed in various other algorithms [(Giovannetti, Lloyd and Maccone 2008)](https://arxiv.org/abs/0708.1879), [(Rebentrost, Mohseni and Lloyd 2014)](http://www.ncbi.nlm.nih.gov/pubmed/25302877) , [(Wiebe, Kapoor and Svore 2014)](https://arxiv.org/abs/1412.3489), [(Lloyd, Mohseni and Rebentrost 2013)](https://arxiv.org/abs/1307.0401). \nA prominent example of an algorithm that uses this encoding is the HHL algorithm for solving linear equations [(Harrow, Hassidim and Lloyd 2009)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502) which uses [Quantum Random Access Memory (QRAM) Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/d9c57511-1101-4707-99bf-36f43a12cb13) as an intermediate representation for eigenvalues [(Mitarai, Kitagawa and Fujii 2019)](http://arxiv.org/pdf/1805.11250v2).  \n\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)\n&quot;, &quot;Related Patterns&quot;: &quot;This pattern is a refinement of [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) which makes use of [Basis Encoding](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/bcd4c7a1-3c92-4f8c-a530-72b8b95d3750). Since the address and output register of QRAM Encoding may be entangled, [Creating Entanglement](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/3d1f3991-df47-4d42-8f9a-e6dcf4e3ccec) can be realized with this pattern.&quot;}"/>
            <where>id='d9c57511-1101-4707-99bf-36f43a12cb13'</where>
        </update>
        <update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;Phase estimation algorithm (PEA)&quot;, &quot;Intent&quot;: &quot;Approximate the eigenvalue of a unitary matrix.&quot;, &quot;Result&quot;: &quot;If $\\varphi$ is a rational number, the ancilla register contains the eigenvalue in [Basis Encoding](#/patterns/0) (assuming a proper number of anchillae). Otherwise, an approximation is produced with a probability of at least $\\frac{4}{\\pi}$. Increasing the precision of the approximation by adding more ancillae is costly because this also increases the number of required controlled-$U$ operations. Because  of  these  demanding  hardware requirements, this algorithm is often regarded as non-suitable for NISQ devices.&quot;, &quot;Context&quot;: &quot;Given a unitary matrix $U$ and one of its eigenstates, the corresponding eigenvalue should be determined. The eigenstate $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{v}$ is given on a register in [Basis Encoding](#/patterns/0). Applying $U$ to the eigenstate $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{v}$ results in a global phase: \n$$U\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{v} = e^{2\\pi i \\varphi} \\state{v}$$\nwhere the eigenvalue $\\lambda = e^{2\\pi i \\varphi}$ is uniquely determined by $\\varphi \\in [0,1]$. Therefore, it is sufficient to estimate $\\varphi$.&quot;, &quot;Solution&quot;: &quot;Use the circuit shown in the pattern sketch to estimate the approximation of $\\theta$. First, a register of $m$ ancillae is brought into an [Uniform Superposition](#/patterns/16). Next, controlled versions of powers of $U$ are applied on the register of the eigenstate following the scheme depicted inthe pattern sketch. Each application of a controlled-$U$ operation results in a _phase kickback_ of the control qubit, i.e., this qubit acquires a relative phase of $\\varphi$. This results in the overall state:\n$$\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi} = \n    \\sum_{y=0}^{2^m-1}e^{2\\pi \\varphi y}\\state{y}$$\n where $\\varphi$ is encoded in the relative phase. \nTo extract this information, the inverse of the quantum fourier transformation is applied on the ancilla register. &quot;, &quot;Variants&quot;: &quot;The second register can also be initialized as an arbitrary quantum state which is always a linear combination of eigenvectors. In this case, the algorithm approximates a superposition of eigenvalues for these eigenvectors in the output register. Other variants of this algorithm further improve the depth of the circuit or require fewer measurements. &quot;, &quot;Known Uses&quot;: &quot;_Quantum Phase Estimation_ is at the heart of many algorithms [[Cleve et al. 1998](https://royalsocietypublishing.org/doi/abs/10.1098/rspa.1998.0164)]. One prominent example which we review in a later section is the HHL algorithm [[Harrow, Hassidim and Lloyd 2009](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502)]. Other QML algorithms follow a similar scheme [[Schuld and Petruccione 2018](http://dx.doi.org/10.1007/978-3-319-96424-9), [Duan et al. 2020](https://www.sciencedirect.com/science/article/abs/pii/S037596012030462X)], e.g., quantum support vector machine (QSVM) [[Rebentrost et al. 2014](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.113.130503)] or quantum principal component analysis (QPCA) [[Lloyd et al. 2014](https://www.nature.com/articles/nphys3029)]. [Qiskit]( https://qiskit.org/documentation/stubs/qiskit.circuit.library.PhaseEstimation.html) provides an implementation for this pattern.\n\n[Shor's Algorithm (PlanQK)](https://platform.planqk.de/algorithms/e7413acf-c25e-4de8-ab78-75bfc836a839/)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern uses [Amplitude Encoding](#/patterns/2) and [Matrix Encoding](#/patterns/11) and produces an output in [Basis Encoding](#/patterns/0).&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/qpe_icon.png"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;Phase estimation algorithm (PEA)&quot;, &quot;Intent&quot;: &quot;Approximate the eigenvalue of a unitary matrix.&quot;, &quot;Result&quot;: &quot;If $\\varphi$ is a rational number, the ancilla register contains the eigenvalue in [Basis Encoding](#/patterns/0) (assuming a proper number of anchillae). Otherwise, an approximation is produced with a probability of at least $\\frac{4}{\\pi}$. Increasing the precision of the approximation by adding more ancillae is costly because this also increases the number of required controlled-$U$ operations. Because  of  these  demanding  hardware requirements, this algorithm is often regarded as non-suitable for NISQ devices.&quot;, &quot;Context&quot;: &quot;Given a unitary matrix $U$ and one of its eigenstates, the corresponding eigenvalue should be determined. The eigenstate $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{v}$ is given on a register in [Basis Encoding](#/patterns/0). Applying $U$ to the eigenstate $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{v}$ results in a global phase: \n$$U\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\\state{v} = e^{2\\pi i \\varphi} \\state{v}$$\nwhere the eigenvalue $\\lambda = e^{2\\pi i \\varphi}$ is uniquely determined by $\\varphi \\in [0,1]$. Therefore, it is sufficient to estimate $\\varphi$.&quot;, &quot;Solution&quot;: &quot;Use the circuit shown in the pattern sketch to estimate the approximation of $\\theta$. First, a register of $m$ ancillae is brought into an [Uniform Superposition](#/patterns/16). Next, controlled versions of powers of $U$ are applied on the register of the eigenstate following the scheme depicted inthe pattern sketch. Each application of a controlled-$U$ operation results in a _phase kickback_ of the control qubit, i.e., this qubit acquires a relative phase of $\\varphi$. This results in the overall state:\n$$\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi} = \n    \\sum_{y=0}^{2^m-1}e^{2\\pi \\varphi y}\\state{y}$$\n where $\\varphi$ is encoded in the relative phase. \nTo extract this information, the inverse of the quantum fourier transformation is applied on the ancilla register. &quot;, &quot;Variants&quot;: &quot;The second register can also be initialized as an arbitrary quantum state which is always a linear combination of eigenvectors. In this case, the algorithm approximates a superposition of eigenvalues for these eigenvectors in the output register. Other variants of this algorithm further improve the depth of the circuit or require fewer measurements. &quot;, &quot;Known Uses&quot;: &quot;_Quantum Phase Estimation_ is at the heart of many algorithms [[Cleve et al. 1998](https://royalsocietypublishing.org/doi/abs/10.1098/rspa.1998.0164)]. One prominent example which we review in a later section is the HHL algorithm [[Harrow, Hassidim and Lloyd 2009](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.150502)]. Other QML algorithms follow a similar scheme [[Schuld and Petruccione 2018](http://dx.doi.org/10.1007/978-3-319-96424-9), [Duan et al. 2020](https://www.sciencedirect.com/science/article/abs/pii/S037596012030462X)], e.g., quantum support vector machine (QSVM) [[Rebentrost et al. 2014](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.113.130503)] or quantum principal component analysis (QPCA) [[Lloyd et al. 2014](https://www.nature.com/articles/nphys3029)]. [Qiskit]( https://qiskit.org/documentation/stubs/qiskit.circuit.library.PhaseEstimation.html) provides an implementation for this pattern.\n\n[Shor's Algorithm (PlanQK)](https://platform.planqk.de/algorithms/e7413acf-c25e-4de8-ab78-75bfc836a839/)\n[HHL Algorithm (PlanQK)](https://platform.planqk.de/algorithms/8c6909bd-a258-4702-8356-6ef28321a826/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern uses [Amplitude Encoding](#/patterns/2) and [Matrix Encoding](#/patterns/11) and produces an output in [Basis Encoding](#/patterns/0).&quot;}"/>
            <where>id='a4ea9f6c-5b0a-4beb-a056-8b261d96ba80'</where>
        </update>
        <update tableName="pattern">
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/speedup_by_verification_icon.png"/>
            <where>id='ddd64fb6-b324-45eb-8e21-8193dc311841'</where>
        </update>
        <update tableName="pattern">
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/vqe_icon.png"/>
            <where>id='27a5d147-a323-4c6a-84ef-45d80cae923d'</where>
        </update>
        <update tableName="pattern">
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/warmstart_icon.png"/>
            <where>id='3ea9e187-e91b-4852-84eb-b35b5c480892'</where>
        </update>
        <update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;\&quot;Optimize the parameters of a quantum circuit on a classical computer\&quot; [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)\n\n&quot;, &quot;Result&quot;: &quot;However, choosing $f$, the observables for measuring the qubits and an ansatz is not trivial.\nThe convergence of the algorithm depends on multiple factors: the objective function and the optimization strategy for updating the parameters. \nRegarding the objective function, one major obstacle for the convergence of the solution are regions of the function which contain only a small norm of the gradient (these regions are also referred to as *barren plateaus*). \nThese regions can significantly influence how fast the solution converges [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265) or in the worst case, result in non-convergence of the algorithm. \nSince the optimization procedure is performed classically, the classical computation can impact the overall runtime. \n\n&quot;, &quot;Context&quot;: &quot;The best solution for a problem must be found or approximated across all possible solutions. \nAn individual solution can be evaluated by an objective function $C$ that is also given.  \nBy definition, this function is *faithful*, i.e, its minimum value indicates the best solution [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265). \nPreferably, $C$ is also *operationally meaningful* which means that solutions can be compared: smaller values of $C$ also indicate better solutions. \nSince the number of possible solutions increases exponentially with the size of the problems, it is too expensive in terms of computations to evaluate all possible solutions. \n\n&quot;, &quot;Solution&quot;: &quot;A hybrid setup is used to evaluate and optimize solutions. \nOn the quantum computer, an initial state is created that may also encode or be varied according to a set of input data $x$ (refer to the quantum circuit in the upper part of the solution sketch). \nOn this state, an ansatz $U(\\theta)$ is applied which is a circuit that depends on a set of parameters $\\theta$. \nThis results in the  $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$ state. \nA canonical example of an ansatz is to apply multiple one-qubit operations defining a rotation in the Bloch Sphere around a rotation angle that depends on $\\theta$.\nHowever, plenty of other parameterized circuits have been proposed as an ansatz. \nThen, based on the expectation values of the output state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$, the objective function $C$ for the parameter values $\\theta$ is calculated by the classical computer: \n\n\n$$\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\nC(\\theta)=\\sum_i f_i(\\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}})\n$$  \n\n\nwhere $O_i$ is the observable and $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}}$ the expectation value of the $i$-th measurement to which the function $f$ assigns an overall cost.\nIf $C(\\theta)$ is sufficiently low, i.e., the termination criteria are fulfilled, the algorithm ends. \nOtherwise, the parameter set $\\theta$ is optimized further for the next iteration. \n\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/variational_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;A plethora of algorithms make use of this pattern, e.g., in quantum machine learning this technique was used for developing quantum classifiers [(Mitarai et al. 2018)](https://arxiv.org/abs/1803.00745v3), \nas well as a quantum version of neural networks [(Farhi and Neven 2018)](https://arxiv.org/abs/1802.06002) or support vector machine [(Havlíček et al. 2019)](https://www.nature.com/articles/s41586-019-0980-2), [(Schuld and Killoran 2019)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.040504). \nA variational algorithm for factorization has been presented in [(Anschuetz et al. 2018)](https://arxiv.org/abs/1808.08927). \n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n[Variational Quantum Eigensolver (PlanQK)](https://platform.planqk.de/algorithms/28fbfa6b-329b-4d99-8c75-f9dbdd365a4f/)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern is a refinement of [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf). \nWithin the quantum computation, [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf) is used.  \n \n&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/vqa_icon.png"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;\&quot;Optimize the parameters of a quantum circuit on a classical computer\&quot; [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)\n\n&quot;, &quot;Result&quot;: &quot;However, choosing $f$, the observables for measuring the qubits and an ansatz is not trivial.\nThe convergence of the algorithm depends on multiple factors: the objective function and the optimization strategy for updating the parameters. \nRegarding the objective function, one major obstacle for the convergence of the solution are regions of the function which contain only a small norm of the gradient (these regions are also referred to as *barren plateaus*). \nThese regions can significantly influence how fast the solution converges [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265) or in the worst case, result in non-convergence of the algorithm. \nSince the optimization procedure is performed classically, the classical computation can impact the overall runtime. \n\n&quot;, &quot;Context&quot;: &quot;The best solution for a problem must be found or approximated across all possible solutions. \nAn individual solution can be evaluated by an objective function $C$ that is also given.  \nBy definition, this function is *faithful*, i.e, its minimum value indicates the best solution [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265). \nPreferably, $C$ is also *operationally meaningful* which means that solutions can be compared: smaller values of $C$ also indicate better solutions. \nSince the number of possible solutions increases exponentially with the size of the problems, it is too expensive in terms of computations to evaluate all possible solutions. \n\n&quot;, &quot;Solution&quot;: &quot;A hybrid setup is used to evaluate and optimize solutions. \nOn the quantum computer, an initial state is created that may also encode or be varied according to a set of input data $x$ (refer to the quantum circuit in the upper part of the solution sketch). \nOn this state, an ansatz $U(\\theta)$ is applied which is a circuit that depends on a set of parameters $\\theta$. \nThis results in the  $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$ state. \nA canonical example of an ansatz is to apply multiple one-qubit operations defining a rotation in the Bloch Sphere around a rotation angle that depends on $\\theta$.\nHowever, plenty of other parameterized circuits have been proposed as an ansatz. \nThen, based on the expectation values of the output state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$, the objective function $C$ for the parameter values $\\theta$ is calculated by the classical computer: \n\n\n$$\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\nC(\\theta)=\\sum_i f_i(\\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}})\n$$  \n\n\nwhere $O_i$ is the observable and $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}}$ the expectation value of the $i$-th measurement to which the function $f$ assigns an overall cost.\nIf $C(\\theta)$ is sufficiently low, i.e., the termination criteria are fulfilled, the algorithm ends. \nOtherwise, the parameter set $\\theta$ is optimized further for the next iteration. \n\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/variational_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;A plethora of algorithms make use of this pattern, e.g., in quantum machine learning this technique was used for developing quantum classifiers [(Mitarai et al. 2018)](https://arxiv.org/abs/1803.00745v3), \nas well as a quantum version of neural networks [(Farhi and Neven 2018)](https://arxiv.org/abs/1802.06002) or support vector machine [(Havlíček et al. 2019)](https://www.nature.com/articles/s41586-019-0980-2), [(Schuld and Killoran 2019)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.040504). \nA variational algorithm for factorization has been presented in [(Anschuetz et al. 2018)](https://arxiv.org/abs/1808.08927). \n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n[Variational Quantum Eigensolver (PlanQK)](https://platform.planqk.de/algorithms/28fbfa6b-329b-4d99-8c75-f9dbdd365a4f/)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern is a refinement of [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf). \nWithin the quantum computation, [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf) is used.  \n \n&quot;}"/>
            <where>id='bc795a9b-7977-4e01-b513-f9f5aba38aa7'</where>
        </update>
        <update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;\&quot;Optimize the parameters of a quantum circuit on a classical computer\&quot; [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)\n\n&quot;, &quot;Result&quot;: &quot;However, choosing $f$, the observables for measuring the qubits and an ansatz is not trivial.\nThe convergence of the algorithm depends on multiple factors: the objective function and the optimization strategy for updating the parameters. \nRegarding the objective function, one major obstacle for the convergence of the solution are regions of the function which contain only a small norm of the gradient (these regions are also referred to as *barren plateaus*). \nThese regions can significantly influence how fast the solution converges [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265) or in the worst case, result in non-convergence of the algorithm. \nSince the optimization procedure is performed classically, the classical computation can impact the overall runtime. \n\n&quot;, &quot;Context&quot;: &quot;The best solution for a problem must be found or approximated across all possible solutions. \nAn individual solution can be evaluated by an objective function $C$ that is also given.  \nBy definition, this function is *faithful*, i.e, its minimum value indicates the best solution [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265). \nPreferably, $C$ is also *operationally meaningful* which means that solutions can be compared: smaller values of $C$ also indicate better solutions. \nSince the number of possible solutions increases exponentially with the size of the problems, it is too expensive in terms of computations to evaluate all possible solutions. \n\n&quot;, &quot;Solution&quot;: &quot;A hybrid setup is used to evaluate and optimize solutions. \nOn the quantum computer, an initial state is created that may also encode or be varied according to a set of input data $x$ (refer to the quantum circuit in the upper part of the solution sketch). \nOn this state, an ansatz $U(\\theta)$ is applied which is a circuit that depends on a set of parameters $\\theta$. \nThis results in the  $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$ state. \nA canonical example of an ansatz is to apply multiple one-qubit operations defining a rotation in the Bloch Sphere around a rotation angle that depends on $\\theta$.\nHowever, plenty of other parameterized circuits have been proposed as an ansatz. \nThen, based on the expectation values of the output state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$, the objective function $C$ for the parameter values $\\theta$ is calculated by the classical computer: \n\n\n$$\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\nC(\\theta)=\\sum_i f_i(\\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}})\n$$  \n\n\nwhere $O_i$ is the observable and $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}}$ the expectation value of the $i$-th measurement to which the function $f$ assigns an overall cost.\nIf $C(\\theta)$ is sufficiently low, i.e., the termination criteria are fulfilled, the algorithm ends. \nOtherwise, the parameter set $\\theta$ is optimized further for the next iteration. \n\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/variational_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;A plethora of algorithms make use of this pattern, e.g., in quantum machine learning this technique was used for developing quantum classifiers [(Mitarai et al. 2018)](https://arxiv.org/abs/1803.00745v3), \nas well as a quantum version of neural networks [(Farhi and Neven 2018)](https://arxiv.org/abs/1802.06002) or support vector machine [(Havlíček et al. 2019)](https://www.nature.com/articles/s41586-019-0980-2), [(Schuld and Killoran 2019)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.040504). \nA variational algorithm for factorization has been presented in [(Anschuetz et al. 2018)](https://arxiv.org/abs/1808.08927). \n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n[Variational Quantum Eigensolver (PlanQK)](https://platform.planqk.de/algorithms/28fbfa6b-329b-4d99-8c75-f9dbdd365a4f/)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern is a refinement of [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf). \nWithin the quantum computation, [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf) is used.  \n \n&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/kmeans_icon.png"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;\&quot;Optimize the parameters of a quantum circuit on a classical computer\&quot; [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)\n\n&quot;, &quot;Result&quot;: &quot;However, choosing $f$, the observables for measuring the qubits and an ansatz is not trivial.\nThe convergence of the algorithm depends on multiple factors: the objective function and the optimization strategy for updating the parameters. \nRegarding the objective function, one major obstacle for the convergence of the solution are regions of the function which contain only a small norm of the gradient (these regions are also referred to as *barren plateaus*). \nThese regions can significantly influence how fast the solution converges [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265) or in the worst case, result in non-convergence of the algorithm. \nSince the optimization procedure is performed classically, the classical computation can impact the overall runtime. \n\n&quot;, &quot;Context&quot;: &quot;The best solution for a problem must be found or approximated across all possible solutions. \nAn individual solution can be evaluated by an objective function $C$ that is also given.  \nBy definition, this function is *faithful*, i.e, its minimum value indicates the best solution [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265). \nPreferably, $C$ is also *operationally meaningful* which means that solutions can be compared: smaller values of $C$ also indicate better solutions. \nSince the number of possible solutions increases exponentially with the size of the problems, it is too expensive in terms of computations to evaluate all possible solutions. \n\n&quot;, &quot;Solution&quot;: &quot;A hybrid setup is used to evaluate and optimize solutions. \nOn the quantum computer, an initial state is created that may also encode or be varied according to a set of input data $x$ (refer to the quantum circuit in the upper part of the solution sketch). \nOn this state, an ansatz $U(\\theta)$ is applied which is a circuit that depends on a set of parameters $\\theta$. \nThis results in the  $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$ state. \nA canonical example of an ansatz is to apply multiple one-qubit operations defining a rotation in the Bloch Sphere around a rotation angle that depends on $\\theta$.\nHowever, plenty of other parameterized circuits have been proposed as an ansatz. \nThen, based on the expectation values of the output state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$, the objective function $C$ for the parameter values $\\theta$ is calculated by the classical computer: \n\n\n$$\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\nC(\\theta)=\\sum_i f_i(\\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}})\n$$  \n\n\nwhere $O_i$ is the observable and $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}}$ the expectation value of the $i$-th measurement to which the function $f$ assigns an overall cost.\nIf $C(\\theta)$ is sufficiently low, i.e., the termination criteria are fulfilled, the algorithm ends. \nOtherwise, the parameter set $\\theta$ is optimized further for the next iteration. \n\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/variational_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;A plethora of algorithms make use of this pattern, e.g., in quantum machine learning this technique was used for developing quantum classifiers [(Mitarai et al. 2018)](https://arxiv.org/abs/1803.00745v3), \nas well as a quantum version of neural networks [(Farhi and Neven 2018)](https://arxiv.org/abs/1802.06002) or support vector machine [(Havlíček et al. 2019)](https://www.nature.com/articles/s41586-019-0980-2), [(Schuld and Killoran 2019)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.040504). \nA variational algorithm for factorization has been presented in [(Anschuetz et al. 2018)](https://arxiv.org/abs/1808.08927). \n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n[Variational Quantum Eigensolver (PlanQK)](https://platform.planqk.de/algorithms/28fbfa6b-329b-4d99-8c75-f9dbdd365a4f/)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern is a refinement of [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf). \nWithin the quantum computation, [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf) is used.  \n \n&quot;}"/>
            <where>id='7294c3f2-cb67-492a-8a16-c7384eb9bac2'</where>
        </update>
        <update tableName="pattern">
            <column name="content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;\&quot;Optimize the parameters of a quantum circuit on a classical computer\&quot; [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)\n\n&quot;, &quot;Result&quot;: &quot;However, choosing $f$, the observables for measuring the qubits and an ansatz is not trivial.\nThe convergence of the algorithm depends on multiple factors: the objective function and the optimization strategy for updating the parameters. \nRegarding the objective function, one major obstacle for the convergence of the solution are regions of the function which contain only a small norm of the gradient (these regions are also referred to as *barren plateaus*). \nThese regions can significantly influence how fast the solution converges [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265) or in the worst case, result in non-convergence of the algorithm. \nSince the optimization procedure is performed classically, the classical computation can impact the overall runtime. \n\n&quot;, &quot;Context&quot;: &quot;The best solution for a problem must be found or approximated across all possible solutions. \nAn individual solution can be evaluated by an objective function $C$ that is also given.  \nBy definition, this function is *faithful*, i.e, its minimum value indicates the best solution [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265). \nPreferably, $C$ is also *operationally meaningful* which means that solutions can be compared: smaller values of $C$ also indicate better solutions. \nSince the number of possible solutions increases exponentially with the size of the problems, it is too expensive in terms of computations to evaluate all possible solutions. \n\n&quot;, &quot;Solution&quot;: &quot;A hybrid setup is used to evaluate and optimize solutions. \nOn the quantum computer, an initial state is created that may also encode or be varied according to a set of input data $x$ (refer to the quantum circuit in the upper part of the solution sketch). \nOn this state, an ansatz $U(\\theta)$ is applied which is a circuit that depends on a set of parameters $\\theta$. \nThis results in the  $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$ state. \nA canonical example of an ansatz is to apply multiple one-qubit operations defining a rotation in the Bloch Sphere around a rotation angle that depends on $\\theta$.\nHowever, plenty of other parameterized circuits have been proposed as an ansatz. \nThen, based on the expectation values of the output state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$, the objective function $C$ for the parameter values $\\theta$ is calculated by the classical computer: \n\n\n$$\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\nC(\\theta)=\\sum_i f_i(\\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}})\n$$  \n\n\nwhere $O_i$ is the observable and $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}}$ the expectation value of the $i$-th measurement to which the function $f$ assigns an overall cost.\nIf $C(\\theta)$ is sufficiently low, i.e., the termination criteria are fulfilled, the algorithm ends. \nOtherwise, the parameter set $\\theta$ is optimized further for the next iteration. \n\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/variational_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;A plethora of algorithms make use of this pattern, e.g., in quantum machine learning this technique was used for developing quantum classifiers [(Mitarai et al. 2018)](https://arxiv.org/abs/1803.00745v3), \nas well as a quantum version of neural networks [(Farhi and Neven 2018)](https://arxiv.org/abs/1802.06002) or support vector machine [(Havlíček et al. 2019)](https://www.nature.com/articles/s41586-019-0980-2), [(Schuld and Killoran 2019)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.040504). \nA variational algorithm for factorization has been presented in [(Anschuetz et al. 2018)](https://arxiv.org/abs/1808.08927). \n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n[Variational Quantum Eigensolver (PlanQK)](https://platform.planqk.de/algorithms/28fbfa6b-329b-4d99-8c75-f9dbdd365a4f/)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern is a refinement of [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf). \nWithin the quantum computation, [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf) is used.  \n \n&quot;}"/>
            <column name="icon_url" value="https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/icons/quantum_computing_patterns/qsvm_icon.png"/>
            <column name="rendered_content" value="{&quot;Alias&quot;: &quot;&quot;, &quot;Intent&quot;: &quot;\&quot;Optimize the parameters of a quantum circuit on a classical computer\&quot; [(Weigold et al. 2021)](https://www.springer.com/de/book/9783030648459)\n\n&quot;, &quot;Result&quot;: &quot;However, choosing $f$, the observables for measuring the qubits and an ansatz is not trivial.\nThe convergence of the algorithm depends on multiple factors: the objective function and the optimization strategy for updating the parameters. \nRegarding the objective function, one major obstacle for the convergence of the solution are regions of the function which contain only a small norm of the gradient (these regions are also referred to as *barren plateaus*). \nThese regions can significantly influence how fast the solution converges [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265) or in the worst case, result in non-convergence of the algorithm. \nSince the optimization procedure is performed classically, the classical computation can impact the overall runtime. \n\n&quot;, &quot;Context&quot;: &quot;The best solution for a problem must be found or approximated across all possible solutions. \nAn individual solution can be evaluated by an objective function $C$ that is also given.  \nBy definition, this function is *faithful*, i.e, its minimum value indicates the best solution [(Cerezo et al. 2020)](https://arxiv.org/abs/2012.09265). \nPreferably, $C$ is also *operationally meaningful* which means that solutions can be compared: smaller values of $C$ also indicate better solutions. \nSince the number of possible solutions increases exponentially with the size of the problems, it is too expensive in terms of computations to evaluate all possible solutions. \n\n&quot;, &quot;Solution&quot;: &quot;A hybrid setup is used to evaluate and optimize solutions. \nOn the quantum computer, an initial state is created that may also encode or be varied according to a set of input data $x$ (refer to the quantum circuit in the upper part of the solution sketch). \nOn this state, an ansatz $U(\\theta)$ is applied which is a circuit that depends on a set of parameters $\\theta$. \nThis results in the  $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$ state. \nA canonical example of an ansatz is to apply multiple one-qubit operations defining a rotation in the Bloch Sphere around a rotation angle that depends on $\\theta$.\nHowever, plenty of other parameterized circuits have been proposed as an ansatz. \nThen, based on the expectation values of the output state $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\state{\\psi_{out}(x,\\theta)}$, the objective function $C$ for the parameter values $\\theta$ is calculated by the classical computer: \n\n\n$$\n\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}}\nC(\\theta)=\\sum_i f_i(\\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}})\n$$  \n\n\nwhere $O_i$ is the observable and $\\newcommand{\\state}[1]{{\\left| #1 \\right&gt;}} \\left&lt;O_i\\right&gt;_{\\state{\\psi_{out}(x,\\theta)}}$ the expectation value of the $i$-th measurement to which the function $f$ assigns an overall cost.\nIf $C(\\theta)$ is sufficiently low, i.e., the termination criteria are fulfilled, the algorithm ends. \nOtherwise, the parameter set $\\theta$ is optimized further for the next iteration. \n\n![](https://raw.githubusercontent.com/PatternAtlas/pattern-atlas-content/main/sketches/quantum_computing_patterns/variational_solution.png)\n\nPattern sketch, taken from: Weigold, Manuela; Barzen, Johanna; Leymann, Frank; and Vietz, Daniel: [Patterns For Hybrid Quantum Algorithms.](https://doi.org/10.1007/978-3-030-87568-8_2) In: Proceedings of the 15th Symposium and Summer School on Service-Oriented Computing (SummerSOC 2021).&quot;, &quot;Variants&quot;: &quot;&quot;, &quot;Known Uses&quot;: &quot;A plethora of algorithms make use of this pattern, e.g., in quantum machine learning this technique was used for developing quantum classifiers [(Mitarai et al. 2018)](https://arxiv.org/abs/1803.00745v3), \nas well as a quantum version of neural networks [(Farhi and Neven 2018)](https://arxiv.org/abs/1802.06002) or support vector machine [(Havlíček et al. 2019)](https://www.nature.com/articles/s41586-019-0980-2), [(Schuld and Killoran 2019)](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.040504). \nA variational algorithm for factorization has been presented in [(Anschuetz et al. 2018)](https://arxiv.org/abs/1808.08927). \n\n[Quantum approximate optimization algorithm (PlanQK)](https://platform.planqk.de/algorithms/fae60bca-d2b6-4aa2-88b7-58caace34179/)\n[Variational Quantum Eigensolver (PlanQK)](https://platform.planqk.de/algorithms/28fbfa6b-329b-4d99-8c75-f9dbdd365a4f/)\n[Hybrid Transfer Learning (PlanQK)](https://platform.planqk.de/algorithms/2803f6d4-094e-4aa9-b09d-5847fba03d21/)\n[Quantum Boltzmann Machine (Gate-based) (PlanQK)](https://platform.planqk.de/algorithms/ae9bac80-672e-432a-983f-a3a7e1a8c92c/)&quot;, &quot;Related Patterns&quot;: &quot;This pattern is a refinement of [Quantum-Classic Split](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/dd15032b-ce2b-40b6-80ac-97623255b531) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf). \nWithin the quantum computation, [Initialization](pattern-languages/af7780d5-1f97-4536-8da7-4194b093ab1d/312bc9d3-26c0-40ae-b90b-56effd136c0d) [(Leymann 2019)](https://www.iaas.uni-stuttgart.de/publications/INPROC-2019-05-Towards_a_Pattern_Language_for_Quantum_Algorithms.pdf) is used.  \n \n&quot;}"/>
            <where>id='cc3731cf-ecbb-490f-b996-525c8f60d8a9'</where>
        </update>
        <update tableName="pattern">
            <column name="icon_url" value="https://quantumcomputingpatterns.org/assets/pattern-icons/uncompute_icon.png"/>
            <where>id='d4f7c247-e2bb-4301-ad06-f758fa58f2dc'</where>
        </update>
        <update tableName="pattern">
            <column name="icon_url" value="http://quantumcomputingpatterns.org/assets/pattern-icons/post_selective_measurement_icon.png"/>
            <where>id='1c95912a-128b-44e7-b2d4-930f7ba11060'</where>
        </update>
        <update tableName="pattern">
            <column name="icon_url" value="https://quantumcomputingpatterns.org/assets/pattern-icons/initialization_icon.png"/>
            <where>id='312bc9d3-26c0-40ae-b90b-56effd136c0d'</where>
        </update>
        
    </changeSet>
</databaseChangeLog>
