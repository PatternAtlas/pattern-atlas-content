<?xml version="1.1" encoding="UTF-8" standalone="no"?>
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                   xmlns:ext="http://www.liquibase.org/xml/ns/dbchangelog-ext"
                   xmlns:pro="http://www.liquibase.org/xml/ns/pro" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd http://www.liquibase.org/xml/ns/pro http://www.liquibase.org/xml/ns/pro/liquibase-pro-4.6.xsd http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.6.xsd">
    <changeSet author="alex" id="1660390145000-1">
        <insert tableName="pattern">
            <column name="id" value="1a5e3708-da39-4356-ab3f-115264da6390"/>
            <column name="name" value="Error Correction"/>
            <column name="uri"
                    value="https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/errorCorrectionPattern"/>
            <column name="content"
                    value="{&quot;Alias&quot;:&quot;Enter your input for this section here.&quot;,&quot;Forces&quot;:&quot;Quantum devices unavoidably cause a certain amount of errors due to the fragility of coherent quantum states [[Devitt et al. 2013](https://iopscience.iop.org/article/10.1088/0034-4885/76/7/076001/meta)]. Furthermore, contrary to classical bits, qubits can not be copied. Hence, classical error correction can\nnot be used for quantum computers and new quantum-specific methods need to be developed. However, these methods can be costly in terms of quantum resources, as they require a large number of additional qubits and quantum gates.\nTo enable scalable quantum computing for real-world problems, all kinds of errors occurring in quantum devices need to be detected and corrected. In general, the correction of errors is preferred over their mitigation, since even minor remaining post-mitigation errors slowly stack up during the computation and ultimately lead to an imprecise result.&quot;,&quot;Intent&quot;:&quot;How to detect and correct errors occurring during the execution of a quantum circuit?&quot;,&quot;Result&quot;:&quot;When applying quantum error correction, computational errors can be prevented, enabling error-free systems of logical qubits. Thus, error correction is making fault-tolerant quantum computation feasible. The good scalability of error correction, enables the accurate execution of large algorithms&quot;,&quot;Context&quot;:&quot;A quantum algorithm needs to be run on a quantum device. The quantum device’s performance is limited by various error sources, such as gate errors and crosstalk. The prevention of these errors enables the execution of large-scale quantum algorithms for real-world problems.&quot;,&quot;Examples&quot;:&quot;The figure below illustrates the application of a 3-qubit variant of the aforementioned error code for multiple qubits. Each of the physical qubits P1 to P4 is transformed into a logical qubit consisting of five physical qubits. Three of these five physical qubits are being used as data qubits and two of them are being used for the detection and recovery process. Further, the 1- and 2-qubit gates G1 to G4 need to be realized by the subroutines S1 to S4, which prepare the data qubits. The resulting errors can then be corrected by individually applying error correction routines for each of the logical qubits.\n![](https://quantumcomputingpatterns.org/assets/sketches/error-correction-example-1.svg)&quot;,&quot;Solution&quot;:&quot;Detect and correct quantum errors using quantum error correction codes [[Devitt et al. 2013](https://iopscience.iop.org/article/10.1088/0034-4885/76/7/076001/meta)]., which are added to the executed circuit. With these correction codes, many physical qubits are combined into one logical qubit. As a result of\nthis bundling, errors in the original qubit can be first detected and then corrected. The figure below depicts a solution sketch showcasing the general building blocks of a quantum error correction procedure. The shown instance applies an error correction code that can detect and fix bit-flip errors in the computational basis. For the correction of errors from other sources, similar processes can be applied. First, the ancilla coupling is created, by encoding the state $\\ket{\\psi}$ of a single physical qubit into multiple ancilla qubits. These qubits now hold the logical qubit’s data and are called data qubits in the following. Next, some unitary transformation is applied to the logical qubit, possibly resulting in an error. In order to detect an error, additional ancilla qubits are employed to check the parity of the data qubits. Based on the discovered syndrome, the error-free state can be recovered in the recovery phase. Note that the process is assumed to only have errors at the unitary transformation step, which is denoted by the error indicator. Further, the number and type of detectable errors depends on the applied error correction code.\n![](https://quantumcomputingpatterns.org/assets/sketches/error-correction-solution-sketch.svg)&quot;,&quot;Known Uses&quot;:&quot;Known Uses: [Laflamme et al.](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.77.198) show a 5-qubit error correction code that can protect a qubit against general 1-qubit errors. Shor’s 9-qubit code can protect a qubit against single bit-flip and phase-flip errors [[Shor 1995]](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.52.R2493). Further, a variety of different quantum error correction codes have been presented in the literature [[Devitt et al. 2013](https://iopscience.iop.org/article/10.1088/0034-4885/76/7/076001/meta)], [[Cai et al. 2021]](https://www.sciencedirect.com/science/article/pii/S2667325820300145), [[Gottesman et al. 1997]](https://arxiv.org/pdf/quant-ph/9705052.pdf), [[Roffe 2019]](https://www.tandfonline.com/doi/full/10.1080/00107514.2019.1667078)&quot;,&quot;Related Pattern&quot;:&quot;Enter your input for this section here.&quot;}"/>
            <column name="icon_url"
                    value="https://quantumcomputingpatterns.org/assets/pattern-icons/error_correction_icon.png"/>
            <column name="rendered_content"
                    value="{&quot;Alias&quot;:&quot;Enter your input for this section here.&quot;,&quot;Forces&quot;:&quot;Quantum devices unavoidably cause a certain amount of errors due to the fragility of coherent quantum states [[Devitt et al. 2013](https://iopscience.iop.org/article/10.1088/0034-4885/76/7/076001/meta)]. Furthermore, contrary to classical bits, qubits can not be copied. Hence, classical error correction can\nnot be used for quantum computers and new quantum-specific methods need to be developed. However, these methods can be costly in terms of quantum resources, as they require a large number of additional qubits and quantum gates.\nTo enable scalable quantum computing for real-world problems, all kinds of errors occurring in quantum devices need to be detected and corrected. In general, the correction of errors is preferred over their mitigation, since even minor remaining post-mitigation errors slowly stack up during the computation and ultimately lead to an imprecise result.&quot;,&quot;Intent&quot;:&quot;How to detect and correct errors occurring during the execution of a quantum circuit?&quot;,&quot;Result&quot;:&quot;When applying quantum error correction, computational errors can be prevented, enabling error-free systems of logical qubits. Thus, error correction is making fault-tolerant quantum computation feasible. The good scalability of error correction, enables the accurate execution of large algorithms&quot;,&quot;Context&quot;:&quot;A quantum algorithm needs to be run on a quantum device. The quantum device’s performance is limited by various error sources, such as gate errors and crosstalk. The prevention of these errors enables the execution of large-scale quantum algorithms for real-world problems.&quot;,&quot;Examples&quot;:&quot;The figure below illustrates the application of a 3-qubit variant of the aforementioned error code for multiple qubits. Each of the physical qubits P1 to P4 is transformed into a logical qubit consisting of five physical qubits. Three of these five physical qubits are being used as data qubits and two of them are being used for the detection and recovery process. Further, the 1- and 2-qubit gates G1 to G4 need to be realized by the subroutines S1 to S4, which prepare the data qubits. The resulting errors can then be corrected by individually applying error correction routines for each of the logical qubits.\n![](https://quantumcomputingpatterns.org/assets/sketches/error-correction-example-1.svg)&quot;,&quot;Solution&quot;:&quot;Detect and correct quantum errors using quantum error correction codes [[Devitt et al. 2013](https://iopscience.iop.org/article/10.1088/0034-4885/76/7/076001/meta)]., which are added to the executed circuit. With these correction codes, many physical qubits are combined into one logical qubit. As a result of\nthis bundling, errors in the original qubit can be first detected and then corrected. The figure below depicts a solution sketch showcasing the general building blocks of a quantum error correction procedure. The shown instance applies an error correction code that can detect and fix bit-flip errors in the computational basis. For the correction of errors from other sources, similar processes can be applied. First, the ancilla coupling is created, by encoding the state $\\ket{\\psi}$ of a single physical qubit into multiple ancilla qubits. These qubits now hold the logical qubit’s data and are called data qubits in the following. Next, some unitary transformation is applied to the logical qubit, possibly resulting in an error. In order to detect an error, additional ancilla qubits are employed to check the parity of the data qubits. Based on the discovered syndrome, the error-free state can be recovered in the recovery phase. Note that the process is assumed to only have errors at the unitary transformation step, which is denoted by the error indicator. Further, the number and type of detectable errors depends on the applied error correction code.\n![](https://quantumcomputingpatterns.org/assets/sketches/error-correction-solution-sketch.svg)&quot;,&quot;Known Uses&quot;:&quot;Known Uses: [Laflamme et al.](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.77.198) show a 5-qubit error correction code that can protect a qubit against general 1-qubit errors. Shor’s 9-qubit code can protect a qubit against single bit-flip and phase-flip errors [[Shor 1995]](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.52.R2493). Further, a variety of different quantum error correction codes have been presented in the literature [[Devitt et al. 2013](https://iopscience.iop.org/article/10.1088/0034-4885/76/7/076001/meta)], [[Cai et al. 2021]](https://www.sciencedirect.com/science/article/pii/S2667325820300145), [[Gottesman et al. 1997]](https://arxiv.org/pdf/quant-ph/9705052.pdf), [[Roffe 2019]](https://www.tandfonline.com/doi/full/10.1080/00107514.2019.1667078)&quot;,&quot;Related Pattern&quot;:&quot;Enter your input for this section here.&quot;}"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="paper_ref"
                    value="https://www.thinkmind.org/index.php?view=article&amp;articleid=patterns_2022_2_10_70007"/>
        </insert>
        <insert schemaName="public" tableName="pattern">
            <column name="id" value="ed3af509-904e-4732-8113-215d65a7d53d"/>
            <column name="name" value="Readout Error Mitigation"/>
            <column name="uri"
                    value="https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/readoutErrorMitigation"/>
            <column name="content"
                    value="{&quot;Alias&quot;:&quot;Enter your input for this section here.&quot;,&quot;Forces&quot;:&quot;The measurement times of quantum computers in the NISQ era are significant in comparison to their decoherence times. Therefore, the measurements are highly error-prone and often are among the main error sources. Due to the limited capabilities of current NISQ devices, a minimal number of additional qubits and quantum gates shall be used for the mitigation of readout errors. Further, a quantum device’s measurement error rates change over time, thus the Readout Error Mitigation (REM) needs to be adaptive.&quot;,&quot;Intent&quot;:&quot;How to reduce the impact of erroneous measurements such that the measured result is closer to the intended quantum state?&quot;,&quot;Result&quot;:&quot;REM can reduce the impact of errors caused by measurement operations. The resulting, more precise probability distributions make NISQ devices more suitable for real-world use cases. However, additional classical processing is necessary, which can significantly increase the runtime and classical resource requirements, as not all mitigation methods scale well with the number of qubits. Generally, data provenance can be employed to increase the efficiency of frequently occurring REM tasks, e.g., when executing a VQA.&quot;,&quot;Context&quot;:&quot;A NISQ-compatible quantum algorithm, e.g., QAOA or VQE, needs to be run on a quantum device. The device’s decoherence times are short and the measurement operations are error-prone. Hence, the measured probability distribution is inaccurate, even when the measured quantum state is accurate. Thus, the negative impact of readout errors needs to be mitigated to obtain a precise measurement result.&quot;,&quot;Examples&quot;:&quot;The figure below illustrates the steps of the Static Invert-and-Measure (SIM) technique[[Tannu et al.]](https://dl.acm.org/doi/abs/10.1145/3352460.3358265). First, multiple slightly adapted instances of the circuit are created. Thereby, bit-flips are added right before the circuit’s measurement operations. This helps to detect erroneous measurements because readout error rates are typically higher when measuring a qubit in the $\\ket{1}$ state than when measuring it in the $\\ket{0}$ state. Once all circuits are executed, the measurement results are processed, returning the mitigated probability distribution.\n![](https://quantumcomputingpatterns.org/assets/sketches/readout-error-mitigation-example1.svg) \n\n\nThe figure below shows the typical process of a calibration matrix-based mitigation method. Multiple shallow calibration circuits are generated and executed. The resulting probability distributions give information about the device’s readout error rates. These error rates are then incorporated into a so-called calibration matrix, which can be used to mitigate readout errors. For example, this can be done by multiplying the inverse of the calibration matrix with the circuit’s measurement result.\n![](https://quantumcomputingpatterns.org/assets/sketches/readout-error-mitigation-example2.svg) &quot;,&quot;Solution&quot;:&quot;Mitigate the impact of readout errors by applying a REM method. The mitigation method is performed after the circuit execution and adjusts the measured probability distribution. The resulting mitigated probability distribution is a more accurate representation of the intended quantum state. A solution sketch for the application of REM is shown in figure below. First, the quantum circuit is implemented and executed. Then the resulting probability distribution is improved based on measurement characteristics collected for the quantum device. These characteristics are typically obtained by separately running so-called calibration circuits. Alternatively, adapted instances of the implemented circuit can be run to obtain additional information about the measurement properties.\n![](https://quantumcomputingpatterns.org/assets/sketches/readout-error-mitigation-solution-sketch.svg)&quot;,&quot;Known Uses&quot;:&quot;Various REM methods, e.g., calibration matrix-based [[Bravyi et al.]](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.103.042605)[[Nachman et al.]](https://www.nature.com/articles/s41534-020-00309-7)[[Maciejewski et al.]](https://quantum-journal.org/papers/q-2020-04-24-257/)[[Nation et al.]](https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.2.040326) or bit-flip-based [[Tannu et al.]](https://dl.acm.org/doi/abs/10.1145/3352460.3358265)[[Smith et al.]](https://www.science.org/doi/full/10.1126/sciadv.abi8009),have been introduced in the literature. Moreover, recent work introduces a deep learning-based REM method [[Kim et al.]](https://iopscience.iop.org/article/10.1088/1367-2630/ac7b3d/pdf).&quot;,&quot;Related Pattern&quot;:&quot;Enter your input for this section here.&quot;}"/>
            <column name="icon_url"
                    value="https://quantumcomputingpatterns.org/assets/pattern-icons/readout_error_mitigation_icon.png"/>
            <column name="rendered_content"
                    value="{&quot;Alias&quot;:&quot;Enter your input for this section here.&quot;,&quot;Forces&quot;:&quot;The measurement times of quantum computers in the NISQ era are significant in comparison to their decoherence times. Therefore, the measurements are highly error-prone and often are among the main error sources. Due to the limited capabilities of current NISQ devices, a minimal number of additional qubits and quantum gates shall be used for the mitigation of readout errors. Further, a quantum device’s measurement error rates change over time, thus the Readout Error Mitigation (REM) needs to be adaptive.&quot;,&quot;Intent&quot;:&quot;How to reduce the impact of erroneous measurements such that the measured result is closer to the intended quantum state?&quot;,&quot;Result&quot;:&quot;REM can reduce the impact of errors caused by measurement operations. The resulting, more precise probability distributions make NISQ devices more suitable for real-world use cases. However, additional classical processing is necessary, which can significantly increase the runtime and classical resource requirements, as not all mitigation methods scale well with the number of qubits. Generally, data provenance can be employed to increase the efficiency of frequently occurring REM tasks, e.g., when executing a VQA.&quot;,&quot;Context&quot;:&quot;A NISQ-compatible quantum algorithm, e.g., QAOA or VQE, needs to be run on a quantum device. The device’s decoherence times are short and the measurement operations are error-prone. Hence, the measured probability distribution is inaccurate, even when the measured quantum state is accurate. Thus, the negative impact of readout errors needs to be mitigated to obtain a precise measurement result.&quot;,&quot;Examples&quot;:&quot;The figure below illustrates the steps of the Static Invert-and-Measure (SIM) technique[[Tannu et al.]](https://dl.acm.org/doi/abs/10.1145/3352460.3358265). First, multiple slightly adapted instances of the circuit are created. Thereby, bit-flips are added right before the circuit’s measurement operations. This helps to detect erroneous measurements because readout error rates are typically higher when measuring a qubit in the $\\ket{1}$ state than when measuring it in the $\\ket{0}$ state. Once all circuits are executed, the measurement results are processed, returning the mitigated probability distribution.\n![](https://quantumcomputingpatterns.org/assets/sketches/readout-error-mitigation-example1.svg) \n\n\nThe figure below shows the typical process of a calibration matrix-based mitigation method. Multiple shallow calibration circuits are generated and executed. The resulting probability distributions give information about the device’s readout error rates. These error rates are then incorporated into a so-called calibration matrix, which can be used to mitigate readout errors. For example, this can be done by multiplying the inverse of the calibration matrix with the circuit’s measurement result.\n![](https://quantumcomputingpatterns.org/assets/sketches/readout-error-mitigation-example2.svg) &quot;,&quot;Solution&quot;:&quot;Mitigate the impact of readout errors by applying a REM method. The mitigation method is performed after the circuit execution and adjusts the measured probability distribution. The resulting mitigated probability distribution is a more accurate representation of the intended quantum state. A solution sketch for the application of REM is shown in figure below. First, the quantum circuit is implemented and executed. Then the resulting probability distribution is improved based on measurement characteristics collected for the quantum device. These characteristics are typically obtained by separately running so-called calibration circuits. Alternatively, adapted instances of the implemented circuit can be run to obtain additional information about the measurement properties.\n![](https://quantumcomputingpatterns.org/assets/sketches/readout-error-mitigation-solution-sketch.svg)&quot;,&quot;Known Uses&quot;:&quot;Various REM methods, e.g., calibration matrix-based [[Bravyi et al.]](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.103.042605)[[Nachman et al.]](https://www.nature.com/articles/s41534-020-00309-7)[[Maciejewski et al.]](https://quantum-journal.org/papers/q-2020-04-24-257/)[[Nation et al.]](https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.2.040326) or bit-flip-based [[Tannu et al.]](https://dl.acm.org/doi/abs/10.1145/3352460.3358265)[[Smith et al.]](https://www.science.org/doi/full/10.1126/sciadv.abi8009),have been introduced in the literature. Moreover, recent work introduces a deep learning-based REM method [[Kim et al.]](https://iopscience.iop.org/article/10.1088/1367-2630/ac7b3d/pdf).&quot;,&quot;Related Pattern&quot;:&quot;Enter your input for this section here.&quot;}"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="paper_ref"
                    value="https://www.thinkmind.org/index.php?view=article&amp;articleid=patterns_2022_2_10_70007"/>
        </insert>
        <insert schemaName="public" tableName="pattern">
            <column name="id" value="b6788c99-24f5-496b-a30c-fc0dd7bb3e96"/>
            <column name="name" value="Gate Error Mitigation"/>
            <column name="uri"
                    value="https://patternpedia.org/patternLanguages/quantumAlgorithmPatterns/gateErrorMitigationPattern"/>
            <column name="content"
                    value="{&quot;Alias&quot;:&quot;Enter your input for this section here.&quot;,&quot;Forces&quot;:&quot;The execution of gates on current NISQ devices is not perfectly accurate. Hence, every execution of a gate causes a minor error. These errors keep accumulating, eventually making large computations impossible. The pulses used for the implementation of gate operations can be controlled on many quantum devices. Therefore, custom pulse schedules can be used to individually calibrate gates. Furthermore, the capabilities of current quantum devices are limited, e.g., the number of qubits and the decoherence times are bound. Thus, minimal additional quantum resources, such as gates and qubits, shall be used for error mitigation.&quot;,&quot;Intent&quot;:&quot;How to reduce the negative impact of noisy gate executions such that the pre-measurement state is closer to the expected error-free state?&quot;,&quot;Result&quot;:&quot;GEM can significantly reduce the impact of errors caused by erroneous gate executions. As a consequence, the state computed by the quantum algorithm is closer to the expected error-free quantum state and a more precise algorithm result can be obtained. However, the mitigation process may induce additional quantum gates into the circuit or require classical pre-processing to calculate optimal device calibrations, e.g., gate pulse calibrations. Generally, GEM methods can be used in combination with other error mitigation methods, such as REM to reduce the overall error further.&quot;,&quot;Context&quot;:&quot;A NISQ-compatible quantum algorithm, e.g., VQE, needs to be run on a quantum device. The device’s gate implementations are error-prone, causing errors in the quantum computation. To obtain precise results for the executed algorithm, the measured state needs to be computed accurately. Thus, it is crucial to mitigate the effects of gate errors.&quot;,&quot;Examples&quot;:&quot;The figure below shows the process of a typical gate addition-based method. These methods mitigate gate errors by adding additional gates to the quantum circuit that balance out gate errors. The initial quantum circuit is modified by adding specific gates for each error-prone operation. Hence, the depth of the circuit increases significantly. Therefore, the device’s decoherence times need to be kept in mind, as otherwise, the mitigation might decrease the result quality. \n![](https://quantumcomputingpatterns.org/assets/sketches/gate-error-mitigation-solution-example1.svg)\nThe figure below depicts the typical process of a pulse calibration method. First, the pulse calibrations for the device are generated, e.g., it is determined which frequency is perfect to perform a bit-flip operation on a specific qubit. Once all required frequencies are determined, the information can be incorporated into the quantum circuit. When executing the modified circuit, the custom pulse calibrations will now be used instead of the default values. More precise pulse calibrations make gate executions more accurate, thus, decreasing gate error rates and increasing the solution’s precision\n![](https://quantumcomputingpatterns.org/assets/sketches/gate-error-mitigation-solution-example1.svg)&quot;,&quot;Solution&quot;:&quot;Mitigate the impact of gate errors by applying a Gate Error Mitigation (GEM) method. The mitigation of gate errors has to be performed before the execution of the quantum circuit, as occurring errors otherwise accumulate during the computation, making it difficult to retrace them. The resulting pre-measurement quantum state is closer to the expected error-free state, therefore, providing more accurate measurement results. The figure below depicts a solution sketch for GEM. First, the circuit is implemented. Afterwards, a GEM method is applied, modifying the circuit, to generate a more precise implementation for the selected device. The circuit modifications can range from simple gate additions over custom gate pulse adjustments to full circuit rewrites based on Machine Learning (ML). Next, the improved circuit is executed on the quantum device. Finally, the improved measurement result can be evaluated to obtain a more precise solution.\n![](https://quantumcomputingpatterns.org/assets/sketches/gate-error-mitigation-solution-sketch.svg)&quot;,&quot;Known Uses&quot;:&quot;Several circuit adjustment methods, e.g., FIIM or Random Identity Insertion (RIIM), are presented in the literature [[Nachman et al.]](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.012426),[[Temme et al.]](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.119.180509),[[Harper et al.]](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.080504). Further, machine learning-based circuit adjustment methods have been introduced, e.g., Noise-Aware Circuit Learning (NACL) [[Cincio et al.]](https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.2.010324). Moreover, pulse modification-based GEM methods have been presented [[Carvalho et al.]](https://journals.aps.org/prapplied/abstract/10.1103/PhysRevApplied.15.064054),[[Giurgica-Tiron et al.]](https://ieeexplore.ieee.org/abstract/document/9259940).&quot;,&quot;Related Pattern&quot;:&quot;Enter your input for this section here.&quot;}"/>
            <column name="icon_url"
                    value="https://quantumcomputingpatterns.org/assets/pattern-icons/gate_error_mitigation_icon.png"/>
            <column name="rendered_content"
                    value="{&quot;Alias&quot;:&quot;Enter your input for this section here.&quot;,&quot;Forces&quot;:&quot;The execution of gates on current NISQ devices is not perfectly accurate. Hence, every execution of a gate causes a minor error. These errors keep accumulating, eventually making large computations impossible. The pulses used for the implementation of gate operations can be controlled on many quantum devices. Therefore, custom pulse schedules can be used to individually calibrate gates. Furthermore, the capabilities of current quantum devices are limited, e.g., the number of qubits and the decoherence times are bound. Thus, minimal additional quantum resources, such as gates and qubits, shall be used for error mitigation.&quot;,&quot;Intent&quot;:&quot;How to reduce the negative impact of noisy gate executions such that the pre-measurement state is closer to the expected error-free state?&quot;,&quot;Result&quot;:&quot;GEM can significantly reduce the impact of errors caused by erroneous gate executions. As a consequence, the state computed by the quantum algorithm is closer to the expected error-free quantum state and a more precise algorithm result can be obtained. However, the mitigation process may induce additional quantum gates into the circuit or require classical pre-processing to calculate optimal device calibrations, e.g., gate pulse calibrations. Generally, GEM methods can be used in combination with other error mitigation methods, such as REM to reduce the overall error further.&quot;,&quot;Context&quot;:&quot;A NISQ-compatible quantum algorithm, e.g., VQE, needs to be run on a quantum device. The device’s gate implementations are error-prone, causing errors in the quantum computation. To obtain precise results for the executed algorithm, the measured state needs to be computed accurately. Thus, it is crucial to mitigate the effects of gate errors.&quot;,&quot;Examples&quot;:&quot;The figure below shows the process of a typical gate addition-based method. These methods mitigate gate errors by adding additional gates to the quantum circuit that balance out gate errors. The initial quantum circuit is modified by adding specific gates for each error-prone operation. Hence, the depth of the circuit increases significantly. Therefore, the device’s decoherence times need to be kept in mind, as otherwise, the mitigation might decrease the result quality. \n![](https://quantumcomputingpatterns.org/assets/sketches/gate-error-mitigation-solution-example1.svg)\nThe figure below depicts the typical process of a pulse calibration method. First, the pulse calibrations for the device are generated, e.g., it is determined which frequency is perfect to perform a bit-flip operation on a specific qubit. Once all required frequencies are determined, the information can be incorporated into the quantum circuit. When executing the modified circuit, the custom pulse calibrations will now be used instead of the default values. More precise pulse calibrations make gate executions more accurate, thus, decreasing gate error rates and increasing the solution’s precision\n![](https://quantumcomputingpatterns.org/assets/sketches/gate-error-mitigation-solution-example1.svg)&quot;,&quot;Solution&quot;:&quot;Mitigate the impact of gate errors by applying a Gate Error Mitigation (GEM) method. The mitigation of gate errors has to be performed before the execution of the quantum circuit, as occurring errors otherwise accumulate during the computation, making it difficult to retrace them. The resulting pre-measurement quantum state is closer to the expected error-free state, therefore, providing more accurate measurement results. The figure below depicts a solution sketch for GEM. First, the circuit is implemented. Afterwards, a GEM method is applied, modifying the circuit, to generate a more precise implementation for the selected device. The circuit modifications can range from simple gate additions over custom gate pulse adjustments to full circuit rewrites based on Machine Learning (ML). Next, the improved circuit is executed on the quantum device. Finally, the improved measurement result can be evaluated to obtain a more precise solution.\n![](https://quantumcomputingpatterns.org/assets/sketches/gate-error-mitigation-solution-sketch.svg)&quot;,&quot;Known Uses&quot;:&quot;Several circuit adjustment methods, e.g., FIIM or Random Identity Insertion (RIIM), are presented in the literature [[Nachman et al.]](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.012426),[[Temme et al.]](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.119.180509),[[Harper et al.]](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.122.080504). Further, machine learning-based circuit adjustment methods have been introduced, e.g., Noise-Aware Circuit Learning (NACL) [[Cincio et al.]](https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.2.010324). Moreover, pulse modification-based GEM methods have been presented [[Carvalho et al.]](https://journals.aps.org/prapplied/abstract/10.1103/PhysRevApplied.15.064054),[[Giurgica-Tiron et al.]](https://ieeexplore.ieee.org/abstract/document/9259940).&quot;,&quot;Related Pattern&quot;:&quot;Enter your input for this section here.&quot;}"/>
            <column name="pattern_language_id" value="af7780d5-1f97-4536-8da7-4194b093ab1d"/>
            <column name="paper_ref"
                    value="https://www.thinkmind.org/index.php?view=article&amp;articleid=patterns_2022_2_10_70007"/>
        </insert>
    </changeSet>
</databaseChangeLog>